<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:llrp="http://www.llrp.org/ltk/schema/core/encoding/binary/1.0"
  xmlns:h="http://www.w3.org/1999/xhtml">
  <xsl:output omit-xml-declaration='yes' method='text' indent='yes'/>
  <xsl:variable name='vendor_name'>
    <xsl:value-of select="/llrp:llrpdef/llrp:vendorDefinition/@name"/>
  </xsl:variable>
  <xsl:variable name ="vendor_id">
    <xsl:value-of select="/llrp:llrpdef/llrp:vendorDefinition/@vendorID"/>
  </xsl:variable>
  <xsl:variable name='prefix'>
    <xsl:value-of select="/llrp:llrpdef/llrp:namespaceDefinition/@prefix"/>
  </xsl:variable>
  <xsl:variable name ="uri">
    <xsl:value-of select="/llrp:llrpdef/llrp:namespaceDefinition/@URI"/>
  </xsl:variable>
  <xsl:variable name ="schemaLocation">
    <xsl:value-of select="/llrp:llrpdef/llrp:namespaceDefinition/@schemaLocation"/>
  </xsl:variable>
  <xsl:template match="/llrp:llrpdef">
/*
 ***************************************************************************
 *
 *  Copyright 2009 Impinj, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ***************************************************************************
 */

/*
 ***************************************************************************
 *
 *  This code is generated by Impinj LLRP .Net generator. Modification
 *  is not recommended.
 *
 ***************************************************************************
 */

/*
 ***************************************************************************
 * File Name:       VendorExt.cs
 * Author:          Your Name
 * Organization:    Your Company
 * Date:            Date
 * Description:     This file contains LLRP vendor extension
 ***************************************************************************
*/

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml;
using System.Xml.Schema;
using System.ComponentModel;
using System.Reflection;

using Org.LLRP.LTK.LLRPV1;
using Org.LLRP.LTK.LLRPV1.DataType;

namespace Org.LLRP.LTK.LLRPV1.<xsl:copy-of select="$prefix"/>
{
    public class LLRPExtensionConstants
    {
        public const string NAMESPACE_PREFIX = "<xsl:copy-of select="$prefix"/>";
        public const string NAMESPACE_URI = "<xsl:copy-of select="$uri"/>";
        public const string NAMESPACE_SCHEMALOCATION = "<xsl:copy-of select="$schemaLocation"/>";
        public const string VENDOR_NAME = "<xsl:copy-of select="$vendor_name"/>";
        public const string VENDOR_ID = "<xsl:copy-of select="$vendor_id"/>";
    }

    public class <xsl:copy-of select="$prefix"/>_Installer
    {
        public static void Install()
        {
            Assembly asm = Assembly.GetExecutingAssembly();
            CustomMsgDecodeFactory.LoadVendorExtensionAssembly(asm);
            CustomParamDecodeFactory.LoadVendorExtensionAssembly(asm);
        }
    }

    #region Custom Parameter Interface
    <xsl:for-each select ="llrp:customMessageDefinition">
      <xsl:variable name="custom_msg_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
      <xsl:for-each select="llrp:parameter">
        <xsl:if test="@type='Custom'">
    public interface I<xsl:copy-of select="$custom_msg_name"/>_Custom_Param : ICustom_Parameter {}
        </xsl:if>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:for-each select ="llrp:customParameterDefinition">
      <xsl:variable name="custom_param_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
      <xsl:for-each select="llrp:parameter">
        <xsl:if test="@type='Custom'">
    public interface I<xsl:copy-of select="$custom_param_name"/>_Custom_Param : ICustom_Parameter {}
        </xsl:if>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:for-each select ="llrp:customChoiceDefinition">
      <xsl:variable name="custom_choice_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
      <xsl:for-each select="llrp:parameter">
        <xsl:if test="@type='Custom'">
    public interface I<xsl:copy-of select="$custom_choice_name"/>_Custom_Param : ICustom_Parameter {}
        </xsl:if>
      </xsl:for-each>
    </xsl:for-each>
    #endregion

    <xsl:for-each select="llrp:customChoiceDefinition">
      <xsl:variable name="choice_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
    ///<xsl:text disable-output-escaping="yes">&lt;</xsl:text>summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
    ///Allowed types: <xsl:for-each select="llrp:parameter">PARAM_<xsl:value-of select="@type"/>, </xsl:for-each>
    ///<xsl:text disable-output-escaping="yes">&lt;</xsl:text>/summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
    public class UNION_<xsl:value-of select="@name"/> : ParamArrayList
    {
      <xsl:for-each select="llrp:parameter">
        <xsl:if test="@type='Custom'">
        public bool AddCustomParameter(ICustom_Parameter param)
        {
            I<xsl:copy-of select='$choice_name'/>_Custom_Param custom =
                param as I<xsl:copy-of select='$choice_name'/>_Custom_Param;
            if (custom != null)
            {
                Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Add(param);
                return true;
            }

            return false;
        }
        </xsl:if>
      </xsl:for-each>
    }
    </xsl:for-each>
    public class PARAM_<xsl:copy-of select="$vendor_name"/>_Custom : PARAM_Custom
    {
        //Add vendor custom parameter implementation while applicable.
        public override void ToBitArray(ref bool[] bit_array, ref int cursor) { }
        public new static PARAM_<xsl:copy-of select="$vendor_name"/>_Custom FromBitArray(ref BitArray bit_array, ref int cursor, int length) { return null; }
        public override string ToString() { return null; }
        public new static PARAM_<xsl:copy-of select="$vendor_name"/>_Custom FromXmlNode(XmlNode node) { return null; }
    }

    <xsl:for-each select="llrp:customEnumerationDefinition">
      <xsl:call-template name ="Comments"/>
    public enum ENUM_<xsl:value-of select="@name"/>
    {
        <xsl:for-each select="llrp:entry">
          <xsl:value-of select="@name"/> = <xsl:value-of select="@value"/>,
        </xsl:for-each>
    }
    </xsl:for-each>
    <xsl:for-each select="llrp:customParameterDefinition">
      <xsl:variable name="inherited_interfaces">
        <xsl:for-each select="llrp:allowedIn">,I<xsl:value-of select="@type"/>_Custom_Param</xsl:for-each>
      </xsl:variable>
      <xsl:variable name="param_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
      <xsl:call-template name ="Comments"/>
    public class PARAM_<xsl:value-of select="@name"/> : PARAM_Custom<xsl:copy-of select="$inherited_interfaces"/>
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_<xsl:value-of select="@name"/>()
        {
            VendorIdentifier = <xsl:copy-of select="$vendor_id"/>;
            ParameterSubtype = <xsl:value-of select="@subtype"/>;
        }
      <xsl:for-each select="*">
        <xsl:if test="name()='field'">
        public <xsl:call-template name='DefineDataType'/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:call-template name='DefineDefaultValue'/>
          <xsl:call-template name="DefineDataLength"/>
        </xsl:if>
        <xsl:if test="name()='reserved'">
        private const UInt16 param_reserved_len<xsl:copy-of select="position()"/>= <xsl:value-of select="@bitCount"/>;
        </xsl:if>
        <xsl:if test="name()='parameter'">
          <xsl:choose>
            <xsl:when test="@type='Custom'">
        public readonly CustomParameterArrayList <xsl:call-template name='DefineParameterName'/> = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            I<xsl:copy-of select='$param_name'/>_Custom_Param custom =
                param as I<xsl:copy-of select='$param_name'/>_Custom_Param;
            if (custom != null)
            {
                <xsl:call-template name='DefineParameterName'/>.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                <xsl:call-template name='DefineParameterName'/>.Add(param);
                return true;
            }

            return false;
        }
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="contains(@repeat, '0-N') or contains(@repeat, '1-N')">
        public PARAM_<xsl:value-of select="@type"/>[] <xsl:call-template name='DefineParameterName'/>;
                </xsl:when>
                <xsl:otherwise>
        public PARAM_<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:call-template name='DefineParameterName'/>;
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
        <xsl:if test="name()='choice'">
          <xsl:variable name="choiceParameterName">
            <xsl:call-template name='DefineParameterName'/>
          </xsl:variable>
        public UNION_<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:call-template name='DefineParameterName'/> = new UNION_<xsl:value-of select="@type"/>();
        </xsl:if>
      </xsl:for-each>

      <xsl:call-template name="VendorPARAMEncodeToBitArray"/>
      <xsl:call-template name="VendorPARAMDecodeFromBitArray"/>
      <xsl:call-template name="VendorPARAMToString"/>
      <xsl:call-template name="VendorPARAMFromXmlNode"/>
    }
    </xsl:for-each>
    <xsl:for-each select="llrp:customMessageDefinition">
      <xsl:call-template name ="Comments"/>
      <xsl:variable name="msg_name">
        <xsl:value-of select="@name"/>
      </xsl:variable>
    public class MSG_<xsl:value-of select="@name"/> : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_<xsl:value-of select="@name"/>()
        {
            VendorIdentifier = <xsl:copy-of select="$vendor_id"/>;
            MessageSubtype = <xsl:value-of select="@subtype"/>;
            <!-- This hack is kept for backward compatibility. Ideally this
                 would go far, far away sometime eventually... -->
      <xsl:if test="contains(@name, 'ENABLE_EXTENSION') and not(contains(@name, 'RESPONSE'))">
            Assembly asm = Assembly.GetExecutingAssembly();
            CustomMsgDecodeFactory.LoadVendorExtensionAssembly(asm);
            CustomParamDecodeFactory.LoadVendorExtensionAssembly(asm);
      </xsl:if>
        }
      <xsl:for-each select="*">
        <xsl:if test="name()='field'">
        public <xsl:call-template name='DefineDataType'/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:call-template name='DefineDefaultValue'/>
          <xsl:call-template name="DefineDataLength"/>
        </xsl:if>
        <xsl:if test="name()='reserved'">
        private const UInt16 param_reserved_len<xsl:copy-of select="position()"/> = <xsl:value-of select="@bitCount"/>;
        </xsl:if>
        <xsl:if test="name()='parameter'">
          <xsl:choose>
            <xsl:when test="@type='Custom'">
        public readonly CustomParameterArrayList <xsl:call-template name='DefineParameterName'/> = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            I<xsl:copy-of select='$msg_name'/>_Custom_Param custom =
                param as I<xsl:copy-of select='$msg_name'/>_Custom_Param;
            if (custom != null)
            {
                <xsl:call-template name='DefineParameterName'/>.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                <xsl:call-template name='DefineParameterName'/>.Add(param);
                return true;
            }

            return false;
        }
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="contains(@repeat, '0-N') or contains(@repeat, '1-N')">
        public PARAM_<xsl:value-of select="@type"/>[] <xsl:call-template name='DefineParameterName'/>;
                </xsl:when>
                <xsl:otherwise>
        public PARAM_<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:call-template name='DefineParameterName'/>;
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
        <xsl:if test="name()='choice'">
        public UNION_<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:call-template name='DefineParameterName'/> = new UNION_<xsl:value-of select="@type"/>();
        </xsl:if>
      </xsl:for-each>
      <xsl:call-template name="VendorMSGEncodeToBitArray"/>
      <xsl:call-template name="VendorMSGDecodeFromBitArray"/>
      <xsl:call-template name="VendorMSGToString"/>
      <xsl:call-template name="VendorMSGFromString"/>
      <xsl:call-template name="VendorMSGToCustomMessage"/>
      <xsl:call-template name="VendorMSGFromCustomMessage"/>
    }
    </xsl:for-each>
}
  </xsl:template>
  <xsl:include href="templates.xslt"/>
</xsl:stylesheet>
