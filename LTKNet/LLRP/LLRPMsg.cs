
/*
 ***************************************************************************
 *  Copyright 2007 Impinj, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ***************************************************************************
 */


/*
 ***************************************************************************
 *
 *  This code is generated by Impinj LLRP .Net generator. Modification
 *  is not recommended.
 *
 ***************************************************************************
 */

/*
 ***************************************************************************
 * File Name:       LLRPMsg.cs
 *
 * Version:         1.0
 * Author:          Impinj
 * Organization:    Impinj
 * Date:            Jan. 18, 2008
 *
 * Description:     This file contains LLRP message definitions
 ***************************************************************************
*/

using System;
using System.IO;
using System.Text;
using System.Collections;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Runtime.InteropServices;

using Org.LLRP.LTK.LLRPV1.DataType;

namespace Org.LLRP.LTK.LLRPV1
{
    #region Custom Parameter Interface
    
    public interface IGET_READER_CAPABILITIES_Custom_Param : ICustom_Parameter {}
        
    public interface IGET_READER_CAPABILITIES_RESPONSE_Custom_Param : ICustom_Parameter {}
        
    public interface IGET_READER_CONFIG_Custom_Param : ICustom_Parameter {}
        
    public interface IGET_READER_CONFIG_RESPONSE_Custom_Param : ICustom_Parameter {}
        
    public interface ISET_READER_CONFIG_Custom_Param : ICustom_Parameter {}
        
    public interface IRO_ACCESS_REPORT_Custom_Param : ICustom_Parameter {}
        
    #endregion

    // LLRP message definitions
    
    ///<summary>
    ///
    ///This message is sent from the Client to the Reader. The Client is able to request only a subset or all the capabilities from the Reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=44&amp;view=fit">LLRP Specification Section 9.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=117&amp;view=fit">LLRP Specification Section 16.1.1,</see>
    ///</summary>
    public class MSG_GET_READER_CAPABILITIES : Message
    {
      
        public ENUM_GetReaderCapabilitiesRequestedData RequestedData;
        private Int16 RequestedData_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGET_READER_CAPABILITIES_Custom_Param custom =
                param as IGET_READER_CAPABILITIES_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_GET_READER_CAPABILITIES()
        {
            msgType = 1;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_READER_CAPABILITIES";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (RequestedData != null)
            {
                try
                {
          
                    xml_str += "  <RequestedData>" + RequestedData.ToString() + "</RequestedData>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</GET_READER_CAPABILITIES>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_READER_CAPABILITIES
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_READER_CAPABILITIES</returns>
        public new static MSG_GET_READER_CAPABILITIES  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_READER_CAPABILITIES msg = new MSG_GET_READER_CAPABILITIES();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "RequestedData");
          
            msg.RequestedData = (ENUM_GetReaderCapabilitiesRequestedData)Enum.Parse(typeof(ENUM_GetReaderCapabilitiesRequestedData), val);
            
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (RequestedData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_READER_CAPABILITIES
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_READER_CAPABILITIES</returns>
        public new static MSG_GET_READER_CAPABILITIES FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CAPABILITIES obj = new MSG_GET_READER_CAPABILITIES();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.RequestedData = (ENUM_GetReaderCapabilitiesRequestedData)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response from the Reader to the GET_READER_CAPABILITIES message. The response contains the LLRPStatus Parameter and the list of parameters for the requested capabilities conveyed via RequestedData in the GET_READER_CAPABILITIES message. 
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=44&amp;view=fit">LLRP Specification Section 9.1.2,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=117&amp;view=fit">LLRP Specification Section 16.1.2,</see>
    ///</summary>
    public class MSG_GET_READER_CAPABILITIES_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              
        public PARAM_GeneralDeviceCapabilities GeneralDeviceCapabilities;
              
        public PARAM_LLRPCapabilities LLRPCapabilities;
              
        public PARAM_RegulatoryCapabilities RegulatoryCapabilities;
              
        public UNION_AirProtocolLLRPCapabilities AirProtocolLLRPCapabilities = new UNION_AirProtocolLLRPCapabilities();
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGET_READER_CAPABILITIES_RESPONSE_Custom_Param custom =
                param as IGET_READER_CAPABILITIES_RESPONSE_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_GET_READER_CAPABILITIES_RESPONSE()
        {
            msgType = 11;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_READER_CAPABILITIES_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (GeneralDeviceCapabilities != null)
            {
          
                xml_str += Util.Indent(GeneralDeviceCapabilities.ToString());
                
            }
        
            if (LLRPCapabilities != null)
            {
          
                xml_str += Util.Indent(LLRPCapabilities.ToString());
                
            }
        
            if (RegulatoryCapabilities != null)
            {
          
                xml_str += Util.Indent(RegulatoryCapabilities.ToString());
                
            }
        
            if (AirProtocolLLRPCapabilities != null)
            {
                len = AirProtocolLLRPCapabilities.Count;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(AirProtocolLLRPCapabilities[i].ToString());
                }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</GET_READER_CAPABILITIES_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_READER_CAPABILITIES_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_READER_CAPABILITIES_RESPONSE</returns>
        public new static MSG_GET_READER_CAPABILITIES_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_READER_CAPABILITIES_RESPONSE msg = new MSG_GET_READER_CAPABILITIES_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GeneralDeviceCapabilities", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GeneralDeviceCapabilities = PARAM_GeneralDeviceCapabilities.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPCapabilities", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPCapabilities = PARAM_LLRPCapabilities.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RegulatoryCapabilities", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.RegulatoryCapabilities = PARAM_RegulatoryCapabilities.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            {
          
            msg.AirProtocolLLRPCapabilities = new UNION_AirProtocolLLRPCapabilities();
          
            try
            {
                foreach (XmlNode ccnode in node.ChildNodes)
                {
                    switch (ccnode.Name)
                    {
              
                    case "C1G2LLRPCapabilities":
                
                        msg.AirProtocolLLRPCapabilities.Add(PARAM_C1G2LLRPCapabilities.FromXmlNode(ccnode));
                        break;
                  
                    }
                }
            } catch { }
            
            }
        
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (GeneralDeviceCapabilities != null)
            {
        GeneralDeviceCapabilities.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (LLRPCapabilities != null)
            {
        LLRPCapabilities.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (RegulatoryCapabilities != null)
            {
        RegulatoryCapabilities.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            len = AirProtocolLLRPCapabilities.Count;
            for (int i=0; i<len; i++)
            {
                AirProtocolLLRPCapabilities[i].ToBitArray(ref bit_array, ref cursor);
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_READER_CAPABILITIES_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_READER_CAPABILITIES_RESPONSE</returns>
        public new static MSG_GET_READER_CAPABILITIES_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CAPABILITIES_RESPONSE obj = new MSG_GET_READER_CAPABILITIES_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.GeneralDeviceCapabilities = PARAM_GeneralDeviceCapabilities.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.LLRPCapabilities = PARAM_LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.RegulatoryCapabilities = PARAM_RegulatoryCapabilities.FromBitArray(ref bit_array, ref cursor, length);
            
            loop_control_counter = 1;
            while (loop_control_counter != 0)
            {
                loop_control_counter = 0;
        
                PARAM_C1G2LLRPCapabilities _param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length);
                if (_param_C1G2LLRPCapabilities != null)
                {
                    loop_control_counter++;
                    obj.AirProtocolLLRPCapabilities.Add(_param_C1G2LLRPCapabilities);
                }
                while ((_param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length)) != null)
                {
                    obj.AirProtocolLLRPCapabilities.Add(_param_C1G2LLRPCapabilities);
                }
            
            }
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///An ADD_ROSPEC message communicates the information of a ROSpec to the Reader. LLRP supports configuration of multiple ROSpecs. Each ROSpec is uniquely identified using a ROSpecID, generated by the Client. The ROSpec starts at the Disabled state waiting for the ENABLE_ROSPEC message for the ROSpec from the Client, upon which it transitions to the Inactive state.
    ///The Client SHALL add a ROSpec in a Disabled State - i.e., CurrentState field in the ROSpec Parameter (section 10.2.1) SHALL be set to disabled. If the CurrentState value is different than disabled, an error SHALL be returned in the ADD_ROSPEC_RESPONSE (e.g. P_FieldError).
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=51&amp;view=fit">LLRP Specification Section 10.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=117&amp;view=fit">LLRP Specification Section 16.1.3,</see>
    ///</summary>
    public class MSG_ADD_ROSPEC : Message
    {
      
        public PARAM_ROSpec ROSpec;
              

        public MSG_ADD_ROSPEC()
        {
            msgType = 20;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ADD_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpec != null)
            {
          
                xml_str += Util.Indent(ROSpec.ToString());
                
            }
        
            xml_str += "</ADD_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ADD_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ADD_ROSPEC</returns>
        public new static MSG_ADD_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ADD_ROSPEC msg = new MSG_ADD_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ROSpec = PARAM_ROSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpec != null)
            {
        ROSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ADD_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ADD_ROSPEC</returns>
        public new static MSG_ADD_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ROSPEC obj = new MSG_ADD_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.ROSpec = PARAM_ROSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to an ADD_ROSPEC message. If all the parameters specified in the ADD_ROSPEC command are successfully set, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=51&amp;view=fit">LLRP Specification Section 10.1.2,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=118&amp;view=fit">LLRP Specification Section 16.1.4,</see>
    ///</summary>
    public class MSG_ADD_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_ADD_ROSPEC_RESPONSE()
        {
            msgType = 30;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ADD_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</ADD_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ADD_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ADD_ROSPEC_RESPONSE</returns>
        public new static MSG_ADD_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ADD_ROSPEC_RESPONSE msg = new MSG_ADD_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ADD_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ADD_ROSPEC_RESPONSE</returns>
        public new static MSG_ADD_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ROSPEC_RESPONSE obj = new MSG_ADD_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command is issued by the Client to the Reader. This command deletes the ROSpec at the Reader corresponding to ROSpecID passed in this message.
    ///ROSpecID: Zero indicates to delete all ROSpecs.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=51&amp;view=fit">LLRP Specification Section 10.1.3,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=118&amp;view=fit">LLRP Specification Section 16.1.5,</see>
    ///</summary>
    public class MSG_DELETE_ROSPEC : Message
    {
      
        public UInt32 ROSpecID=0;
        private Int16 ROSpecID_len=0;
      

        public MSG_DELETE_ROSPEC()
        {
            msgType = 21;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DELETE_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpecID != null)
            {
                try
                {
          
                    xml_str += "  <ROSpecID>" + Util.ConvertValueTypeToString(ROSpecID, "u32", "") + "</ROSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</DELETE_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DELETE_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DELETE_ROSPEC</returns>
        public new static MSG_DELETE_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DELETE_ROSPEC msg = new MSG_DELETE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ROSpecID");
          
            msg.ROSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DELETE_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DELETE_ROSPEC</returns>
        public new static MSG_DELETE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ROSPEC obj = new MSG_DELETE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a DELETE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID that the Reader was presently executing, and the Reader was successful in stopping that execution, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=52&amp;view=fit">LLRP Specification Section 10.1.4,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=118&amp;view=fit">LLRP Specification Section 16.1.6,</see>
    ///</summary>
    public class MSG_DELETE_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_DELETE_ROSPEC_RESPONSE()
        {
            msgType = 31;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DELETE_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</DELETE_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DELETE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DELETE_ROSPEC_RESPONSE</returns>
        public new static MSG_DELETE_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DELETE_ROSPEC_RESPONSE msg = new MSG_DELETE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DELETE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DELETE_ROSPEC_RESPONSE</returns>
        public new static MSG_DELETE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ROSPEC_RESPONSE obj = new MSG_DELETE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader starts the ROSpec corresponding to ROSpecID passed in this message, if the ROSpec is in the enabled state.
    ///ROSpecID: Zero is disallowed.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=52&amp;view=fit">LLRP Specification Section 10.1.5,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=118&amp;view=fit">LLRP Specification Section 16.1.7,</see>
    ///</summary>
    public class MSG_START_ROSPEC : Message
    {
      
        public UInt32 ROSpecID=0;
        private Int16 ROSpecID_len=0;
      

        public MSG_START_ROSPEC()
        {
            msgType = 22;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<START_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpecID != null)
            {
                try
                {
          
                    xml_str += "  <ROSpecID>" + Util.ConvertValueTypeToString(ROSpecID, "u32", "") + "</ROSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</START_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_START_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_START_ROSPEC</returns>
        public new static MSG_START_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_START_ROSPEC msg = new MSG_START_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ROSpecID");
          
            msg.ROSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_START_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_START_ROSPEC</returns>
        public new static MSG_START_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_START_ROSPEC obj = new MSG_START_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a START_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID in the enabled state, and the Reader was able to start executing that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=52&amp;view=fit">LLRP Specification Section 10.1.6,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=119&amp;view=fit">LLRP Specification Section 16.1.8,</see>
    ///</summary>
    public class MSG_START_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_START_ROSPEC_RESPONSE()
        {
            msgType = 32;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<START_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</START_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_START_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_START_ROSPEC_RESPONSE</returns>
        public new static MSG_START_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_START_ROSPEC_RESPONSE msg = new MSG_START_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_START_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_START_ROSPEC_RESPONSE</returns>
        public new static MSG_START_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_START_ROSPEC_RESPONSE obj = new MSG_START_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader stops the execution of the ROSpec corresponding to the ROSpecID passed in this message. STOP_ROSPEC overrides all other priorities and stops the execution. This basically moves the ROSpec's state to Inactive. This message does not the delete the ROSpec.
    ///ROSpecID: Zero is disallowed.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=53&amp;view=fit">LLRP Specification Section 10.1.7,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=119&amp;view=fit">LLRP Specification Section 16.1.9,</see>
    ///</summary>
    public class MSG_STOP_ROSPEC : Message
    {
      
        public UInt32 ROSpecID=0;
        private Int16 ROSpecID_len=0;
      

        public MSG_STOP_ROSPEC()
        {
            msgType = 23;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<STOP_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpecID != null)
            {
                try
                {
          
                    xml_str += "  <ROSpecID>" + Util.ConvertValueTypeToString(ROSpecID, "u32", "") + "</ROSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</STOP_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_STOP_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_STOP_ROSPEC</returns>
        public new static MSG_STOP_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_STOP_ROSPEC msg = new MSG_STOP_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ROSpecID");
          
            msg.ROSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_STOP_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_STOP_ROSPEC</returns>
        public new static MSG_STOP_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_STOP_ROSPEC obj = new MSG_STOP_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a STOP_ROSPEC command. If the Reader was currently executing the ROSpec corresponding to the ROSpecID, and the Reader was able to stop executing that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=53&amp;view=fit">LLRP Specification Section 10.1.8,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=119&amp;view=fit">LLRP Specification Section 16.1.10,</see>
    ///</summary>
    public class MSG_STOP_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_STOP_ROSPEC_RESPONSE()
        {
            msgType = 33;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<STOP_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</STOP_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_STOP_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_STOP_ROSPEC_RESPONSE</returns>
        public new static MSG_STOP_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_STOP_ROSPEC_RESPONSE msg = new MSG_STOP_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_STOP_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_STOP_ROSPEC_RESPONSE</returns>
        public new static MSG_STOP_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_STOP_ROSPEC_RESPONSE obj = new MSG_STOP_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the ROSpec corresponding to the ROSpecID passed in this message from the disabled to the enabled state.
    ///ROSpecID:  If set to zero, all ROSpecs are enabled.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=53&amp;view=fit">LLRP Specification Section 10.1.9,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=119&amp;view=fit">LLRP Specification Section 16.1.11,</see>
    ///</summary>
    public class MSG_ENABLE_ROSPEC : Message
    {
      
        public UInt32 ROSpecID=0;
        private Int16 ROSpecID_len=0;
      

        public MSG_ENABLE_ROSPEC()
        {
            msgType = 24;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ENABLE_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpecID != null)
            {
                try
                {
          
                    xml_str += "  <ROSpecID>" + Util.ConvertValueTypeToString(ROSpecID, "u32", "") + "</ROSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</ENABLE_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ENABLE_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ENABLE_ROSPEC</returns>
        public new static MSG_ENABLE_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ENABLE_ROSPEC msg = new MSG_ENABLE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ROSpecID");
          
            msg.ROSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ENABLE_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ENABLE_ROSPEC</returns>
        public new static MSG_ENABLE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ROSPEC obj = new MSG_ENABLE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a ENABLE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID, and the Reader was able to enable that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=54&amp;view=fit">LLRP Specification Section 10.1.10,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=120&amp;view=fit">LLRP Specification Section 16.1.12,</see>
    ///</summary>
    public class MSG_ENABLE_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_ENABLE_ROSPEC_RESPONSE()
        {
            msgType = 34;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ENABLE_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</ENABLE_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ENABLE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ENABLE_ROSPEC_RESPONSE</returns>
        public new static MSG_ENABLE_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ENABLE_ROSPEC_RESPONSE msg = new MSG_ENABLE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ENABLE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ENABLE_ROSPEC_RESPONSE</returns>
        public new static MSG_ENABLE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ROSPEC_RESPONSE obj = new MSG_ENABLE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the ROSpec corresponding to the ROSpecID passed in this message to the disabled state.
    ///ROSpecID:  If set to Zero, all ROSpecs are disabled.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=54&amp;view=fit">LLRP Specification Section 10.1.11,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=120&amp;view=fit">LLRP Specification Section 16.1.13,</see>
    ///</summary>
    public class MSG_DISABLE_ROSPEC : Message
    {
      
        public UInt32 ROSpecID=0;
        private Int16 ROSpecID_len=0;
      

        public MSG_DISABLE_ROSPEC()
        {
            msgType = 25;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DISABLE_ROSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ROSpecID != null)
            {
                try
                {
          
                    xml_str += "  <ROSpecID>" + Util.ConvertValueTypeToString(ROSpecID, "u32", "") + "</ROSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</DISABLE_ROSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DISABLE_ROSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DISABLE_ROSPEC</returns>
        public new static MSG_DISABLE_ROSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DISABLE_ROSPEC msg = new MSG_DISABLE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ROSpecID");
          
            msg.ROSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ROSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DISABLE_ROSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DISABLE_ROSPEC</returns>
        public new static MSG_DISABLE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ROSPEC obj = new MSG_DISABLE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a DISABLE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID, and the Reader was able to disable that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=54&amp;view=fit">LLRP Specification Section 10.1.12,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=120&amp;view=fit">LLRP Specification Section 16.1.14,</see>
    ///</summary>
    public class MSG_DISABLE_ROSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_DISABLE_ROSPEC_RESPONSE()
        {
            msgType = 35;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DISABLE_ROSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</DISABLE_ROSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DISABLE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DISABLE_ROSPEC_RESPONSE</returns>
        public new static MSG_DISABLE_ROSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DISABLE_ROSPEC_RESPONSE msg = new MSG_DISABLE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DISABLE_ROSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DISABLE_ROSPEC_RESPONSE</returns>
        public new static MSG_DISABLE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ROSPEC_RESPONSE obj = new MSG_DISABLE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the request from the Client to the Reader to retrieve all the ROSpecs that have been configured at the Reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=54&amp;view=fit">LLRP Specification Section 10.1.13,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=120&amp;view=fit">LLRP Specification Section 16.1.15,</see>
    ///</summary>
    public class MSG_GET_ROSPECS : Message
    {
      

        public MSG_GET_ROSPECS()
        {
            msgType = 26;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_ROSPECS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</GET_ROSPECS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_ROSPECS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_ROSPECS</returns>
        public new static MSG_GET_ROSPECS  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_ROSPECS msg = new MSG_GET_ROSPECS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_ROSPECS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_ROSPECS</returns>
        public new static MSG_GET_ROSPECS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ROSPECS obj = new MSG_GET_ROSPECS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a GET_ROSPECS command. If there are no ROSpecs configured at the Reader, the response is just the LLRPStatus parameter with the success code. Else, a list of ROSpec parameter is returned by the Reader, along with the success code in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=55&amp;view=fit">LLRP Specification Section 10.1.14,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=121&amp;view=fit">LLRP Specification Section 16.1.16,</see>
    ///</summary>
    public class MSG_GET_ROSPECS_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              
        public PARAM_ROSpec[] ROSpec;
                

        public MSG_GET_ROSPECS_RESPONSE()
        {
            msgType = 36;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_ROSPECS_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (ROSpec != null)
            {
          
                len = ROSpec.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(ROSpec[i].ToString());
                }
                
            }
        
            xml_str += "</GET_ROSPECS_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_ROSPECS_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_ROSPECS_RESPONSE</returns>
        public new static MSG_GET_ROSPECS_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_ROSPECS_RESPONSE msg = new MSG_GET_ROSPECS_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ROSpec = new PARAM_ROSpec[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.ROSpec[i] = PARAM_ROSpec.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ROSpec != null)
            {
        
                len = ROSpec.Length;
                for (int i=0; i<len; i++)
                {
                    ROSpec[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_ROSPECS_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_ROSPECS_RESPONSE</returns>
        public new static MSG_GET_ROSPECS_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ROSPECS_RESPONSE obj = new MSG_GET_ROSPECS_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_ROSpec _param_ROSpec;
            while ((_param_ROSpec = PARAM_ROSpec.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_ROSpec);
            }
            if (param_list.Count > 0)
            {
                obj.ROSpec = new PARAM_ROSpec[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.ROSpec[i] = (PARAM_ROSpec)param_list[i];
                }
            }
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command creates a new AccessSpec at the Reader. The AccessSpec starts at the Disabled state waiting for the ENABLE_ACCESSSPEC message for the AccessSpec from the Client, upon which it transitions to the Active state. The AccessSpecID is generated by the Client.
    ///The Client SHALL add an AccessSpec in a Disabled State i.e., CurrentState field in the AccessSpec Parameter (section 11.2.1) SHALL be set to false. If the CurrentState value is different than false, an error SHALL be returned in the ADD_ACCESSSPEC_RESPONSE (e.g. P_FieldError).
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=60&amp;view=fit">LLRP Specification Section 11.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=121&amp;view=fit">LLRP Specification Section 16.1.17,</see>
    ///</summary>
    public class MSG_ADD_ACCESSSPEC : Message
    {
      
        public PARAM_AccessSpec AccessSpec;
              

        public MSG_ADD_ACCESSSPEC()
        {
            msgType = 40;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ADD_ACCESSSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AccessSpec != null)
            {
          
                xml_str += Util.Indent(AccessSpec.ToString());
                
            }
        
            xml_str += "</ADD_ACCESSSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ADD_ACCESSSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ADD_ACCESSSPEC</returns>
        public new static MSG_ADD_ACCESSSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ADD_ACCESSSPEC msg = new MSG_ADD_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AccessSpec = PARAM_AccessSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (AccessSpec != null)
            {
        AccessSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ADD_ACCESSSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ADD_ACCESSSPEC</returns>
        public new static MSG_ADD_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ACCESSSPEC obj = new MSG_ADD_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.AccessSpec = PARAM_AccessSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to an ADD_ACCESSSPEC command. If the parameters passed in that ADD_ACCESSSPEC command were successfully accepted and set at the Reader, then the success code is returned in the LLRPStatus parameter. However, if the AccessSpec was not successfully created at the Reader, the Reader sends a LLRPStatus parameter describing the error in the message.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=61&amp;view=fit">LLRP Specification Section 11.1.2,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=121&amp;view=fit">LLRP Specification Section 16.1.18,</see>
    ///</summary>
    public class MSG_ADD_ACCESSSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_ADD_ACCESSSPEC_RESPONSE()
        {
            msgType = 50;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ADD_ACCESSSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</ADD_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ADD_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ADD_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_ADD_ACCESSSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ADD_ACCESSSPEC_RESPONSE msg = new MSG_ADD_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ADD_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ADD_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_ADD_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ACCESSSPEC_RESPONSE obj = new MSG_ADD_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command is issued by the Client to the Reader. The Reader deletes the AccessSpec corresponding to the AccessSpecId, and this AccessSpec will stop taking effect from the next inventory round.
    ///AccessSpecID: If set to Zero, all AccessSpecs are deleted.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=61&amp;view=fit">LLRP Specification Section 11.1.3,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=122&amp;view=fit">LLRP Specification Section 16.1.19,</see>
    ///</summary>
    public class MSG_DELETE_ACCESSSPEC : Message
    {
      
        public UInt32 AccessSpecID=0;
        private Int16 AccessSpecID_len=0;
      

        public MSG_DELETE_ACCESSSPEC()
        {
            msgType = 41;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DELETE_ACCESSSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AccessSpecID != null)
            {
                try
                {
          
                    xml_str += "  <AccessSpecID>" + Util.ConvertValueTypeToString(AccessSpecID, "u32", "") + "</AccessSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</DELETE_ACCESSSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DELETE_ACCESSSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DELETE_ACCESSSPEC</returns>
        public new static MSG_DELETE_ACCESSSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DELETE_ACCESSSPEC msg = new MSG_DELETE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "AccessSpecID");
          
            msg.AccessSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (AccessSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DELETE_ACCESSSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DELETE_ACCESSSPEC</returns>
        public new static MSG_DELETE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ACCESSSPEC obj = new MSG_DELETE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a DELETE_ACCESSSPEC command. If there was an AccessSpec at the Reader corresponding to the AccessSpecID passed in the DELETE_ACCESSSPEC command, and the Reader was successful in deleting that AccessSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=61&amp;view=fit">LLRP Specification Section 11.1.4,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=122&amp;view=fit">LLRP Specification Section 16.1.20,</see>
    ///</summary>
    public class MSG_DELETE_ACCESSSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_DELETE_ACCESSSPEC_RESPONSE()
        {
            msgType = 51;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DELETE_ACCESSSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</DELETE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DELETE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DELETE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_DELETE_ACCESSSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DELETE_ACCESSSPEC_RESPONSE msg = new MSG_DELETE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DELETE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DELETE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_DELETE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ACCESSSPEC_RESPONSE obj = new MSG_DELETE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the AccessSpec corresponding to the AccessSpecID in this message from the Disabled state to the Active state. The Reader executes this access-spec until it gets a DISABLE_ACCESSSPEC or a DELETE_ACCESSSPEC from the Client. The AccessSpec takes effect with the next (and subsequent) inventory rounds.
    ///AccessSpecID: If set to 0, all AccessSpecs are enabled.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=62&amp;view=fit">LLRP Specification Section 11.1.5,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=122&amp;view=fit">LLRP Specification Section 16.1.21,</see>
    ///</summary>
    public class MSG_ENABLE_ACCESSSPEC : Message
    {
      
        public UInt32 AccessSpecID=0;
        private Int16 AccessSpecID_len=0;
      

        public MSG_ENABLE_ACCESSSPEC()
        {
            msgType = 42;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ENABLE_ACCESSSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AccessSpecID != null)
            {
                try
                {
          
                    xml_str += "  <AccessSpecID>" + Util.ConvertValueTypeToString(AccessSpecID, "u32", "") + "</AccessSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</ENABLE_ACCESSSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ENABLE_ACCESSSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ENABLE_ACCESSSPEC</returns>
        public new static MSG_ENABLE_ACCESSSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ENABLE_ACCESSSPEC msg = new MSG_ENABLE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "AccessSpecID");
          
            msg.AccessSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (AccessSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ENABLE_ACCESSSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ENABLE_ACCESSSPEC</returns>
        public new static MSG_ENABLE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ACCESSSPEC obj = new MSG_ENABLE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to an ENABLE_ACCESSSPEC command. If there was an AccessSpec corresponding to the AccessSpecID, and the Reader was able to move that AccessSpec from the disabled to the active state, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=62&amp;view=fit">LLRP Specification Section 11.1.6,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=122&amp;view=fit">LLRP Specification Section 16.1.22,</see>
    ///</summary>
    public class MSG_ENABLE_ACCESSSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_ENABLE_ACCESSSPEC_RESPONSE()
        {
            msgType = 52;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ENABLE_ACCESSSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</ENABLE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ENABLE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ENABLE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_ENABLE_ACCESSSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ENABLE_ACCESSSPEC_RESPONSE msg = new MSG_ENABLE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ENABLE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ENABLE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_ENABLE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ACCESSSPEC_RESPONSE obj = new MSG_ENABLE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader. Upon receiving the message, the Reader stops the execution of the AccessSpec corresponding to AccessSpecID in this message. This basically moves the AccessSpec's state to Disabled. This message does not delete the AccessSpec. The AccessSpec will stop taking effect from the next inventory round.
    ///AccessSpecID: If set to zero, all AccessSpecs are disabled.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=62&amp;view=fit">LLRP Specification Section 11.1.7,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=123&amp;view=fit">LLRP Specification Section 16.1.23,</see>
    ///</summary>
    public class MSG_DISABLE_ACCESSSPEC : Message
    {
      
        public UInt32 AccessSpecID=0;
        private Int16 AccessSpecID_len=0;
      

        public MSG_DISABLE_ACCESSSPEC()
        {
            msgType = 43;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DISABLE_ACCESSSPEC";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AccessSpecID != null)
            {
                try
                {
          
                    xml_str += "  <AccessSpecID>" + Util.ConvertValueTypeToString(AccessSpecID, "u32", "") + "</AccessSpecID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            xml_str += "</DISABLE_ACCESSSPEC>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DISABLE_ACCESSSPEC
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DISABLE_ACCESSSPEC</returns>
        public new static MSG_DISABLE_ACCESSSPEC  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DISABLE_ACCESSSPEC msg = new MSG_DISABLE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "AccessSpecID");
          
            msg.AccessSpecID = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (AccessSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DISABLE_ACCESSSPEC
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DISABLE_ACCESSSPEC</returns>
        public new static MSG_DISABLE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ACCESSSPEC obj = new MSG_DISABLE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a STOP_ACCESSSPEC command. If the Reader was currently executing the AccessSpec corresponding to the AccessSpecID, and the Reader was able to disable that AccessSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=63&amp;view=fit">LLRP Specification Section 11.1.8,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=123&amp;view=fit">LLRP Specification Section 16.1.24,</see>
    ///</summary>
    public class MSG_DISABLE_ACCESSSPEC_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_DISABLE_ACCESSSPEC_RESPONSE()
        {
            msgType = 53;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<DISABLE_ACCESSSPEC_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</DISABLE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_DISABLE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_DISABLE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_DISABLE_ACCESSSPEC_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_DISABLE_ACCESSSPEC_RESPONSE msg = new MSG_DISABLE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_DISABLE_ACCESSSPEC_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_DISABLE_ACCESSSPEC_RESPONSE</returns>
        public new static MSG_DISABLE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ACCESSSPEC_RESPONSE obj = new MSG_DISABLE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the request from the Client to the Reader to retrieve all the AccessSpecs that have been configured at the Reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=63&amp;view=fit">LLRP Specification Section 11.1.9,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=123&amp;view=fit">LLRP Specification Section 16.1.25,</see>
    ///</summary>
    public class MSG_GET_ACCESSSPECS : Message
    {
      

        public MSG_GET_ACCESSSPECS()
        {
            msgType = 44;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_ACCESSSPECS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</GET_ACCESSSPECS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_ACCESSSPECS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_ACCESSSPECS</returns>
        public new static MSG_GET_ACCESSSPECS  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_ACCESSSPECS msg = new MSG_GET_ACCESSSPECS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_ACCESSSPECS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_ACCESSSPECS</returns>
        public new static MSG_GET_ACCESSSPECS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ACCESSSPECS obj = new MSG_GET_ACCESSSPECS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a GET_ACCESSSPECS command. If there are no AccessSpecs configured at the Reader, the response is just the LLRPStatus parameter with the success code. Else, a list of (AccessSpecID, AccessSpec parameter) is returned by the Reader, along with the LLRPStatus parameter containing the success code. The order of the AccessSpecs listed in the message is normatively the order in which the AccessSpecs were created at the Reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=63&amp;view=fit">LLRP Specification Section 11.1.10,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=123&amp;view=fit">LLRP Specification Section 16.1.26,</see>
    ///</summary>
    public class MSG_GET_ACCESSSPECS_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              
        public PARAM_AccessSpec[] AccessSpec;
                

        public MSG_GET_ACCESSSPECS_RESPONSE()
        {
            msgType = 54;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_ACCESSSPECS_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (AccessSpec != null)
            {
          
                len = AccessSpec.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(AccessSpec[i].ToString());
                }
                
            }
        
            xml_str += "</GET_ACCESSSPECS_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_ACCESSSPECS_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_ACCESSSPECS_RESPONSE</returns>
        public new static MSG_GET_ACCESSSPECS_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_ACCESSSPECS_RESPONSE msg = new MSG_GET_ACCESSSPECS_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AccessSpec = new PARAM_AccessSpec[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.AccessSpec[i] = PARAM_AccessSpec.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AccessSpec != null)
            {
        
                len = AccessSpec.Length;
                for (int i=0; i<len; i++)
                {
                    AccessSpec[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_ACCESSSPECS_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_ACCESSSPECS_RESPONSE</returns>
        public new static MSG_GET_ACCESSSPECS_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ACCESSSPECS_RESPONSE obj = new MSG_GET_ACCESSSPECS_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_AccessSpec _param_AccessSpec;
            while ((_param_AccessSpec = PARAM_AccessSpec.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_AccessSpec);
            }
            if (param_list.Count > 0)
            {
                obj.AccessSpec = new PARAM_AccessSpec[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.AccessSpec[i] = (PARAM_AccessSpec)param_list[i];
                }
            }
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command is issued by the Client to get the current configuration information of the Reader. The Requested Data passed in the command represents the parameter(s) of interest to the Client that has to be returned by the Reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=67&amp;view=fit">LLRP Specification Section 12.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=126&amp;view=fit">LLRP Specification Section 16.1.36,</see>
    ///</summary>
    public class MSG_GET_READER_CONFIG : Message
    {
      
        public UInt16 AntennaID=0;
        private Int16 AntennaID_len=0;
      
        public ENUM_GetReaderConfigRequestedData RequestedData;
        private Int16 RequestedData_len = 8;
        public UInt16 GPIPortNum=0;
        private Int16 GPIPortNum_len=0;
      
        public UInt16 GPOPortNum=0;
        private Int16 GPOPortNum_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGET_READER_CONFIG_Custom_Param custom =
                param as IGET_READER_CONFIG_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_GET_READER_CONFIG()
        {
            msgType = 2;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_READER_CONFIG";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AntennaID != null)
            {
                try
                {
          
                    xml_str += "  <AntennaID>" + Util.ConvertValueTypeToString(AntennaID, "u16", "") + "</AntennaID>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (RequestedData != null)
            {
                try
                {
          
                    xml_str += "  <RequestedData>" + RequestedData.ToString() + "</RequestedData>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (GPIPortNum != null)
            {
                try
                {
          
                    xml_str += "  <GPIPortNum>" + Util.ConvertValueTypeToString(GPIPortNum, "u16", "") + "</GPIPortNum>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (GPOPortNum != null)
            {
                try
                {
          
                    xml_str += "  <GPOPortNum>" + Util.ConvertValueTypeToString(GPOPortNum, "u16", "") + "</GPOPortNum>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</GET_READER_CONFIG>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_READER_CONFIG
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_READER_CONFIG</returns>
        public new static MSG_GET_READER_CONFIG  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_READER_CONFIG msg = new MSG_GET_READER_CONFIG();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "AntennaID");
          
            msg.AntennaID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
            
            val = XmlUtil.GetNodeValue(node, "RequestedData");
          
            msg.RequestedData = (ENUM_GetReaderConfigRequestedData)Enum.Parse(typeof(ENUM_GetReaderConfigRequestedData), val);
            
            val = XmlUtil.GetNodeValue(node, "GPIPortNum");
          
            msg.GPIPortNum = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
            
            val = XmlUtil.GetNodeValue(node, "GPOPortNum");
          
            msg.GPOPortNum = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
            
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (AntennaID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (RequestedData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (GPIPortNum != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIPortNum, GPIPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (GPOPortNum != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPOPortNum, GPOPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_READER_CONFIG
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_READER_CONFIG</returns>
        public new static MSG_GET_READER_CONFIG FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CONFIG obj = new MSG_GET_READER_CONFIG();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.AntennaID = (UInt16)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.RequestedData = (ENUM_GetReaderConfigRequestedData)(UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.GPIPortNum = (UInt16)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.GPOPortNum = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to the GET_READER_CONFIG message. The response is the LLRPStatus Parameter and the list of configuration parameters based on the RequestedData in GET_READER_CONFIG. If the GET_READER_CONFIG message did not have any errors, the success code is returned in the LLRPStatus parameter, and in addition the requested configuration parameters are returned. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. The response contains at most one instance of each configuration parameter except for two cases, which are as follows:
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=68&amp;view=fit">LLRP Specification Section 12.1.2,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=127&amp;view=fit">LLRP Specification Section 16.1.37,</see>
    ///</summary>
    public class MSG_GET_READER_CONFIG_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              
        public PARAM_Identification Identification;
              
        public PARAM_AntennaProperties[] AntennaProperties;
                
        public PARAM_AntennaConfiguration[] AntennaConfiguration;
                
        public PARAM_ReaderEventNotificationSpec ReaderEventNotificationSpec;
              
        public PARAM_ROReportSpec ROReportSpec;
              
        public PARAM_AccessReportSpec AccessReportSpec;
              
        public PARAM_LLRPConfigurationStateValue LLRPConfigurationStateValue;
              
        public PARAM_KeepaliveSpec KeepaliveSpec;
              
        public PARAM_GPIPortCurrentState[] GPIPortCurrentState;
                
        public PARAM_GPOWriteData[] GPOWriteData;
                
        public PARAM_EventsAndReports EventsAndReports;
              
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGET_READER_CONFIG_RESPONSE_Custom_Param custom =
                param as IGET_READER_CONFIG_RESPONSE_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_GET_READER_CONFIG_RESPONSE()
        {
            msgType = 12;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_READER_CONFIG_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (Identification != null)
            {
          
                xml_str += Util.Indent(Identification.ToString());
                
            }
        
            if (AntennaProperties != null)
            {
          
                len = AntennaProperties.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(AntennaProperties[i].ToString());
                }
                
            }
        
            if (AntennaConfiguration != null)
            {
          
                len = AntennaConfiguration.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(AntennaConfiguration[i].ToString());
                }
                
            }
        
            if (ReaderEventNotificationSpec != null)
            {
          
                xml_str += Util.Indent(ReaderEventNotificationSpec.ToString());
                
            }
        
            if (ROReportSpec != null)
            {
          
                xml_str += Util.Indent(ROReportSpec.ToString());
                
            }
        
            if (AccessReportSpec != null)
            {
          
                xml_str += Util.Indent(AccessReportSpec.ToString());
                
            }
        
            if (LLRPConfigurationStateValue != null)
            {
          
                xml_str += Util.Indent(LLRPConfigurationStateValue.ToString());
                
            }
        
            if (KeepaliveSpec != null)
            {
          
                xml_str += Util.Indent(KeepaliveSpec.ToString());
                
            }
        
            if (GPIPortCurrentState != null)
            {
          
                len = GPIPortCurrentState.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(GPIPortCurrentState[i].ToString());
                }
                
            }
        
            if (GPOWriteData != null)
            {
          
                len = GPOWriteData.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(GPOWriteData[i].ToString());
                }
                
            }
        
            if (EventsAndReports != null)
            {
          
                xml_str += Util.Indent(EventsAndReports.ToString());
                
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</GET_READER_CONFIG_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_READER_CONFIG_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_READER_CONFIG_RESPONSE</returns>
        public new static MSG_GET_READER_CONFIG_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_READER_CONFIG_RESPONSE msg = new MSG_GET_READER_CONFIG_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Identification", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.Identification = PARAM_Identification.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaProperties", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaProperties = new PARAM_AntennaProperties[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.AntennaProperties[i] = PARAM_AntennaProperties.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaConfiguration", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaConfiguration = new PARAM_AntennaConfiguration[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.AntennaConfiguration[i] = PARAM_AntennaConfiguration.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROReportSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ROReportSpec = PARAM_ROReportSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessReportSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AccessReportSpec = PARAM_AccessReportSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPConfigurationStateValue", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPConfigurationStateValue = PARAM_LLRPConfigurationStateValue.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "KeepaliveSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.KeepaliveSpec = PARAM_KeepaliveSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIPortCurrentState", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPIPortCurrentState = new PARAM_GPIPortCurrentState[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.GPIPortCurrentState[i] = PARAM_GPIPortCurrentState.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPOWriteData", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPOWriteData = new PARAM_GPOWriteData[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.GPOWriteData[i] = PARAM_GPOWriteData.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EventsAndReports", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.EventsAndReports = PARAM_EventsAndReports.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Identification != null)
            {
        Identification.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AntennaProperties != null)
            {
        
                len = AntennaProperties.Length;
                for (int i=0; i<len; i++)
                {
                    AntennaProperties[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (AntennaConfiguration != null)
            {
        
                len = AntennaConfiguration.Length;
                for (int i=0; i<len; i++)
                {
                    AntennaConfiguration[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (ReaderEventNotificationSpec != null)
            {
        ReaderEventNotificationSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ROReportSpec != null)
            {
        ROReportSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AccessReportSpec != null)
            {
        AccessReportSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (LLRPConfigurationStateValue != null)
            {
        LLRPConfigurationStateValue.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (KeepaliveSpec != null)
            {
        KeepaliveSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (GPIPortCurrentState != null)
            {
        
                len = GPIPortCurrentState.Length;
                for (int i=0; i<len; i++)
                {
                    GPIPortCurrentState[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (GPOWriteData != null)
            {
        
                len = GPOWriteData.Length;
                for (int i=0; i<len; i++)
                {
                    GPOWriteData[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (EventsAndReports != null)
            {
        EventsAndReports.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_READER_CONFIG_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_READER_CONFIG_RESPONSE</returns>
        public new static MSG_GET_READER_CONFIG_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CONFIG_RESPONSE obj = new MSG_GET_READER_CONFIG_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.Identification = PARAM_Identification.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_AntennaProperties _param_AntennaProperties;
            while ((_param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_AntennaProperties);
            }
            if (param_list.Count > 0)
            {
                obj.AntennaProperties = new PARAM_AntennaProperties[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.AntennaProperties[i] = (PARAM_AntennaProperties)param_list[i];
                }
            }
            
            param_list = new ArrayList();
            PARAM_AntennaConfiguration _param_AntennaConfiguration;
            while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_AntennaConfiguration);
            }
            if (param_list.Count > 0)
            {
                obj.AntennaConfiguration = new PARAM_AntennaConfiguration[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.AntennaConfiguration[i] = (PARAM_AntennaConfiguration)param_list[i];
                }
            }
            
            obj.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ROReportSpec = PARAM_ROReportSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.AccessReportSpec = PARAM_AccessReportSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.LLRPConfigurationStateValue = PARAM_LLRPConfigurationStateValue.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.KeepaliveSpec = PARAM_KeepaliveSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_GPIPortCurrentState _param_GPIPortCurrentState;
            while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_GPIPortCurrentState);
            }
            if (param_list.Count > 0)
            {
                obj.GPIPortCurrentState = new PARAM_GPIPortCurrentState[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.GPIPortCurrentState[i] = (PARAM_GPIPortCurrentState)param_list[i];
                }
            }
            
            param_list = new ArrayList();
            PARAM_GPOWriteData _param_GPOWriteData;
            while ((_param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_GPOWriteData);
            }
            if (param_list.Count > 0)
            {
                obj.GPOWriteData = new PARAM_GPOWriteData[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.GPOWriteData[i] = (PARAM_GPOWriteData)param_list[i];
                }
            }
            
            obj.EventsAndReports = PARAM_EventsAndReports.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command is issued by the Client to the Reader. This command sets the Reader configuration using the parameters specified in this command.  Values passed by the SET_READER_CONFIG SHALL apply for the duration of the LLRP connection, or until the values are changed by additional SET_READER_CONFIG messages.
    ///For example, ROReportSpec defines the reporting of ROReport format and trigger for a ROSpec. ROReportSpec sent as part of SET_READER_CONFIG becomes the default ROReportSpec for the Reader. A ROReportSpec sent as part of ROSpec in the ADD_ROSPEC command overrides the default value for that ROSpec. However, in cases where there is no ROReportSpec specified in a ROSpec sent as part of ADD_ROSPEC, that particular ROSpec inherits the default ROReportSpec.
    ///The data field ResetToFactoryDefault informs the Reader to set all configurable values to factory defaults before applying the remaining parameters.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=69&amp;view=fit">LLRP Specification Section 12.1.3,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=127&amp;view=fit">LLRP Specification Section 16.1.38,</see>
    ///</summary>
    public class MSG_SET_READER_CONFIG : Message
    {
      
        public bool ResetToFactoryDefault=false;
        private Int16 ResetToFactoryDefault_len=0;
      
        private const UInt16 param_reserved_len3 = 7;
        
        public PARAM_ReaderEventNotificationSpec ReaderEventNotificationSpec;
              
        public PARAM_AntennaProperties[] AntennaProperties;
                
        public PARAM_AntennaConfiguration[] AntennaConfiguration;
                
        public PARAM_ROReportSpec ROReportSpec;
              
        public PARAM_AccessReportSpec AccessReportSpec;
              
        public PARAM_KeepaliveSpec KeepaliveSpec;
              
        public PARAM_GPOWriteData[] GPOWriteData;
                
        public PARAM_GPIPortCurrentState[] GPIPortCurrentState;
                
        public PARAM_EventsAndReports EventsAndReports;
              
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ISET_READER_CONFIG_Custom_Param custom =
                param as ISET_READER_CONFIG_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_SET_READER_CONFIG()
        {
            msgType = 3;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<SET_READER_CONFIG";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ResetToFactoryDefault != null)
            {
                try
                {
          
                    xml_str += "  <ResetToFactoryDefault>" + Util.ConvertValueTypeToString(ResetToFactoryDefault, "u1", "") + "</ResetToFactoryDefault>";
            
                    xml_str += "\r\n";
                }
                catch { }
            }
        
            if (ReaderEventNotificationSpec != null)
            {
          
                xml_str += Util.Indent(ReaderEventNotificationSpec.ToString());
                
            }
        
            if (AntennaProperties != null)
            {
          
                len = AntennaProperties.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(AntennaProperties[i].ToString());
                }
                
            }
        
            if (AntennaConfiguration != null)
            {
          
                len = AntennaConfiguration.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(AntennaConfiguration[i].ToString());
                }
                
            }
        
            if (ROReportSpec != null)
            {
          
                xml_str += Util.Indent(ROReportSpec.ToString());
                
            }
        
            if (AccessReportSpec != null)
            {
          
                xml_str += Util.Indent(AccessReportSpec.ToString());
                
            }
        
            if (KeepaliveSpec != null)
            {
          
                xml_str += Util.Indent(KeepaliveSpec.ToString());
                
            }
        
            if (GPOWriteData != null)
            {
          
                len = GPOWriteData.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(GPOWriteData[i].ToString());
                }
                
            }
        
            if (GPIPortCurrentState != null)
            {
          
                len = GPIPortCurrentState.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(GPIPortCurrentState[i].ToString());
                }
                
            }
        
            if (EventsAndReports != null)
            {
          
                xml_str += Util.Indent(EventsAndReports.ToString());
                
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</SET_READER_CONFIG>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_SET_READER_CONFIG
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_SET_READER_CONFIG</returns>
        public new static MSG_SET_READER_CONFIG  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_SET_READER_CONFIG msg = new MSG_SET_READER_CONFIG();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            val = XmlUtil.GetNodeValue(node, "ResetToFactoryDefault");
          
            msg.ResetToFactoryDefault = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
            
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaProperties", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaProperties = new PARAM_AntennaProperties[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.AntennaProperties[i] = PARAM_AntennaProperties.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaConfiguration", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaConfiguration = new PARAM_AntennaConfiguration[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.AntennaConfiguration[i] = PARAM_AntennaConfiguration.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROReportSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ROReportSpec = PARAM_ROReportSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessReportSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AccessReportSpec = PARAM_AccessReportSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "KeepaliveSpec", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.KeepaliveSpec = PARAM_KeepaliveSpec.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPOWriteData", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPOWriteData = new PARAM_GPOWriteData[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.GPOWriteData[i] = PARAM_GPOWriteData.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIPortCurrentState", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPIPortCurrentState = new PARAM_GPIPortCurrentState[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.GPIPortCurrentState[i] = PARAM_GPIPortCurrentState.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EventsAndReports", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.EventsAndReports = PARAM_EventsAndReports.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ResetToFactoryDefault != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ResetToFactoryDefault, ResetToFactoryDefault_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (ReaderEventNotificationSpec != null)
            {
        ReaderEventNotificationSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AntennaProperties != null)
            {
        
                len = AntennaProperties.Length;
                for (int i=0; i<len; i++)
                {
                    AntennaProperties[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (AntennaConfiguration != null)
            {
        
                len = AntennaConfiguration.Length;
                for (int i=0; i<len; i++)
                {
                    AntennaConfiguration[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (ROReportSpec != null)
            {
        ROReportSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AccessReportSpec != null)
            {
        AccessReportSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (KeepaliveSpec != null)
            {
        KeepaliveSpec.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (GPOWriteData != null)
            {
        
                len = GPOWriteData.Length;
                for (int i=0; i<len; i++)
                {
                    GPOWriteData[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (GPIPortCurrentState != null)
            {
        
                len = GPIPortCurrentState.Length;
                for (int i=0; i<len; i++)
                {
                    GPIPortCurrentState[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (EventsAndReports != null)
            {
        EventsAndReports.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_SET_READER_CONFIG
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_SET_READER_CONFIG</returns>
        public new static MSG_SET_READER_CONFIG FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_SET_READER_CONFIG obj = new MSG_SET_READER_CONFIG();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ResetToFactoryDefault = (bool)obj_val;
          
            cursor += param_reserved_len3;
      
            obj.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_AntennaProperties _param_AntennaProperties;
            while ((_param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_AntennaProperties);
            }
            if (param_list.Count > 0)
            {
                obj.AntennaProperties = new PARAM_AntennaProperties[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.AntennaProperties[i] = (PARAM_AntennaProperties)param_list[i];
                }
            }
            
            param_list = new ArrayList();
            PARAM_AntennaConfiguration _param_AntennaConfiguration;
            while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_AntennaConfiguration);
            }
            if (param_list.Count > 0)
            {
                obj.AntennaConfiguration = new PARAM_AntennaConfiguration[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.AntennaConfiguration[i] = (PARAM_AntennaConfiguration)param_list[i];
                }
            }
            
            obj.ROReportSpec = PARAM_ROReportSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.AccessReportSpec = PARAM_AccessReportSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.KeepaliveSpec = PARAM_KeepaliveSpec.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_GPOWriteData _param_GPOWriteData;
            while ((_param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_GPOWriteData);
            }
            if (param_list.Count > 0)
            {
                obj.GPOWriteData = new PARAM_GPOWriteData[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.GPOWriteData[i] = (PARAM_GPOWriteData)param_list[i];
                }
            }
            
            param_list = new ArrayList();
            PARAM_GPIPortCurrentState _param_GPIPortCurrentState;
            while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_GPIPortCurrentState);
            }
            if (param_list.Count > 0)
            {
                obj.GPIPortCurrentState = new PARAM_GPIPortCurrentState[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.GPIPortCurrentState[i] = (PARAM_GPIPortCurrentState)param_list[i];
                }
            }
            
            obj.EventsAndReports = PARAM_EventsAndReports.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a SET_READER_CONFIG command. If all the parameters specified in the SET_READER_CONFIG command are successfully set, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=70&amp;view=fit">LLRP Specification Section 12.1.4,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=128&amp;view=fit">LLRP Specification Section 16.1.39,</see>
    ///</summary>
    public class MSG_SET_READER_CONFIG_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_SET_READER_CONFIG_RESPONSE()
        {
            msgType = 13;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<SET_READER_CONFIG_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</SET_READER_CONFIG_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_SET_READER_CONFIG_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_SET_READER_CONFIG_RESPONSE</returns>
        public new static MSG_SET_READER_CONFIG_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_SET_READER_CONFIG_RESPONSE msg = new MSG_SET_READER_CONFIG_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_SET_READER_CONFIG_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_SET_READER_CONFIG_RESPONSE</returns>
        public new static MSG_SET_READER_CONFIG_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_SET_READER_CONFIG_RESPONSE obj = new MSG_SET_READER_CONFIG_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This command is issued by the Client to the Reader.  This command instructs the Reader to gracefully close its connection with the Client.  Under normal operating conditions, a Client SHALL attempt to send this command before closing an LLRP connection.  A Client should wait briefly for the Reader to respond with a CLOSE_CONNECTION_RESPONSE.
    ///Upon receipt of this command, the Reader SHALL respond with the CLOSE_CONNECTION_REPONSE message and it should then attempt to close the connection between the Reader and Client.
    ///Having executed a CLOSE_CONNECTION command, a Reader MAY persist its configuration state as defined by the ReaderConfigurationStateValue parameter specified in section 12.2.1.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=70&amp;view=fit">LLRP Specification Section 12.1.5,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=128&amp;view=fit">LLRP Specification Section 16.1.40,</see>
    ///</summary>
    public class MSG_CLOSE_CONNECTION : Message
    {
      

        public MSG_CLOSE_CONNECTION()
        {
            msgType = 14;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<CLOSE_CONNECTION";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</CLOSE_CONNECTION>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_CLOSE_CONNECTION
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_CLOSE_CONNECTION</returns>
        public new static MSG_CLOSE_CONNECTION  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_CLOSE_CONNECTION msg = new MSG_CLOSE_CONNECTION();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_CLOSE_CONNECTION
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_CLOSE_CONNECTION</returns>
        public new static MSG_CLOSE_CONNECTION FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_CLOSE_CONNECTION obj = new MSG_CLOSE_CONNECTION();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This is the response by the Reader to a CLOSE_CONNECTON command from the Client.  Upon receiving a CLOSE_CONNECTION command, the Reader SHALL attempt to send this response to the Client.  After attempting to send this response, the Reader SHALL close its connection with the Client.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=71&amp;view=fit">LLRP Specification Section 12.1.6,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=128&amp;view=fit">LLRP Specification Section 16.1.41,</see>
    ///</summary>
    public class MSG_CLOSE_CONNECTION_RESPONSE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_CLOSE_CONNECTION_RESPONSE()
        {
            msgType = 4;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<CLOSE_CONNECTION_RESPONSE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</CLOSE_CONNECTION_RESPONSE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_CLOSE_CONNECTION_RESPONSE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_CLOSE_CONNECTION_RESPONSE</returns>
        public new static MSG_CLOSE_CONNECTION_RESPONSE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_CLOSE_CONNECTION_RESPONSE msg = new MSG_CLOSE_CONNECTION_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_CLOSE_CONNECTION_RESPONSE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_CLOSE_CONNECTION_RESPONSE</returns>
        public new static MSG_CLOSE_CONNECTION_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_CLOSE_CONNECTION_RESPONSE obj = new MSG_CLOSE_CONNECTION_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Client to the Reader to get the tag reports. In response to this message, the Reader SHALL return tag reports accumulated.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=76&amp;view=fit">LLRP Specification Section 13.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=124&amp;view=fit">LLRP Specification Section 16.1.29,</see>
    ///</summary>
    public class MSG_GET_REPORT : Message
    {
      

        public MSG_GET_REPORT()
        {
            msgType = 60;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<GET_REPORT";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</GET_REPORT>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_GET_REPORT
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_GET_REPORT</returns>
        public new static MSG_GET_REPORT  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_GET_REPORT msg = new MSG_GET_REPORT();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_GET_REPORT
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_GET_REPORT</returns>
        public new static MSG_GET_REPORT FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_REPORT obj = new MSG_GET_REPORT();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Reader to the Client, and it contains the results of the RO and Access operations. The ROReportSpec and AccessReportSpec parameters define the contents and triggers for this message.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=77&amp;view=fit">LLRP Specification Section 13.1.2,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=125&amp;view=fit">LLRP Specification Section 16.1.30,</see>
    ///</summary>
    public class MSG_RO_ACCESS_REPORT : Message
    {
      
        public PARAM_TagReportData[] TagReportData;
                
        public PARAM_RFSurveyReportData[] RFSurveyReportData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IRO_ACCESS_REPORT_Custom_Param custom =
                param as IRO_ACCESS_REPORT_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            

        public MSG_RO_ACCESS_REPORT()
        {
            msgType = 61;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<RO_ACCESS_REPORT";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (TagReportData != null)
            {
          
                len = TagReportData.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(TagReportData[i].ToString());
                }
                
            }
        
            if (RFSurveyReportData != null)
            {
          
                len = RFSurveyReportData.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(RFSurveyReportData[i].ToString());
                }
                
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
		            xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</RO_ACCESS_REPORT>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_RO_ACCESS_REPORT
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_RO_ACCESS_REPORT</returns>
        public new static MSG_RO_ACCESS_REPORT  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_RO_ACCESS_REPORT msg = new MSG_RO_ACCESS_REPORT();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagReportData", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.TagReportData = new PARAM_TagReportData[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.TagReportData[i] = PARAM_TagReportData.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFSurveyReportData", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.RFSurveyReportData = new PARAM_RFSurveyReportData[xnl.Count];
                        for (int i=0; i<xnl.Count; i++)
                        {
                            msg.RFSurveyReportData[i] = PARAM_RFSurveyReportData.FromXmlNode(xnl[i]);
                        }
                    }
                }
                
            } catch { }
        
            try
            {
          
                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, nsmgr);
                if (xnl != null)
                {
                    for(int i=0; i<xnl.Count; i++)
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            msg.AddCustomParameter(custom);
                        }
                    }
                }
            
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (TagReportData != null)
            {
        
                len = TagReportData.Length;
                for (int i=0; i<len; i++)
                {
                    TagReportData[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (RFSurveyReportData != null)
            {
        
                len = RFSurveyReportData.Length;
                for (int i=0; i<len; i++)
                {
                    RFSurveyReportData[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_RO_ACCESS_REPORT
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_RO_ACCESS_REPORT</returns>
        public new static MSG_RO_ACCESS_REPORT FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_RO_ACCESS_REPORT obj = new MSG_RO_ACCESS_REPORT();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            param_list = new ArrayList();
            PARAM_TagReportData _param_TagReportData;
            while ((_param_TagReportData = PARAM_TagReportData.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_TagReportData);
            }
            if (param_list.Count > 0)
            {
                obj.TagReportData = new PARAM_TagReportData[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.TagReportData[i] = (PARAM_TagReportData)param_list[i];
                }
            }
            
            param_list = new ArrayList();
            PARAM_RFSurveyReportData _param_RFSurveyReportData;
            while ((_param_RFSurveyReportData = PARAM_RFSurveyReportData.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_RFSurveyReportData);
            }
            if (param_list.Count > 0)
            {
                obj.RFSurveyReportData = new PARAM_RFSurveyReportData[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.RFSurveyReportData[i] = (PARAM_RFSurveyReportData)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Reader to the Client. This message can be used by the Client to monitor the LLRP-layer connectivity with the Reader. The Client configures the trigger at the Reader to send the Keepalive message. The configuration is done using the KeepaliveSpec parameter (section 12.2.4).
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=77&amp;view=fit">LLRP Specification Section 13.1.3,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=125&amp;view=fit">LLRP Specification Section 16.1.31,</see>
    ///</summary>
    public class MSG_KEEPALIVE : Message
    {
      

        public MSG_KEEPALIVE()
        {
            msgType = 62;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<KEEPALIVE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</KEEPALIVE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_KEEPALIVE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_KEEPALIVE</returns>
        public new static MSG_KEEPALIVE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_KEEPALIVE msg = new MSG_KEEPALIVE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_KEEPALIVE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_KEEPALIVE</returns>
        public new static MSG_KEEPALIVE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_KEEPALIVE obj = new MSG_KEEPALIVE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///A Client SHALL generate a KEEPALIVE_ACK in response to each KEEPALIVE received by the reader.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=77&amp;view=fit">LLRP Specification Section 13.1.4,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=125&amp;view=fit">LLRP Specification Section 16.1.32,</see>
    ///</summary>
    public class MSG_KEEPALIVE_ACK : Message
    {
      

        public MSG_KEEPALIVE_ACK()
        {
            msgType = 72;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<KEEPALIVE_ACK";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</KEEPALIVE_ACK>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_KEEPALIVE_ACK
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_KEEPALIVE_ACK</returns>
        public new static MSG_KEEPALIVE_ACK  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_KEEPALIVE_ACK msg = new MSG_KEEPALIVE_ACK();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_KEEPALIVE_ACK
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_KEEPALIVE_ACK</returns>
        public new static MSG_KEEPALIVE_ACK FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_KEEPALIVE_ACK obj = new MSG_KEEPALIVE_ACK();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message is issued by the Reader to the Client whenever an event that the Client subscribed to occurs. The pertinent event data is conveyed using the ReaderEventNotificationData parameter.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=77&amp;view=fit">LLRP Specification Section 13.1.5,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=126&amp;view=fit">LLRP Specification Section 16.1.33,</see>
    ///</summary>
    public class MSG_READER_EVENT_NOTIFICATION : Message
    {
      
        public PARAM_ReaderEventNotificationData ReaderEventNotificationData;
              

        public MSG_READER_EVENT_NOTIFICATION()
        {
            msgType = 63;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<READER_EVENT_NOTIFICATION";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (ReaderEventNotificationData != null)
            {
          
                xml_str += Util.Indent(ReaderEventNotificationData.ToString());
                
            }
        
            xml_str += "</READER_EVENT_NOTIFICATION>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_READER_EVENT_NOTIFICATION
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_READER_EVENT_NOTIFICATION</returns>
        public new static MSG_READER_EVENT_NOTIFICATION  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_READER_EVENT_NOTIFICATION msg = new MSG_READER_EVENT_NOTIFICATION();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationData", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ReaderEventNotificationData = PARAM_ReaderEventNotificationData.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (ReaderEventNotificationData != null)
            {
        ReaderEventNotificationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_READER_EVENT_NOTIFICATION
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_READER_EVENT_NOTIFICATION</returns>
        public new static MSG_READER_EVENT_NOTIFICATION FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_READER_EVENT_NOTIFICATION obj = new MSG_READER_EVENT_NOTIFICATION();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.ReaderEventNotificationData = PARAM_ReaderEventNotificationData.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///This message can be issued by the Client to the Reader after a LLRP connection is established. The Client uses this message to inform the Reader that it can remove its hold on event and report messages.  Readers that are configured to hold events and reports on reconnection (See Section 12.2.6.4) respond to this message by returning the tag reports accumulated (same way they respond to GET_REPORT (See Section 13.1.1)).
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=78&amp;view=fit">LLRP Specification Section 13.1.6,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=126&amp;view=fit">LLRP Specification Section 16.1.34,</see>
    ///</summary>
    public class MSG_ENABLE_EVENTS_AND_REPORTS : Message
    {
      

        public MSG_ENABLE_EVENTS_AND_REPORTS()
        {
            msgType = 64;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ENABLE_EVENTS_AND_REPORTS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            xml_str += "</ENABLE_EVENTS_AND_REPORTS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ENABLE_EVENTS_AND_REPORTS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ENABLE_EVENTS_AND_REPORTS</returns>
        public new static MSG_ENABLE_EVENTS_AND_REPORTS  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ENABLE_EVENTS_AND_REPORTS msg = new MSG_ENABLE_EVENTS_AND_REPORTS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ENABLE_EVENTS_AND_REPORTS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ENABLE_EVENTS_AND_REPORTS</returns>
        public new static MSG_ENABLE_EVENTS_AND_REPORTS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_EVENTS_AND_REPORTS obj = new MSG_ENABLE_EVENTS_AND_REPORTS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            return obj;
        }
  
    }
    
    ///<summary>
    ///
    ///The Reader SHALL discard the message if there is at least one error in the message, or cannot be fully processed. In addition, no portion of the message containing an error SHALL be executed by the Reader. In case the message has one or more errors, the Reader SHALL return at least one error parameter for one of the errors. The Reader MAY return more than one error parameter, one for each error. The errors are conveyed using a combination of "generic error codes", a pointer to the culprit parameter/field, and a description of the error encoded as a string of UTF-8 characters.
    ///Typically the errors in the LLRP defined messages are conveyed inside of the responses from the Reader. However, in cases where the message received by the Reader contains an unsupported message type, or a CUSTOM_MESSAGE with unsupported parameters or fields, the Reader SHALL respond with the ERROR_MESSAGE.
    ///When a Reader or Client receives a command or notification with a version that is not supported, the receiver SHALL send an ERROR_MESSAGE in reply consisting of:  A version that is the same as the received message, the message ID that matches the received message, and an LLRPStatusParameter with the ErrorCode set to M_UnsupportedVersion. This message SHALL contain no sub-parameters (such as Field Error, Parameter Error).
    ///Readers and Clients SHALL not respond to an ERROR_MESSAGE. 
    ///This message is issued by the Reader to the Client, and it contains the LLRPStatus parameter that describes the error in the message.
    ///
    ///For more information, please refer to:
    ///
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=93&amp;view=fit">LLRP Specification Section 14.1.1,</see>
    ///<see cref="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=126&amp;view=fit">LLRP Specification Section 16.1.35,</see>
    ///</summary>
    public class MSG_ERROR_MESSAGE : Message
    {
      
        public PARAM_LLRPStatus LLRPStatus;
              

        public MSG_ERROR_MESSAGE()
        {
            msgType = 100;
            MSG_ID = MessageID.getNewMessageID();   // Give each message a unique ID by default
        }

      
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<ERROR_MESSAGE";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += string.Format(" xmlns:llrp=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            xml_str += "</ERROR_MESSAGE>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_ERROR_MESSAGE
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_ERROR_MESSAGE</returns>
        public new static MSG_ERROR_MESSAGE  FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);

            MSG_ERROR_MESSAGE msg = new MSG_ERROR_MESSAGE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }catch { }

    
            try
            {
          
                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                    }
                }
                
            } catch { }
        
            return msg;
        }
  
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen ,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID,32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_ERROR_MESSAGE
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_ERROR_MESSAGE</returns>
        public new static MSG_ERROR_MESSAGE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ERROR_MESSAGE obj = new MSG_ERROR_MESSAGE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
    }
    
}
  