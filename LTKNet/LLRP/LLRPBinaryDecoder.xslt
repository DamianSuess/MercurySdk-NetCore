<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:llrp="http://www.llrp.org/ltk/schema/core/encoding/binary/1.0">
  <xsl:output omit-xml-declaration='yes' method='text' indent='yes'/>
  <xsl:template match="/llrp:llrpdef">
    /*
    ***************************************************************************
    *  Copyright 2008 Impinj, Inc.
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    *
    ***************************************************************************
    */


    /*
    ***************************************************************************
    *
    *  This code is generated by Impinj LLRP .Net generator. Modification is not
    *  recommended.
    *
    ***************************************************************************
    */

    /*
    ***************************************************************************
    * File Name:       LLRPBinaryDecoder.cs
    *
    * Version:         1.0
    * Author:          Impinj
    * Organization:    Impinj
    * Date:            Jan. 18, 2008
    *
    * Description:     This file contains general XML Decoder for LLRP messages
    ***************************************************************************
    */

    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.ComponentModel;
    using System.Runtime.InteropServices;

    using Org.LLRP.LTK.LLRPV1;
    using Org.LLRP.LTK.LLRPV1.DataType;
    
    using System.Net;

    namespace Org.LLRP.LTK.LLRPV1
    {

    /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
    /// LLRP Binary Decoder
    /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>/summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
    public class LLRPBinaryDecoder
    {

       public const int MIN_HDR = 10;

       public struct LLRP_Envelope
       {
          public byte ver;
          public ENUM_LLRP_MSG_TYPE msg_type;
          public UInt32 msg_len;
          public UInt32 msg_id;
       }

       public static void Decode_Envelope (byte [] hdr, out LLRP_Envelope env)
       {
       
          System.IO.MemoryStream mr = new MemoryStream (hdr, 0, MIN_HDR);
          System.IO.BinaryReader br = new BinaryReader (mr);

          /* decode minimal header */
          env = new LLRP_Envelope();
          UInt16 prefix = (UInt16) IPAddress.NetworkToHostOrder ((short) br.ReadUInt16());
          env.ver = (byte)(prefix <xsl:text disable-output-escaping="yes">&gt;&gt;</xsl:text> 10);
          env.msg_type = (ENUM_LLRP_MSG_TYPE) (prefix <xsl:text disable-output-escaping="yes">&amp;</xsl:text> 1023);
          env.msg_len = (UInt32) IPAddress.NetworkToHostOrder((int) br.ReadUInt32());
          env.msg_id = (UInt32) IPAddress.NetworkToHostOrder((int) br.ReadUInt32());
       }
       
       /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
       /// Decode Binary LLRP packet to LLRP message object
       /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>/summary<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
       /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>param name="packet"<xsl:text disable-output-escaping="yes">&gt;</xsl:text>Binary LLRP packet to be decoded<xsl:text disable-output-escaping="yes">&lt;</xsl:text>/param<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
       /// <xsl:text disable-output-escaping="yes">&lt;</xsl:text>param name="msg"<xsl:text disable-output-escaping="yes">&gt;</xsl:text>LLRP message. output<xsl:text disable-output-escaping="yes">&lt;</xsl:text>/param<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
       public static void Decode(ref byte [] packet, out Message msg)
       {
          LLRP_Envelope env;
          Decode_Envelope (packet, out env);
          
          BitArray ba = Util.ConvertByteArrayToBitArray(packet);
          int cursor = 0;

          switch(env.msg_type)
          {
          <xsl:for-each select="llrp:messageDefinition">
             case ENUM_LLRP_MSG_TYPE.<xsl:value-of select="@name"/>:
            <xsl:choose>
              <xsl:when test="@name='CUSTOM_MESSAGE'">
                msg = CustomMsgDecodeFactory.DecodeCustomMessage(ref ba, ref cursor, (int)(env.msg_len * 8));
              </xsl:when>
              <xsl:otherwise>
                msg = MSG_<xsl:value-of select="@name"/>.FromBitArray(ref ba, ref cursor, (int)(env.msg_len * 8));
              </xsl:otherwise>
            </xsl:choose>
                return;
          </xsl:for-each>
             default:
                throw new MalformedPacket ("Unrecognized message " + env.msg_type);
          }
       }
    }
    
    public class MalformedPacket : System.Exception
    {
        // The default constructor needs to be defined
        // explicitly now since it would be gone otherwise.

        public MalformedPacket()
        {
        }

        public MalformedPacket(string message)
            : base(message)
        {
        }

        public MalformedPacket(string message, Exception innerException)
            : base(message, innerException)
        {
        }

    }

    }
    
    
  </xsl:template>
</xsl:stylesheet>
