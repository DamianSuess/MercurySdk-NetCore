
/*
 ***************************************************************************
 *
 *  Copyright 2009 Impinj, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ***************************************************************************
 */

/*
 ***************************************************************************
 *
 *  This code is generated by Impinj LLRP .Net generator. Modification
 *  is not recommended.
 *
 ***************************************************************************
 */

/*
 ***************************************************************************
 * File Name:       VendorExt.cs
 * Author:          Your Name
 * Organization:    Your Company
 * Date:            Date
 * Description:     This file contains LLRP vendor extension
 ***************************************************************************
*/

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml;
using System.Xml.Schema;
using System.ComponentModel;
using System.Reflection;

using Org.LLRP.LTK.LLRPV1;
using Org.LLRP.LTK.LLRPV1.DataType;

namespace Org.LLRP.LTK.LLRPV1.thingmagic
{
    public class LLRPExtensionConstants
    {
        public const string NAMESPACE_PREFIX = "thingmagic";
        public const string NAMESPACE_URI = "http://www.thingmagic.com/ltk/schema/extension/xml/1.0/";
        public const string NAMESPACE_SCHEMALOCATION = "http://www.thingmagic.com/ltk/schema/extension/xml/1.0/thingmagic.xsd";
        public const string VENDOR_NAME = "thingmagic";
        public const string VENDOR_ID = "26554";
    }

    public class thingmagic_Installer
    {
        public static void Install()
        {
            Assembly asm = Assembly.GetExecutingAssembly();
            CustomMsgDecodeFactory.LoadVendorExtensionAssembly(asm);
            CustomParamDecodeFactory.LoadVendorExtensionAssembly(asm);
        }
    }

    #region Custom Parameter Interface
    
    public interface ITHINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS_Custom_Param : ICustom_Parameter {}
        
    public interface ITHINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDeviceControlCapabilities_Custom_Param : ICustom_Parameter {}
        
    public interface IDeviceInformationCapabilities_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDeviceControlConfiguration_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicReaderConfiguration_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicRegionConfiguration_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicProtocolConfiguration_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2CustomParameters_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicAntennaConfiguration_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicCurrentTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDeDuplication_Custom_Param : ICustom_Parameter {}
        
    public interface IDeviceProtocolCapabilities_Custom_Param : ICustom_Parameter {}
        
    public interface ISupportedProtocols_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicReaderModuleTemperature_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2Q_Custom_Param : ICustom_Parameter {}
        
    public interface IInitQ_Custom_Param : ICustom_Parameter {}
        
    public interface IqValue_Custom_Param : ICustom_Parameter {}
        
    public interface IsendSelect_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicAntennaDetection_Custom_Param : ICustom_Parameter {}
        
    public interface IWriteTransmitPower_Custom_Param : ICustom_Parameter {}
        
    public interface IReadPointDescription_Custom_Param : ICustom_Parameter {}
        
    public interface IAntennaMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicTargetStrategy_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2T4Param_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicLicenseKey_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicBlockPermalock_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicBlockPermalockOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs2PartialLoadImage_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs2PartialLoadImageOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs2FullLoadImage_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs2FullLoadImageOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3FastLoadImage_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3FastLoadImageOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3LoadImage_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3LoadImageOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3BlockReadLock_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHiggs3BlockReadLockOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2ISetReadProtect_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2ISetReadProtectOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XSetReadProtect_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XSetReadProtectOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IResetReadProtect_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IResetReadProtectOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XResetReadProtect_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XResetReadProtectOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IChangeEAS_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IChangeEASOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XChangeEAS_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XChangeEASOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IEASAlarm_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IEASAlarmOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XEASAlarm_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XEASAlarmOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2ICalibrate_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2ICalibrateOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XCalibrate_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2XCalibrateOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IChangeConfig_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPG2IChangeConfigOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPConfigWord_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicImpinjMonza4QTReadWrite_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicImpinjMonza4QTReadWriteOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicMonza4ControlByte_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicMonza4Payload_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicWriteTag_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicWriteTagOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO180006BReadOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO180006BWriteOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO180006BLockOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IISO18K6BCustomParameters_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO180006BDelimiter_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO18K6BModulationDepth_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicISO18K6BLinkFrequency_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASensorValue_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ACommandRequest_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASensorValueOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetLogState_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ALogStateOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogState_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogStateLimitCounter_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogStateSystemStatus_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogStateStatusFlag_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetLogMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetLogModeOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AStartLog_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AStartLogOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AEndLog_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AEndLogOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AInitialize_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AInitializeOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetMeasurementSetup_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetMeasurementSetupOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetCalibrationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetCalibrationDataOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetCalibrationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetCalibrationDataOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetSFEParams_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetSFEParamsOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFOStatus_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFOStatusOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetBatteryLevel_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AGetBatteryLevelOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSDelayTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSApplicationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSLogLimits_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSStartTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSFEParam_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSCalibrationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFORead_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFOReadOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFOWrite_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900AAccessFIFOWriteOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetLogLimits_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetLogLimitsOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetIDSPassword_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSL900ASetPasswordOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSBatteryLevel_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSetShelfLife_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSLBlock0_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSLBlock1_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicIDSSetShelfLifeOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicHopTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVActivateSecureMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVActivateSecureModeOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVAuthenticateOBU_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVAuthenticateOBUOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVActivateSiniavMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVActivateSiniavModeOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateID_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateFullPass1_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateFullPass2_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUReadFromMemMap_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUWriteToMemMap_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicDenatranIAVCommandRequest_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicTagReportContentSelector_Custom_Param : ICustom_Parameter {}
        
    public interface IMetadataGPIOMode_Custom_Param : ICustom_Parameter {}
        
    public interface IMetadataGen2QMode_Custom_Param : ICustom_Parameter {}
        
    public interface IMetadataGen2LFMode_Custom_Param : ICustom_Parameter {}
        
    public interface IMetadataGen2TargetMode_Custom_Param : ICustom_Parameter {}
        
    public interface IMetadataDataMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicRFPhase_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicMetadataGPIO_Custom_Param : ICustom_Parameter {}
        
    public interface IGPIOStatus_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicMetadataGen2_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2QResponse_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2LFResponse_Custom_Param : ICustom_Parameter {}
        
    public interface IGen2TargetResponse_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicFastSearchMode_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicAsyncOFFTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicAsyncONTime_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicLicensedFeatures_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicSelectedProtocols_Custom_Param : ICustom_Parameter {}
        
    public interface ISelectedProtocol_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPReadbuffer_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPReadbufferOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPAuthentication_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPAuthenticationOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPTAM2AuthenticationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPCommandRequest_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicGEN2ProtocolExtension_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPUntraceable_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPUntraceableOpSpecResult_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPUntraceableAuthentication_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicNXPTAM1AuthenticationData_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicAntennaReturnloss_Custom_Param : ICustom_Parameter {}
        
    public interface IReturnlossValue_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicMetadata_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicStatsEnable_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicReaderStats_Custom_Param : ICustom_Parameter {}
        
    public interface ICustomStatsValue_Custom_Param : ICustom_Parameter {}
        
    public interface ITemperatureParam_Custom_Param : ICustom_Parameter {}
        
    public interface IProtocolParam_Custom_Param : ICustom_Parameter {}
        
    public interface IAntennaParam_Custom_Param : ICustom_Parameter {}
        
    public interface IFrequencyParam_Custom_Param : ICustom_Parameter {}
        
    public interface IConnectedAntennaList_Custom_Param : ICustom_Parameter {}
        
    public interface IperAntennaStatsList_Custom_Param : ICustom_Parameter {}
        
    public interface IRFOntimeParam_Custom_Param : ICustom_Parameter {}
        
    public interface INoiseFloorParam_Custom_Param : ICustom_Parameter {}
        
    public interface IThingMagicCustomTagopResponse_Custom_Param : ICustom_Parameter {}
        
    public interface ITagopByteStreamParam_Custom_Param : ICustom_Parameter {}
        
    #endregion

    
    public class PARAM_thingmagic_Custom : PARAM_Custom
    {
        //Add vendor custom parameter implementation while applicable.
        public override void ToBitArray(ref bool[] bit_array, ref int cursor) { }
        public new static PARAM_thingmagic_Custom FromBitArray(ref BitArray bit_array, ref int cursor, int length) { return null; }
        public override string ToString() { return null; }
        public new static PARAM_thingmagic_Custom FromXmlNode(XmlNode node) { return null; }
    }

    
        ///<summary>
        ///
        ///An enumeration of ThingMagic Reader Device operating status
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicReaderOperatingStatus
    {
        IDLE = 0,
        RUNNING = 1,
        ERROR = 2,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of ThingMagic Control plane capabilities
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicControlCapabilities
    {
        All = 0,
        DeviceInformationCapabilities = 1,
        DeviceProtocolCapabilities = 2,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of ThingMagic Control plane configuration
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicControlConfiguration
    {
        All = 0,
        ThingMagicReaderConfiguration = 1,
        ThingMagicRegionConfiguration = 2,
        ThingMagicProtocolConfiguration = 3,
        ThingMagicAntennaConfiguration = 4,
        ThingMagicCurrentTime = 5,
        ThingMagicDeDuplication = 6,
        ThingMagicReaderModuleTemperature = 7,
        ThingMagicAntennaDetection = 8,
        ThingMagicLicenseKey = 9,
        ThingMagicHopTime = 10,
        ThingMagicAsyncOFFTime = 11,
        ThingMagicLicensedFeatures = 12,
        ThingMagicSelectedProtocols = 13,
        ThingMagicGEN2ProtocolExtension = 14,
        ThingMagicAsyncONTime = 17,
        ThingMagicAntennaReturnloss = 18,
        ThingMagicMetadata = 19,
        ThingMagicStatsEnable = 20,
        ThingMagicReaderStats = 21,
        ThingMagicPortSwitchGPO = 22,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of Regulatory Regions supported by ThingMagic Reader
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicRegionID
    {
        UnspecifiedRegion = 0,
        NorthAmerica = 1,
        EuropeanUnion = 2,
        Korea = 3,
        India = 4,
        Japan = 5,
        PeoplesRepublicofChina = 6,
        EuropeanUnion2 = 7,
        EuropeanUnion3 = 8,
        Korea2 = 9,
        Australia = 11,
        NewZealand = 12,
        Open = 255,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of Antenna Mode
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicAntennaMode
    {
        MonoStatic = 0,
        BiStatic = 1,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of Regulatory Regions supported by ThingMagic Reader
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ProtocolID
    {
        UnspecifiedProtocol = 0,
        ISO180006B = 3,
        GEN2 = 5,
        ISO180006B_UCODE = 6,
        IPX64 = 7,
        IPX256 = 8,
        ATA = 29,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of Gen2 Q types
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_QType
    {
        Dynamic = 0,
        Static = 1,
        
    }
    
        ///<summary>
        ///
        ///An enumeration of C1G2 Target types
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicC1G2TargetStrategy
    {
        TargetA = 0,
        TargetB = 1,
        TargetAB = 2,
        TargetBA = 3,
        
    }
    
        ///<summary>
        ///
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomTagOpSpecResultType
    {
        Success = 0,
        Nonspecific_Tag_Error = 1,
        No_Response_From_Tag = 2,
        Nonspecific_Reader_Error = 3,
        Unsupported_Operation = 4,
        Tag_Memory_Overrun_Error = 5,
        Gen2V2_Authentication_Fail = 6,
        Gen2V2_Untrace_Fail = 7,
        
    }
    
        ///<summary>
        ///
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicGen2DivideRatio
    {
        Divide_Ratio_8 = 0,
        Divide_Ratio_64_3 = 1,
        
    }
    
        ///<summary>
        ///
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicGen2TagEncoding
    {
        FM0 = 0,
        M2 = 1,
        M4 = 2,
        M8 = 3,
        
    }
    
        ///<summary>
        ///
        ///This is the identifier of custom air protocols. It continues from maximum value of standard protocols supported by the specification. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomAirProtocolList
    {
        Iso180006b = 2,
        IPX64 = 3,
        IPX256 = 4,
        ATA = 5,
        
    }
    
        ///<summary>
        ///
        ///This is the identifier of ThingMagic ISO180006B FilterType. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicISO180006BFilterType
    {
        ISO180006BSelect = 0,
        ISO180006BTagData = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various delimiter values for ISO18K6B. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustom18K6BDelimiter
    {
        ISO180006B_Delimiter1 = 1,
        ISO180006B_Delimiter4 = 4,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various modulation depth values for ISO18K6B. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustom18K6BModulationDepth
    {
        ISO180006B_ModulationDepth99percent = 0,
        ISO180006B_ModulationDepth11percent = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Link Frequencies for ISO18K6B. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustom18K6BLinkFrequency
    {
        ISO180006B_LINKFREQUENCY_40KHZ = 40,
        ISO180006B_LINKFREQUENCY_160KHZ = 160,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Sensor types for IDS custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomIDSSensorType
    {
        IDSSL900A_SENSOR_TEMP = 0,
        IDSSL900A_SENSOR_EXT1 = 1,
        IDSSL900A_SENSOR_EXT2 = 2,
        IDSSL900A_SENSOR_BATTV = 3,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Password levels for IDS custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomIDSPasswordLevel
    {
        IDSSL900A_PASSWORD_NOTALLOWED = 0,
        IDSSL900A_PASSWORD_SYSTEM = 1,
        IDSSL900A_PASSWORD_APPLICATION = 2,
        IDSSL900A_PASSWORD_MEASUREMENT = 3,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Logging forms for IDS custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomIDSLoggingForm
    {
        IDSSL900A_LOGGINGFORM_DENSE = 0,
        IDSSL900A_LOGGINGFORM_OUTOFLIMITS = 1,
        IDSSL900A_LOGGINGFORM_LIMITSCROSSING = 3,
        IDSSL900A_LOGGINGFORM_IRQ1 = 5,
        IDSSL900A_LOGGINGFORM_IRQ2 = 6,
        IDSSL900A_LOGGINGFORM_IRQ1IRQ2 = 7,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Storage rules for IDS custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomIDSStorageRule
    {
        IDSSL900A_STORAGERULE_NORMAL = 0,
        IDSSL900A_STORAGERULE_ROLLING = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various SFE types for IDS custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomIDSSFEType
    {
        IDSSL900A_SFE_RANG = 0,
        IDSSL900A_SFE_SETI = 1,
        IDSSL900A_SFE_EXT1 = 2,
        IDSSL900A_SFE_EXT2 = 3,
        IDSSL900A_SFE_AUTORANGEDISABLE = 4,
        IDSSL900A_SFE_VERIFYSENSORID = 5,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the options to enable/disable the Phase in the ROReport 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicPhaseMode
    {
        Disabled = 0,
        Enabled = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the options to enable/disable the Metadata Flag in the ROReport 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicMetadataFlagStatus
    {
        Disabled = 0,
        Enabled = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the options to enable/disable the Fast Search Mode 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicFastSearchValue
    {
        Disabled = 0,
        Enabled = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various Authentication types for NXP custom tag operations. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPAuthenticationType
    {
        TAM1_AUTHENTICATION = 0,
        TAM2_AUTHENTICATION = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various NXP profile types 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicNXPProfileType
    {
        EPC = 0,
        TID = 1,
        USER = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various KEY types . 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPKeyType
    {
        KEY0 = 0,
        KEY1 = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides untraceable EPC types. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPUntraceableEPC
    {
        EPC_SHOW = 0,
        EPC_HIDE = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various untraceable tid types. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPUntraceableTID
    {
        HIDE_NONE = 0,
        HIDE_SOME = 1,
        HIDE_ALL = 2,
        TID_RFU = 3,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various untraceable UserMemory types. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPUntraceableUserMemory
    {
        SHOW = 0,
        HIDE = 1,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides the various untraceable user memory range. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPUntraceableRange
    {
        NORMAL = 0,
        REDUCED = 1,
        TOGGLE_TEMPORARLY = 2,
        RFU = 3,
        
    }
    
        ///<summary>
        ///
        ///This custom enumeration provides untraceable Authentication types. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomNXPUntraceableAuthType
    {
        UNTRACEABLE_WITH_AUTHENTICATION = 0,
        UNTRACEABLE_WITH_ACCESS = 1,
        
    }
    
        ///<summary>
        ///
        ///It provides the Thingmagic custom protocol ID. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomProtocol
    {
        Gen2 = 1,
        Iso180006b = 2,
        IPX64 = 3,
        IPX256 = 4,
        Ata = 5,
        
    }
    
        ///<summary>
        ///
        ///It provides the Thingmagic custom Metadata values. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomMetadataFlag
    {
        MetadataNone = 0,
        MetadataReadCount = 1,
        MetadataRSSI = 2,
        MetadataAntID = 4,
        MetadataFrequency = 8,
        MetadataTimestamp = 16,
        MetadataPhase = 32,
        MetadataProtocol = 64,
        MetadataData = 128,
        MetadataGPIOStatus = 256,
        MetadataGen2Q = 512,
        MetadataGen2LF = 1024,
        MetadataGen2Target = 2048,
        MetadataBrandID = 4096,
        MetadataMax = 4096,
        MetadataAll = 4095,
        
    }
    
        ///<summary>
        ///
        ///It provides the Thingmagic custom StatsEnable value. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomStatsEnableFlag
    {
        StatsEnableNone = 0,
        StatsEnableRFOnTime = 1,
        StatsEnableNoiseFloorSearchRxTxWithTxOn = 64,
        StatsEnableFrequency = 128,
        StatsEnableTemperature = 256,
        StatsEnableAntennaPorts = 512,
        StatsEnableProtocol = 1024,
        StatsEnableConnectedAntennas = 2048,
        StatsEnableAll = 4033,
        
    }
    
        ///<summary>
        ///
        ///It provides the Thingmagic custom antenna switching type. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public enum ENUM_ThingMagicCustomAntennaSwitchingType
    {
        Equal = 0,
        Dynamic = 1,
        
    }
    
        ///<summary>
        ///
        ///This parameter fills in the control plane capabilities that are specific to a thingmagic reader. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDeviceControlCapabilities : PARAM_Custom,IGET_READER_CAPABILITIES_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDeviceControlCapabilities()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 1;
        }
      
        public ENUM_ThingMagicControlCapabilities RequestedData;
        private Int16 RequestedData_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDeviceControlCapabilities_Custom_Param custom =
                param as IThingMagicDeviceControlCapabilities_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (RequestedData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDeviceControlCapabilities</returns>
        public new static PARAM_ThingMagicDeviceControlCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDeviceControlCapabilities obj = new PARAM_ThingMagicDeviceControlCapabilities();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.RequestedData = (ENUM_ThingMagicControlCapabilities)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDeviceControlCapabilities";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (RequestedData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RequestedData>" + RequestedData.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RequestedData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDeviceControlCapabilities>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDeviceControlCapabilities</returns>
        public new static PARAM_ThingMagicDeviceControlCapabilities  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDeviceControlCapabilities param = new PARAM_ThingMagicDeviceControlCapabilities();
    
            val = XmlUtil.GetNodeValue(node, "RequestedData");
        
            param.RequestedData = (ENUM_ThingMagicControlCapabilities)Enum.Parse(typeof(ENUM_ThingMagicControlCapabilities), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Device information fields required for RM Device Information command. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_DeviceInformationCapabilities : PARAM_Custom,IGET_READER_CAPABILITIES_RESPONSE_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_DeviceInformationCapabilities()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 2;
        }
      
        public string ReaderEPC=string.Empty;
        private Int16 ReaderEPC_len=0;
      
        public string ReaderSerialNumber=string.Empty;
        private Int16 ReaderSerialNumber_len=0;
      
        public string HardwareVersion=string.Empty;
        private Int16 HardwareVersion_len=0;
      
        public string AFEVersion=string.Empty;
        private Int16 AFEVersion_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IDeviceInformationCapabilities_Custom_Param custom =
                param as IDeviceInformationCapabilities_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReaderEPC != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderEPC.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderEPC, ReaderEPC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReaderSerialNumber != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderSerialNumber.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderSerialNumber, ReaderSerialNumber_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (HardwareVersion != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(HardwareVersion.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(HardwareVersion, HardwareVersion_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AFEVersion != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(AFEVersion.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(AFEVersion, AFEVersion_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_DeviceInformationCapabilities</returns>
        public new static PARAM_DeviceInformationCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_DeviceInformationCapabilities obj = new PARAM_DeviceInformationCapabilities();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderEPC = (string)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderSerialNumber = (string)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.HardwareVersion = (string)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.AFEVersion = (string)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"DeviceInformationCapabilities";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReaderEPC != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderEPC>" + Util.ConvertArrayTypeToString(ReaderEPC, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderEPC>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReaderSerialNumber != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderSerialNumber>" + Util.ConvertArrayTypeToString(ReaderSerialNumber, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderSerialNumber>";
            
	            xml_str += "\r\n";
	        }
        
            if (HardwareVersion != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "HardwareVersion>" + Util.ConvertArrayTypeToString(HardwareVersion, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "HardwareVersion>";
            
	            xml_str += "\r\n";
	        }
        
            if (AFEVersion != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AFEVersion>" + Util.ConvertArrayTypeToString(AFEVersion, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AFEVersion>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":DeviceInformationCapabilities>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_DeviceInformationCapabilities</returns>
        public new static PARAM_DeviceInformationCapabilities  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_DeviceInformationCapabilities param = new PARAM_DeviceInformationCapabilities();
    
            val = XmlUtil.GetNodeValue(node, "ReaderEPC");
        
            param.ReaderEPC = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReaderSerialNumber");
        
            param.ReaderSerialNumber = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "HardwareVersion");
        
            param.HardwareVersion = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "AFEVersion");
        
            param.AFEVersion = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter fills in the control plane configuration parameters that are specific to a thingmagic reader. 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDeviceControlConfiguration : PARAM_Custom,IGET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDeviceControlConfiguration()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 3;
        }
      
        public UInt16 AntennaID=0;
        private Int16 AntennaID_len=0;
      
        public ENUM_ThingMagicControlConfiguration RequestedData;
        private Int16 RequestedData_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDeviceControlConfiguration_Custom_Param custom =
                param as IThingMagicDeviceControlConfiguration_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AntennaID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (RequestedData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDeviceControlConfiguration</returns>
        public new static PARAM_ThingMagicDeviceControlConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDeviceControlConfiguration obj = new PARAM_ThingMagicDeviceControlConfiguration();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.AntennaID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.RequestedData = (ENUM_ThingMagicControlConfiguration)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDeviceControlConfiguration";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AntennaID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaID>" + Util.ConvertValueTypeToString(AntennaID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AntennaID>";
            
	            xml_str += "\r\n";
	        }
        
            if (RequestedData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RequestedData>" + RequestedData.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RequestedData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDeviceControlConfiguration>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDeviceControlConfiguration</returns>
        public new static PARAM_ThingMagicDeviceControlConfiguration  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDeviceControlConfiguration param = new PARAM_ThingMagicDeviceControlConfiguration();
    
            val = XmlUtil.GetNodeValue(node, "AntennaID");
        
            param.AntennaID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "RequestedData");
        
            param.RequestedData = (ENUM_ThingMagicControlConfiguration)Enum.Parse(typeof(ENUM_ThingMagicControlConfiguration), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic Reader configuration values like Reader Description, Reader Role etc., 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicReaderConfiguration : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicReaderConfiguration()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 4;
        }
      
        public string ReaderDescription=string.Empty;
        private Int16 ReaderDescription_len=0;
      
        public string ReaderRole=string.Empty;
        private Int16 ReaderRole_len=0;
      
        public string ReaderHostName=string.Empty;
        private Int16 ReaderHostName_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicReaderConfiguration_Custom_Param custom =
                param as IThingMagicReaderConfiguration_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReaderDescription != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderDescription.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderDescription, ReaderDescription_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReaderRole != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderRole.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderRole, ReaderRole_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReaderHostName != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderHostName.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderHostName, ReaderHostName_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicReaderConfiguration</returns>
        public new static PARAM_ThingMagicReaderConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicReaderConfiguration obj = new PARAM_ThingMagicReaderConfiguration();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderDescription = (string)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderRole = (string)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderHostName = (string)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicReaderConfiguration";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReaderDescription != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderDescription>" + Util.ConvertArrayTypeToString(ReaderDescription, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderDescription>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReaderRole != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderRole>" + Util.ConvertArrayTypeToString(ReaderRole, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderRole>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReaderHostName != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderHostName>" + Util.ConvertArrayTypeToString(ReaderHostName, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderHostName>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicReaderConfiguration>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicReaderConfiguration</returns>
        public new static PARAM_ThingMagicReaderConfiguration  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicReaderConfiguration param = new PARAM_ThingMagicReaderConfiguration();
    
            val = XmlUtil.GetNodeValue(node, "ReaderDescription");
        
            param.ReaderDescription = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReaderRole");
        
            param.ReaderRole = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReaderHostName");
        
            param.ReaderHostName = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific region information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicRegionConfiguration : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicRegionConfiguration()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 5;
        }
      
        public ENUM_ThingMagicRegionID RegionID;
        private Int16 RegionID_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicRegionConfiguration_Custom_Param custom =
                param as IThingMagicRegionConfiguration_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (RegionID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RegionID, RegionID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicRegionConfiguration</returns>
        public new static PARAM_ThingMagicRegionConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicRegionConfiguration obj = new PARAM_ThingMagicRegionConfiguration();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.RegionID = (ENUM_ThingMagicRegionID)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicRegionConfiguration";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (RegionID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RegionID>" + RegionID.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RegionID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicRegionConfiguration>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicRegionConfiguration</returns>
        public new static PARAM_ThingMagicRegionConfiguration  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicRegionConfiguration param = new PARAM_ThingMagicRegionConfiguration();
    
            val = XmlUtil.GetNodeValue(node, "RegionID");
        
            param.RegionID = (ENUM_ThingMagicRegionID)Enum.Parse(typeof(ENUM_ThingMagicRegionID), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific Protocol information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicProtocolConfiguration : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicProtocolConfiguration()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 6;
        }
      
        public PARAM_Gen2CustomParameters Gen2CustomParameters;
                
        public PARAM_ISO18K6BCustomParameters ISO18K6BCustomParameters;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicProtocolConfiguration_Custom_Param custom =
                param as IThingMagicProtocolConfiguration_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Gen2CustomParameters != null)
            {
        Gen2CustomParameters.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ISO18K6BCustomParameters != null)
            {
        ISO18K6BCustomParameters.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicProtocolConfiguration</returns>
        public new static PARAM_ThingMagicProtocolConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicProtocolConfiguration obj = new PARAM_ThingMagicProtocolConfiguration();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.Gen2CustomParameters = PARAM_Gen2CustomParameters.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ISO18K6BCustomParameters = PARAM_ISO18K6BCustomParameters.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicProtocolConfiguration";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Gen2CustomParameters != null)
            {
          
                xml_str += Util.Indent(Gen2CustomParameters.ToString());
            
            }
        
            if (ISO18K6BCustomParameters != null)
            {
          
                xml_str += Util.Indent(ISO18K6BCustomParameters.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicProtocolConfiguration>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicProtocolConfiguration</returns>
        public new static PARAM_ThingMagicProtocolConfiguration  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicProtocolConfiguration param = new PARAM_ThingMagicProtocolConfiguration();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2CustomParameters", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2CustomParameters = PARAM_Gen2CustomParameters.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ISO18K6BCustomParameters", nsmgr);
            if (xnl.Count != 0)
            {
                param.ISO18K6BCustomParameters = PARAM_ISO18K6BCustomParameters.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "Gen2CustomParameters", "ISO18K6BCustomParameters",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific Protocol information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2CustomParameters : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2CustomParameters()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 7;
        }
      
        public PARAM_Gen2Q Gen2Q;
                
        public PARAM_ThingMagicTargetStrategy ThingMagicTargetStrategy;
                
        public PARAM_Gen2T4Param Gen2T4Param;
                
        public PARAM_InitQ InitQ;
                
        public PARAM_sendSelect sendSelect;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2CustomParameters_Custom_Param custom =
                param as IGen2CustomParameters_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Gen2Q != null)
            {
        Gen2Q.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicTargetStrategy != null)
            {
        ThingMagicTargetStrategy.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Gen2T4Param != null)
            {
        Gen2T4Param.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (InitQ != null)
            {
        InitQ.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (sendSelect != null)
            {
        sendSelect.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2CustomParameters</returns>
        public new static PARAM_Gen2CustomParameters FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2CustomParameters obj = new PARAM_Gen2CustomParameters();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.Gen2Q = PARAM_Gen2Q.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicTargetStrategy = PARAM_ThingMagicTargetStrategy.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.Gen2T4Param = PARAM_Gen2T4Param.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.InitQ = PARAM_InitQ.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.sendSelect = PARAM_sendSelect.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2CustomParameters";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Gen2Q != null)
            {
          
                xml_str += Util.Indent(Gen2Q.ToString());
            
            }
        
            if (ThingMagicTargetStrategy != null)
            {
          
                xml_str += Util.Indent(ThingMagicTargetStrategy.ToString());
            
            }
        
            if (Gen2T4Param != null)
            {
          
                xml_str += Util.Indent(Gen2T4Param.ToString());
            
            }
        
            if (InitQ != null)
            {
          
                xml_str += Util.Indent(InitQ.ToString());
            
            }
        
            if (sendSelect != null)
            {
          
                xml_str += Util.Indent(sendSelect.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2CustomParameters>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2CustomParameters</returns>
        public new static PARAM_Gen2CustomParameters  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2CustomParameters param = new PARAM_Gen2CustomParameters();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2Q", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2Q = PARAM_Gen2Q.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicTargetStrategy", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicTargetStrategy = PARAM_ThingMagicTargetStrategy.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2T4Param", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2T4Param = PARAM_Gen2T4Param.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "InitQ", nsmgr);
            if (xnl.Count != 0)
            {
                param.InitQ = PARAM_InitQ.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "sendSelect", nsmgr);
            if (xnl.Count != 0)
            {
                param.sendSelect = PARAM_sendSelect.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "Gen2Q", "ThingMagicTargetStrategy", "Gen2T4Param", "InitQ", "sendSelect",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific antenna configuration information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicAntennaConfiguration : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicAntennaConfiguration()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 8;
        }
      
        public UInt16 AntennaID=0;
        private Int16 AntennaID_len=0;
      
        public PARAM_AntennaMode AntennaMode;
                
        public PARAM_WriteTransmitPower WriteTransmitPower;
                
        public PARAM_ReadPointDescription ReadPointDescription;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicAntennaConfiguration_Custom_Param custom =
                param as IThingMagicAntennaConfiguration_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AntennaID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AntennaMode != null)
            {
        AntennaMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (WriteTransmitPower != null)
            {
        WriteTransmitPower.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ReadPointDescription != null)
            {
        ReadPointDescription.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicAntennaConfiguration</returns>
        public new static PARAM_ThingMagicAntennaConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicAntennaConfiguration obj = new PARAM_ThingMagicAntennaConfiguration();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.AntennaID = (UInt16)obj_val;
          
            obj.AntennaMode = PARAM_AntennaMode.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.WriteTransmitPower = PARAM_WriteTransmitPower.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ReadPointDescription = PARAM_ReadPointDescription.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicAntennaConfiguration";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AntennaID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaID>" + Util.ConvertValueTypeToString(AntennaID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AntennaID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AntennaMode != null)
            {
          
                xml_str += Util.Indent(AntennaMode.ToString());
            
            }
        
            if (WriteTransmitPower != null)
            {
          
                xml_str += Util.Indent(WriteTransmitPower.ToString());
            
            }
        
            if (ReadPointDescription != null)
            {
          
                xml_str += Util.Indent(ReadPointDescription.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicAntennaConfiguration>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicAntennaConfiguration</returns>
        public new static PARAM_ThingMagicAntennaConfiguration  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicAntennaConfiguration param = new PARAM_ThingMagicAntennaConfiguration();
    
            val = XmlUtil.GetNodeValue(node, "AntennaID");
        
            param.AntennaID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.AntennaMode = PARAM_AntennaMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "WriteTransmitPower", nsmgr);
            if (xnl.Count != 0)
            {
                param.WriteTransmitPower = PARAM_WriteTransmitPower.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReadPointDescription", nsmgr);
            if (xnl.Count != 0)
            {
                param.ReadPointDescription = PARAM_ReadPointDescription.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "AntennaMode", "WriteTransmitPower", "ReadPointDescription",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic current time value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCurrentTime : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCurrentTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 9;
        }
      
        public string ReaderCurrentTime=string.Empty;
        private Int16 ReaderCurrentTime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicCurrentTime_Custom_Param custom =
                param as IThingMagicCurrentTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReaderCurrentTime != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderCurrentTime.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderCurrentTime, ReaderCurrentTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCurrentTime</returns>
        public new static PARAM_ThingMagicCurrentTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCurrentTime obj = new PARAM_ThingMagicCurrentTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReaderCurrentTime = (string)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCurrentTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReaderCurrentTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderCurrentTime>" + Util.ConvertArrayTypeToString(ReaderCurrentTime, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderCurrentTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCurrentTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCurrentTime</returns>
        public new static PARAM_ThingMagicCurrentTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCurrentTime param = new PARAM_ThingMagicCurrentTime();
    
            val = XmlUtil.GetNodeValue(node, "ReaderCurrentTime");
        
            param.ReaderCurrentTime = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic De Duplication related fields 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDeDuplication : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDeDuplication()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 10;
        }
      
        public bool RecordHighestRSSI=false;
        private Int16 RecordHighestRSSI_len=0;
      
        private const UInt16 param_reserved_len3= 7;
        
        public bool UniqueByAntenna=false;
        private Int16 UniqueByAntenna_len=0;
      
        private const UInt16 param_reserved_len5= 7;
        
        public bool UniqueByData=false;
        private Int16 UniqueByData_len=0;
      
        private const UInt16 param_reserved_len7= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDeDuplication_Custom_Param custom =
                param as IThingMagicDeDuplication_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (RecordHighestRSSI != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RecordHighestRSSI, RecordHighestRSSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (UniqueByAntenna != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(UniqueByAntenna, UniqueByAntenna_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (UniqueByData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(UniqueByData, UniqueByData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDeDuplication</returns>
        public new static PARAM_ThingMagicDeDuplication FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDeDuplication obj = new PARAM_ThingMagicDeDuplication();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.RecordHighestRSSI = (bool)obj_val;
          
            cursor += param_reserved_len3;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.UniqueByAntenna = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.UniqueByData = (bool)obj_val;
          
            cursor += param_reserved_len7;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDeDuplication";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (RecordHighestRSSI != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RecordHighestRSSI>" + Util.ConvertValueTypeToString(RecordHighestRSSI, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "RecordHighestRSSI>";
            
	            xml_str += "\r\n";
	        }
        
            if (UniqueByAntenna != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "UniqueByAntenna>" + Util.ConvertValueTypeToString(UniqueByAntenna, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "UniqueByAntenna>";
            
	            xml_str += "\r\n";
	        }
        
            if (UniqueByData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "UniqueByData>" + Util.ConvertValueTypeToString(UniqueByData, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "UniqueByData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDeDuplication>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDeDuplication</returns>
        public new static PARAM_ThingMagicDeDuplication  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDeDuplication param = new PARAM_ThingMagicDeDuplication();
    
            val = XmlUtil.GetNodeValue(node, "RecordHighestRSSI");
        
            param.RecordHighestRSSI = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "UniqueByAntenna");
        
            param.UniqueByAntenna = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "UniqueByData");
        
            param.UniqueByData = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic De Duplication related fields 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_DeviceProtocolCapabilities : PARAM_Custom,IGET_READER_CAPABILITIES_RESPONSE_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_DeviceProtocolCapabilities()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 11;
        }
      
        public PARAM_SupportedProtocols[] SupportedProtocols;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IDeviceProtocolCapabilities_Custom_Param custom =
                param as IDeviceProtocolCapabilities_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (SupportedProtocols != null)
            {
        
                len = SupportedProtocols.Length;
                for (int i=0; i<len;i++)
                {
                    SupportedProtocols[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_DeviceProtocolCapabilities</returns>
        public new static PARAM_DeviceProtocolCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_DeviceProtocolCapabilities obj = new PARAM_DeviceProtocolCapabilities();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            param_list = new ArrayList();
            PARAM_SupportedProtocols _param_SupportedProtocols;
            while ((_param_SupportedProtocols = PARAM_SupportedProtocols.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_SupportedProtocols);
            }

            if (param_list.Count > 0)
            {
                obj.SupportedProtocols = new PARAM_SupportedProtocols[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.SupportedProtocols[i] = (PARAM_SupportedProtocols)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"DeviceProtocolCapabilities";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (SupportedProtocols != null)
            {
          
                len = SupportedProtocols.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(SupportedProtocols[i].ToString());
                }
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":DeviceProtocolCapabilities>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_DeviceProtocolCapabilities</returns>
        public new static PARAM_DeviceProtocolCapabilities  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_DeviceProtocolCapabilities param = new PARAM_DeviceProtocolCapabilities();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "SupportedProtocols", nsmgr);
            if (xnl.Count != 0)
            {
                param.SupportedProtocols = new PARAM_SupportedProtocols[xnl.Count];
                for (int i=0; i<xnl.Count; i++)
                {
                    param.SupportedProtocols[i] = PARAM_SupportedProtocols.FromXmlNode(xnl[i]);
                }
            }
              
            }
      
            {
        
            string[] excl = new string[] { "SupportedProtocols",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic Module supported protocols information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_SupportedProtocols : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_SupportedProtocols()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 12;
        }
      
        public ENUM_ProtocolID Protocol;
        private Int16 Protocol_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ISupportedProtocols_Custom_Param custom =
                param as ISupportedProtocols_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Protocol != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Protocol, Protocol_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_SupportedProtocols</returns>
        public new static PARAM_SupportedProtocols FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_SupportedProtocols obj = new PARAM_SupportedProtocols();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Protocol = (ENUM_ProtocolID)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"SupportedProtocols";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Protocol != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>" + Protocol.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":SupportedProtocols>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_SupportedProtocols</returns>
        public new static PARAM_SupportedProtocols  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_SupportedProtocols param = new PARAM_SupportedProtocols();
    
            val = XmlUtil.GetNodeValue(node, "Protocol");
        
            param.Protocol = (ENUM_ProtocolID)Enum.Parse(typeof(ENUM_ProtocolID), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic Reader Module Temperature 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicReaderModuleTemperature : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicReaderModuleTemperature()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 13;
        }
      
        public byte ReaderModuleTemperature=0;
        private Int16 ReaderModuleTemperature_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicReaderModuleTemperature_Custom_Param custom =
                param as IThingMagicReaderModuleTemperature_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReaderModuleTemperature != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReaderModuleTemperature, ReaderModuleTemperature_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicReaderModuleTemperature</returns>
        public new static PARAM_ThingMagicReaderModuleTemperature FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicReaderModuleTemperature obj = new PARAM_ThingMagicReaderModuleTemperature();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ReaderModuleTemperature = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicReaderModuleTemperature";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReaderModuleTemperature != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderModuleTemperature>" + Util.ConvertValueTypeToString(ReaderModuleTemperature, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReaderModuleTemperature>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicReaderModuleTemperature>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicReaderModuleTemperature</returns>
        public new static PARAM_ThingMagicReaderModuleTemperature  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicReaderModuleTemperature param = new PARAM_ThingMagicReaderModuleTemperature();
    
            val = XmlUtil.GetNodeValue(node, "ReaderModuleTemperature");
        
            param.ReaderModuleTemperature = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Gen2 Q type and value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2Q : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2Q()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 14;
        }
      
        public ENUM_QType Gen2QType;
        private Int16 Gen2QType_len = 8;
        public byte InitQValue=0;
        private Int16 InitQValue_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2Q_Custom_Param custom =
                param as IGen2Q_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Gen2QType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Gen2QType, Gen2QType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (InitQValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(InitQValue, InitQValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2Q</returns>
        public new static PARAM_Gen2Q FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2Q obj = new PARAM_Gen2Q();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Gen2QType = (ENUM_QType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.InitQValue = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2Q";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Gen2QType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Gen2QType>" + Gen2QType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Gen2QType>";
            
	            xml_str += "\r\n";
	        }
        
            if (InitQValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "InitQValue>" + Util.ConvertValueTypeToString(InitQValue, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "InitQValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2Q>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2Q</returns>
        public new static PARAM_Gen2Q  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2Q param = new PARAM_Gen2Q();
    
            val = XmlUtil.GetNodeValue(node, "Gen2QType");
        
            param.Gen2QType = (ENUM_QType)Enum.Parse(typeof(ENUM_QType), val);
          
            val = XmlUtil.GetNodeValue(node, "InitQValue");
        
            param.InitQValue = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the InitQ value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_InitQ : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_InitQ()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 177;
        }
      
        public bool qEnable=false;
        private Int16 qEnable_len=0;
      
        private const UInt16 param_reserved_len3= 7;
        
        public PARAM_qValue qValue;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IInitQ_Custom_Param custom =
                param as IInitQ_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (qEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(qEnable, qEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (qValue != null)
            {
        qValue.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_InitQ</returns>
        public new static PARAM_InitQ FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_InitQ obj = new PARAM_InitQ();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.qEnable = (bool)obj_val;
          
            cursor += param_reserved_len3;
      
            obj.qValue = PARAM_qValue.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"InitQ";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (qEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "qEnable>" + Util.ConvertValueTypeToString(qEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "qEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (qValue != null)
            {
          
                xml_str += Util.Indent(qValue.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":InitQ>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_InitQ</returns>
        public new static PARAM_InitQ  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_InitQ param = new PARAM_InitQ();
    
            val = XmlUtil.GetNodeValue(node, "qEnable");
        
            param.qEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "qValue", nsmgr);
            if (xnl.Count != 0)
            {
                param.qValue = PARAM_qValue.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "qValue",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the InitQ value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_qValue : PARAM_Custom,IInitQ_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_qValue()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 180;
        }
      
        public byte value=0;
        private Int16 value_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IqValue_Custom_Param custom =
                param as IqValue_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (value != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(value, value_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_qValue</returns>
        public new static PARAM_qValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_qValue obj = new PARAM_qValue();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.value = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"qValue";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (value != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "value>" + Util.ConvertValueTypeToString(value, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "value>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":qValue>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_qValue</returns>
        public new static PARAM_qValue  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_qValue param = new PARAM_qValue();
    
            val = XmlUtil.GetNodeValue(node, "value");
        
            param.value = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the sendSelect value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_sendSelect : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_sendSelect()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 178;
        }
      
        public bool selectValue=false;
        private Int16 selectValue_len=0;
      
        private const UInt16 param_reserved_len3= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IsendSelect_Custom_Param custom =
                param as IsendSelect_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (selectValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(selectValue, selectValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_sendSelect</returns>
        public new static PARAM_sendSelect FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_sendSelect obj = new PARAM_sendSelect();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.selectValue = (bool)obj_val;
          
            cursor += param_reserved_len3;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"sendSelect";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (selectValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "selectValue>" + Util.ConvertValueTypeToString(selectValue, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "selectValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":sendSelect>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_sendSelect</returns>
        public new static PARAM_sendSelect  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_sendSelect param = new PARAM_sendSelect();
    
            val = XmlUtil.GetNodeValue(node, "selectValue");
        
            param.selectValue = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Antenna Detection value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicAntennaDetection : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicAntennaDetection()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 15;
        }
      
        public bool AntennaDetection=false;
        private Int16 AntennaDetection_len=0;
      
        private const UInt16 param_reserved_len3= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicAntennaDetection_Custom_Param custom =
                param as IThingMagicAntennaDetection_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AntennaDetection != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaDetection, AntennaDetection_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicAntennaDetection</returns>
        public new static PARAM_ThingMagicAntennaDetection FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicAntennaDetection obj = new PARAM_ThingMagicAntennaDetection();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.AntennaDetection = (bool)obj_val;
          
            cursor += param_reserved_len3;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicAntennaDetection";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AntennaDetection != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaDetection>" + Util.ConvertValueTypeToString(AntennaDetection, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AntennaDetection>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicAntennaDetection>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicAntennaDetection</returns>
        public new static PARAM_ThingMagicAntennaDetection  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicAntennaDetection param = new PARAM_ThingMagicAntennaDetection();
    
            val = XmlUtil.GetNodeValue(node, "AntennaDetection");
        
            param.AntennaDetection = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Custom Write Power 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_WriteTransmitPower : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_WriteTransmitPower()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 16;
        }
      
        public UInt16 WriteTransmitPower=0;
        private Int16 WriteTransmitPower_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IWriteTransmitPower_Custom_Param custom =
                param as IWriteTransmitPower_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (WriteTransmitPower != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WriteTransmitPower, WriteTransmitPower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_WriteTransmitPower</returns>
        public new static PARAM_WriteTransmitPower FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_WriteTransmitPower obj = new PARAM_WriteTransmitPower();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.WriteTransmitPower = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"WriteTransmitPower";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (WriteTransmitPower != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteTransmitPower>" + Util.ConvertValueTypeToString(WriteTransmitPower, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "WriteTransmitPower>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":WriteTransmitPower>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_WriteTransmitPower</returns>
        public new static PARAM_WriteTransmitPower  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_WriteTransmitPower param = new PARAM_WriteTransmitPower();
    
            val = XmlUtil.GetNodeValue(node, "WriteTransmitPower");
        
            param.WriteTransmitPower = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom Antenna Read point Description 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ReadPointDescription : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ReadPointDescription()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 17;
        }
      
        public string ReadPointDescription=string.Empty;
        private Int16 ReadPointDescription_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IReadPointDescription_Custom_Param custom =
                param as IReadPointDescription_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReadPointDescription != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReadPointDescription.Length), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReadPointDescription, ReadPointDescription_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ReadPointDescription</returns>
        public new static PARAM_ReadPointDescription FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReadPointDescription obj = new PARAM_ReadPointDescription();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            obj.ReadPointDescription = (string)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ReadPointDescription";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReadPointDescription != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadPointDescription>" + Util.ConvertArrayTypeToString(ReadPointDescription, "utf8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadPointDescription>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ReadPointDescription>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ReadPointDescription</returns>
        public new static PARAM_ReadPointDescription  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ReadPointDescription param = new PARAM_ReadPointDescription();
    
            val = XmlUtil.GetNodeValue(node, "ReadPointDescription");
        
            param.ReadPointDescription = (string)(Util.ParseArrayTypeFromString(val, "utf8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom Antenna Mode 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_AntennaMode : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_AntennaMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 18;
        }
      
        public ENUM_ThingMagicAntennaMode AntennaMode;
        private Int16 AntennaMode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IAntennaMode_Custom_Param custom =
                param as IAntennaMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AntennaMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaMode, AntennaMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_AntennaMode</returns>
        public new static PARAM_AntennaMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaMode obj = new PARAM_AntennaMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AntennaMode = (ENUM_ThingMagicAntennaMode)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"AntennaMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AntennaMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaMode>" + AntennaMode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":AntennaMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_AntennaMode</returns>
        public new static PARAM_AntennaMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_AntennaMode param = new PARAM_AntennaMode();
    
            val = XmlUtil.GetNodeValue(node, "AntennaMode");
        
            param.AntennaMode = (ENUM_ThingMagicAntennaMode)Enum.Parse(typeof(ENUM_ThingMagicAntennaMode), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom C1G2 Target parameter 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicTargetStrategy : PARAM_Custom,IGen2CustomParameters_Custom_Param,IC1G2InventoryCommand_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicTargetStrategy()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 19;
        }
      
        public ENUM_ThingMagicC1G2TargetStrategy ThingMagicTargetStrategyValue;
        private Int16 ThingMagicTargetStrategyValue_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicTargetStrategy_Custom_Param custom =
                param as IThingMagicTargetStrategy_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicTargetStrategyValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ThingMagicTargetStrategyValue, ThingMagicTargetStrategyValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicTargetStrategy</returns>
        public new static PARAM_ThingMagicTargetStrategy FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicTargetStrategy obj = new PARAM_ThingMagicTargetStrategy();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ThingMagicTargetStrategyValue = (ENUM_ThingMagicC1G2TargetStrategy)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicTargetStrategy";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicTargetStrategyValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ThingMagicTargetStrategyValue>" + ThingMagicTargetStrategyValue.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ThingMagicTargetStrategyValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicTargetStrategy>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicTargetStrategy</returns>
        public new static PARAM_ThingMagicTargetStrategy  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicTargetStrategy param = new PARAM_ThingMagicTargetStrategy();
    
            val = XmlUtil.GetNodeValue(node, "ThingMagicTargetStrategyValue");
        
            param.ThingMagicTargetStrategyValue = (ENUM_ThingMagicC1G2TargetStrategy)Enum.Parse(typeof(ENUM_ThingMagicC1G2TargetStrategy), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom Gen2 T4 parameter 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2T4Param : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2T4Param()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 162;
        }
      
        public UInt32 T4ParamValue=0;
        private Int16 T4ParamValue_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2T4Param_Custom_Param custom =
                param as IGen2T4Param_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (T4ParamValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(T4ParamValue, T4ParamValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2T4Param</returns>
        public new static PARAM_Gen2T4Param FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2T4Param obj = new PARAM_Gen2T4Param();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.T4ParamValue = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2T4Param";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (T4ParamValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "T4ParamValue>" + Util.ConvertValueTypeToString(T4ParamValue, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "T4ParamValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2T4Param>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2T4Param</returns>
        public new static PARAM_Gen2T4Param  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2T4Param param = new PARAM_Gen2T4Param();
    
            val = XmlUtil.GetNodeValue(node, "T4ParamValue");
        
            param.T4ParamValue = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic License key parameter 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicLicenseKey : PARAM_Custom,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicLicenseKey()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 20;
        }
      
        public ByteArray LicenseKey=new ByteArray();
        private Int16 LicenseKey_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicLicenseKey_Custom_Param custom =
                param as IThingMagicLicenseKey_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (LicenseKey != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(LicenseKey.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(LicenseKey, LicenseKey_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicLicenseKey</returns>
        public new static PARAM_ThingMagicLicenseKey FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicLicenseKey obj = new PARAM_ThingMagicLicenseKey();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.LicenseKey = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicLicenseKey";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (LicenseKey != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LicenseKey>" + Util.ConvertArrayTypeToString(LicenseKey, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LicenseKey>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicLicenseKey>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicLicenseKey</returns>
        public new static PARAM_ThingMagicLicenseKey  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicLicenseKey param = new PARAM_ThingMagicLicenseKey();
    
            val = XmlUtil.GetNodeValue(node, "LicenseKey");
        
            param.LicenseKey = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. ReadLock field determines whether to read the status or PermaLock the blocks specified. [if ReadLock=0, Return the PermaLock status of blocks specified. if ReadLock=1, PermaLock the blocks specified]. MB is the Memory bank whos blocks will be locked. BlockPointer is the starting address for mask. BlockMask is the range of blocks to lock.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicBlockPermalock : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicBlockPermalock()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 21;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public byte ReadLock=0;
        private Int16 ReadLock_len=0;
      
        public TwoBits MB=new TwoBits(0);
        private Int16 MB_len=0;
      
        private const UInt16 param_reserved_len6= 6;
        
        public UInt32 BlockPointer=0;
        private Int16 BlockPointer_len=0;
      
        public UInt16Array BlockMask=new UInt16Array();
        private Int16 BlockMask_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicBlockPermalock_Custom_Param custom =
                param as IThingMagicBlockPermalock_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadLock != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadLock, ReadLock_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (MB != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len6;
      
            if (BlockPointer != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BlockPointer, BlockPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (BlockMask != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(BlockMask.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(BlockMask, BlockMask_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicBlockPermalock</returns>
        public new static PARAM_ThingMagicBlockPermalock FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicBlockPermalock obj = new PARAM_ThingMagicBlockPermalock();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ReadLock = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 2;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            obj.MB = (TwoBits)obj_val;
          
            cursor += param_reserved_len6;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.BlockPointer = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            obj.BlockMask = (UInt16Array)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicBlockPermalock";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadLock != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadLock>" + Util.ConvertValueTypeToString(ReadLock, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadLock>";
            
	            xml_str += "\r\n";
	        }
        
            if (MB != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MB>" + MB.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MB>";
            
	            xml_str += "\r\n";
	        }
        
            if (BlockPointer != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BlockPointer>" + Util.ConvertValueTypeToString(BlockPointer, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "BlockPointer>";
            
	            xml_str += "\r\n";
	        }
        
            if (BlockMask != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BlockMask>" + Util.ConvertArrayTypeToString(BlockMask, "u16v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BlockMask>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicBlockPermalock>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicBlockPermalock</returns>
        public new static PARAM_ThingMagicBlockPermalock  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicBlockPermalock param = new PARAM_ThingMagicBlockPermalock();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadLock");
        
            param.ReadLock = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "MB");
        
            param.MB = TwoBits.FromString(val);
          
            val = XmlUtil.GetNodeValue(node, "BlockPointer");
        
            param.BlockPointer = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "BlockMask");
        
            param.BlockMask = (UInt16Array)(Util.ParseArrayTypeFromString(val, "u16v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicBlockPermalock OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicBlockPermalockOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicBlockPermalockOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 22;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16Array PermalockStatus=new UInt16Array();
        private Int16 PermalockStatus_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicBlockPermalockOpSpecResult_Custom_Param custom =
                param as IThingMagicBlockPermalockOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PermalockStatus != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(PermalockStatus.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(PermalockStatus, PermalockStatus_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicBlockPermalockOpSpecResult</returns>
        public new static PARAM_ThingMagicBlockPermalockOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicBlockPermalockOpSpecResult obj = new PARAM_ThingMagicBlockPermalockOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            obj.PermalockStatus = (UInt16Array)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicBlockPermalockOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (PermalockStatus != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PermalockStatus>" + Util.ConvertArrayTypeToString(PermalockStatus, "u16v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PermalockStatus>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicBlockPermalockOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicBlockPermalockOpSpecResult</returns>
        public new static PARAM_ThingMagicBlockPermalockOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicBlockPermalockOpSpecResult param = new PARAM_ThingMagicBlockPermalockOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "PermalockStatus");
        
            param.PermalockStatus = (UInt16Array)(Util.ParseArrayTypeFromString(val, "u16v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The CurrentAccessPassword field is the password used by the Reader to transition the tag to the secure state. KillPassword is the kill password to write on the tag. AccessPassword is the access password to write on the tag. EPCData is the tag EPC to write to the tag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs2PartialLoadImage : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs2PartialLoadImage()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 23;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 CurrentAccessPassword=0;
        private Int16 CurrentAccessPassword_len=0;
      
        public UInt32 KillPassword=0;
        private Int16 KillPassword_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public ByteArray EPCData=new ByteArray();
        private Int16 EPCData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs2PartialLoadImage_Custom_Param custom =
                param as IThingMagicHiggs2PartialLoadImage_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CurrentAccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentAccessPassword, CurrentAccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillPassword, KillPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EPCData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPCData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPCData, EPCData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs2PartialLoadImage</returns>
        public new static PARAM_ThingMagicHiggs2PartialLoadImage FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs2PartialLoadImage obj = new PARAM_ThingMagicHiggs2PartialLoadImage();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.CurrentAccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EPCData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs2PartialLoadImage";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CurrentAccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CurrentAccessPassword>" + Util.ConvertValueTypeToString(CurrentAccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CurrentAccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (KillPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillPassword>" + Util.ConvertValueTypeToString(KillPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "KillPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (EPCData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>" + Util.ConvertArrayTypeToString(EPCData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs2PartialLoadImage>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs2PartialLoadImage</returns>
        public new static PARAM_ThingMagicHiggs2PartialLoadImage  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs2PartialLoadImage param = new PARAM_ThingMagicHiggs2PartialLoadImage();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CurrentAccessPassword");
        
            param.CurrentAccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "KillPassword");
        
            param.KillPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "EPCData");
        
            param.EPCData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicHiggs2PartialLoadImage OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 24;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs2PartialLoadImageOpSpecResult_Custom_Param custom =
                param as IThingMagicHiggs2PartialLoadImageOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult obj = new PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs2PartialLoadImageOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs2PartialLoadImageOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult param = new PARAM_ThingMagicHiggs2PartialLoadImageOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The CurrentAccessPassword field is the password used by the Reader to transition the tag to the secure state. KillPassword is the kill password to write on the tag. AccessPassword is the access password to write on the tag. LockBits specify the lock action on the tag according to Alien Higgs Lock Bits. PCWord is the tag's PC Bytes to be written on the tag. EPCData is the tag EPC to write to the tag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs2FullLoadImage : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs2FullLoadImage()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 25;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 CurrentAccessPassword=0;
        private Int16 CurrentAccessPassword_len=0;
      
        public UInt32 KillPassword=0;
        private Int16 KillPassword_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public UInt16 LockBits=0;
        private Int16 LockBits_len=0;
      
        public UInt16 PCWord=0;
        private Int16 PCWord_len=0;
      
        public ByteArray EPCData=new ByteArray();
        private Int16 EPCData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs2FullLoadImage_Custom_Param custom =
                param as IThingMagicHiggs2FullLoadImage_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CurrentAccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentAccessPassword, CurrentAccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillPassword, KillPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LockBits != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LockBits, LockBits_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PCWord != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PCWord, PCWord_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EPCData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPCData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPCData, EPCData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs2FullLoadImage</returns>
        public new static PARAM_ThingMagicHiggs2FullLoadImage FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs2FullLoadImage obj = new PARAM_ThingMagicHiggs2FullLoadImage();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.CurrentAccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.LockBits = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.PCWord = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EPCData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs2FullLoadImage";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CurrentAccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CurrentAccessPassword>" + Util.ConvertValueTypeToString(CurrentAccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CurrentAccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (KillPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillPassword>" + Util.ConvertValueTypeToString(KillPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "KillPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (LockBits != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockBits>" + Util.ConvertValueTypeToString(LockBits, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "LockBits>";
            
	            xml_str += "\r\n";
	        }
        
            if (PCWord != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PCWord>" + Util.ConvertValueTypeToString(PCWord, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PCWord>";
            
	            xml_str += "\r\n";
	        }
        
            if (EPCData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>" + Util.ConvertArrayTypeToString(EPCData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs2FullLoadImage>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs2FullLoadImage</returns>
        public new static PARAM_ThingMagicHiggs2FullLoadImage  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs2FullLoadImage param = new PARAM_ThingMagicHiggs2FullLoadImage();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CurrentAccessPassword");
        
            param.CurrentAccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "KillPassword");
        
            param.KillPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "LockBits");
        
            param.LockBits = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "PCWord");
        
            param.PCWord = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "EPCData");
        
            param.EPCData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicHiggs2FullLoadImage OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 26;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs2FullLoadImageOpSpecResult_Custom_Param custom =
                param as IThingMagicHiggs2FullLoadImageOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult obj = new PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs2FullLoadImageOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs2FullLoadImageOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult param = new PARAM_ThingMagicHiggs2FullLoadImageOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The CurrentAccessPassword field is the password used by the Reader to transition the tag to the secure state. KillPassword is the kill password to write on the tag. AccessPassword is the access password to write on the tag. PCWord is the tag's PC Bytes to be written on the tag. EPCData is the tag EPC to write to the tag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3FastLoadImage : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3FastLoadImage()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 27;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 CurrentAccessPassword=0;
        private Int16 CurrentAccessPassword_len=0;
      
        public UInt32 KillPassword=0;
        private Int16 KillPassword_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public UInt16 PCWord=0;
        private Int16 PCWord_len=0;
      
        public ByteArray EPCData=new ByteArray();
        private Int16 EPCData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3FastLoadImage_Custom_Param custom =
                param as IThingMagicHiggs3FastLoadImage_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CurrentAccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentAccessPassword, CurrentAccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillPassword, KillPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PCWord != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PCWord, PCWord_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EPCData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPCData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPCData, EPCData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3FastLoadImage</returns>
        public new static PARAM_ThingMagicHiggs3FastLoadImage FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3FastLoadImage obj = new PARAM_ThingMagicHiggs3FastLoadImage();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.CurrentAccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.PCWord = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EPCData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3FastLoadImage";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CurrentAccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CurrentAccessPassword>" + Util.ConvertValueTypeToString(CurrentAccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CurrentAccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (KillPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillPassword>" + Util.ConvertValueTypeToString(KillPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "KillPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (PCWord != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PCWord>" + Util.ConvertValueTypeToString(PCWord, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PCWord>";
            
	            xml_str += "\r\n";
	        }
        
            if (EPCData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>" + Util.ConvertArrayTypeToString(EPCData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3FastLoadImage>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3FastLoadImage</returns>
        public new static PARAM_ThingMagicHiggs3FastLoadImage  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3FastLoadImage param = new PARAM_ThingMagicHiggs3FastLoadImage();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CurrentAccessPassword");
        
            param.CurrentAccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "KillPassword");
        
            param.KillPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "PCWord");
        
            param.PCWord = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "EPCData");
        
            param.EPCData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicHiggs3FastLoadImage OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 28;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3FastLoadImageOpSpecResult_Custom_Param custom =
                param as IThingMagicHiggs3FastLoadImageOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult obj = new PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3FastLoadImageOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3FastLoadImageOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult param = new PARAM_ThingMagicHiggs3FastLoadImageOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The CurrentAccessPassword field is the password used by the Reader to transition the tag to the secure state. KillPassword is the kill password to write on the tag. AccessPassword is the access password to write on the tag. PCWord is the tag's PC Bytes to be written on the tag. EPCAndUserData is the Tag EPC and user data to write to the tag (76 bytes)
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3LoadImage : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3LoadImage()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 29;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 CurrentAccessPassword=0;
        private Int16 CurrentAccessPassword_len=0;
      
        public UInt32 KillPassword=0;
        private Int16 KillPassword_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public UInt16 PCWord=0;
        private Int16 PCWord_len=0;
      
        public ByteArray EPCAndUserData=new ByteArray();
        private Int16 EPCAndUserData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3LoadImage_Custom_Param custom =
                param as IThingMagicHiggs3LoadImage_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CurrentAccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentAccessPassword, CurrentAccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillPassword, KillPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PCWord != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PCWord, PCWord_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EPCAndUserData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPCAndUserData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPCAndUserData, EPCAndUserData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3LoadImage</returns>
        public new static PARAM_ThingMagicHiggs3LoadImage FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3LoadImage obj = new PARAM_ThingMagicHiggs3LoadImage();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.CurrentAccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.PCWord = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EPCAndUserData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3LoadImage";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CurrentAccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CurrentAccessPassword>" + Util.ConvertValueTypeToString(CurrentAccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CurrentAccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (KillPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillPassword>" + Util.ConvertValueTypeToString(KillPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "KillPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (PCWord != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PCWord>" + Util.ConvertValueTypeToString(PCWord, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PCWord>";
            
	            xml_str += "\r\n";
	        }
        
            if (EPCAndUserData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCAndUserData>" + Util.ConvertArrayTypeToString(EPCAndUserData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EPCAndUserData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3LoadImage>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3LoadImage</returns>
        public new static PARAM_ThingMagicHiggs3LoadImage  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3LoadImage param = new PARAM_ThingMagicHiggs3LoadImage();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CurrentAccessPassword");
        
            param.CurrentAccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "KillPassword");
        
            param.KillPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "PCWord");
        
            param.PCWord = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "EPCAndUserData");
        
            param.EPCAndUserData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicHiggs3LoadImage OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3LoadImageOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3LoadImageOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 30;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3LoadImageOpSpecResult_Custom_Param custom =
                param as IThingMagicHiggs3LoadImageOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3LoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3LoadImageOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3LoadImageOpSpecResult obj = new PARAM_ThingMagicHiggs3LoadImageOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3LoadImageOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3LoadImageOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3LoadImageOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3LoadImageOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3LoadImageOpSpecResult param = new PARAM_ThingMagicHiggs3LoadImageOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. LockBits is a bitmask of bits to lock.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3BlockReadLock : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3BlockReadLock()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 31;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public byte LockBits=0;
        private Int16 LockBits_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3BlockReadLock_Custom_Param custom =
                param as IThingMagicHiggs3BlockReadLock_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LockBits != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LockBits, LockBits_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3BlockReadLock</returns>
        public new static PARAM_ThingMagicHiggs3BlockReadLock FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3BlockReadLock obj = new PARAM_ThingMagicHiggs3BlockReadLock();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.LockBits = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3BlockReadLock";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (LockBits != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockBits>" + Util.ConvertValueTypeToString(LockBits, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "LockBits>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3BlockReadLock>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3BlockReadLock</returns>
        public new static PARAM_ThingMagicHiggs3BlockReadLock  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3BlockReadLock param = new PARAM_ThingMagicHiggs3BlockReadLock();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "LockBits");
        
            param.LockBits = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicHiggs3BlockReadLock OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 32;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHiggs3BlockReadLockOpSpecResult_Custom_Param custom =
                param as IThingMagicHiggs3BlockReadLockOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult obj = new PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHiggs3BlockReadLockOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHiggs3BlockReadLockOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult</returns>
        public new static PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult param = new PARAM_ThingMagicHiggs3BlockReadLockOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2ISetReadProtect : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2ISetReadProtect()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 33;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2ISetReadProtect_Custom_Param custom =
                param as IThingMagicNXPG2ISetReadProtect_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2ISetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2ISetReadProtect FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2ISetReadProtect obj = new PARAM_ThingMagicNXPG2ISetReadProtect();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2ISetReadProtect";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2ISetReadProtect>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2ISetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2ISetReadProtect  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2ISetReadProtect param = new PARAM_ThingMagicNXPG2ISetReadProtect();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2ISetReadProtect OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 34;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2ISetReadProtectOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2ISetReadProtectOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult obj = new PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2ISetReadProtectOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2ISetReadProtectOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult param = new PARAM_ThingMagicNXPG2ISetReadProtectOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XSetReadProtect : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XSetReadProtect()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 35;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XSetReadProtect_Custom_Param custom =
                param as IThingMagicNXPG2XSetReadProtect_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XSetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2XSetReadProtect FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XSetReadProtect obj = new PARAM_ThingMagicNXPG2XSetReadProtect();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XSetReadProtect";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XSetReadProtect>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XSetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2XSetReadProtect  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XSetReadProtect param = new PARAM_ThingMagicNXPG2XSetReadProtect();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2XSetReadProtect OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 36;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XSetReadProtectOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2XSetReadProtectOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult obj = new PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XSetReadProtectOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XSetReadProtectOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult param = new PARAM_ThingMagicNXPG2XSetReadProtectOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IResetReadProtect : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IResetReadProtect()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 37;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IResetReadProtect_Custom_Param custom =
                param as IThingMagicNXPG2IResetReadProtect_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IResetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2IResetReadProtect FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IResetReadProtect obj = new PARAM_ThingMagicNXPG2IResetReadProtect();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IResetReadProtect";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IResetReadProtect>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IResetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2IResetReadProtect  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IResetReadProtect param = new PARAM_ThingMagicNXPG2IResetReadProtect();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2IResetReadProtect OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 38;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IResetReadProtectOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2IResetReadProtectOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult obj = new PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IResetReadProtectOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IResetReadProtectOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult param = new PARAM_ThingMagicNXPG2IResetReadProtectOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XResetReadProtect : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XResetReadProtect()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 39;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XResetReadProtect_Custom_Param custom =
                param as IThingMagicNXPG2XResetReadProtect_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XResetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2XResetReadProtect FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XResetReadProtect obj = new PARAM_ThingMagicNXPG2XResetReadProtect();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XResetReadProtect";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XResetReadProtect>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XResetReadProtect</returns>
        public new static PARAM_ThingMagicNXPG2XResetReadProtect  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XResetReadProtect param = new PARAM_ThingMagicNXPG2XResetReadProtect();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2XResetReadProtect OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 40;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XResetReadProtectOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2XResetReadProtectOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult obj = new PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XResetReadProtectOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XResetReadProtectOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult param = new PARAM_ThingMagicNXPG2XResetReadProtectOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. Reset is a boolean value. If true, reset the EAS flag on the chosen tags, otherwise set the EAS flag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IChangeEAS : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IChangeEAS()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 41;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public bool Reset=false;
        private Int16 Reset_len=0;
      
        private const UInt16 param_reserved_len5= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IChangeEAS_Custom_Param custom =
                param as IThingMagicNXPG2IChangeEAS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Reset != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Reset, Reset_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeEAS</returns>
        public new static PARAM_ThingMagicNXPG2IChangeEAS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IChangeEAS obj = new PARAM_ThingMagicNXPG2IChangeEAS();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Reset = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IChangeEAS";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Reset != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Reset>" + Util.ConvertValueTypeToString(Reset, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Reset>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IChangeEAS>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeEAS</returns>
        public new static PARAM_ThingMagicNXPG2IChangeEAS  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IChangeEAS param = new PARAM_ThingMagicNXPG2IChangeEAS();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "Reset");
        
            param.Reset = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2IChangeEAS OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IChangeEASOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IChangeEASOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 42;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IChangeEASOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2IChangeEASOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeEASOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IChangeEASOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IChangeEASOpSpecResult obj = new PARAM_ThingMagicNXPG2IChangeEASOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IChangeEASOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IChangeEASOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeEASOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IChangeEASOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IChangeEASOpSpecResult param = new PARAM_ThingMagicNXPG2IChangeEASOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. Reset is a boolean value. If true, reset the EAS flag on the chosen tags, otherwise set the EAS flag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XChangeEAS : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XChangeEAS()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 43;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public bool Reset=false;
        private Int16 Reset_len=0;
      
        private const UInt16 param_reserved_len5= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XChangeEAS_Custom_Param custom =
                param as IThingMagicNXPG2XChangeEAS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Reset != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Reset, Reset_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XChangeEAS</returns>
        public new static PARAM_ThingMagicNXPG2XChangeEAS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XChangeEAS obj = new PARAM_ThingMagicNXPG2XChangeEAS();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Reset = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XChangeEAS";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Reset != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Reset>" + Util.ConvertValueTypeToString(Reset, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Reset>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XChangeEAS>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XChangeEAS</returns>
        public new static PARAM_ThingMagicNXPG2XChangeEAS  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XChangeEAS param = new PARAM_ThingMagicNXPG2XChangeEAS();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "Reset");
        
            param.Reset = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2XChangeEAS OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XChangeEASOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XChangeEASOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 44;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XChangeEASOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2XChangeEASOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XChangeEASOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XChangeEASOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XChangeEASOpSpecResult obj = new PARAM_ThingMagicNXPG2XChangeEASOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XChangeEASOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XChangeEASOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XChangeEASOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XChangeEASOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XChangeEASOpSpecResult param = new PARAM_ThingMagicNXPG2XChangeEASOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. DivideRatio specifies the Divide Ratio as per Gen2 (DR). TagEncoding specifies Gen2 M value. PilotTone is a boolean parameter. if true, there is a pilot tone in tag response otherwise no pilot tone.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IEASAlarm : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IEASAlarm()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 45;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public ENUM_ThingMagicGen2DivideRatio DivideRatio;
        private Int16 DivideRatio_len = 8;
        public ENUM_ThingMagicGen2TagEncoding TagEncoding;
        private Int16 TagEncoding_len = 8;
        public bool PilotTone=false;
        private Int16 PilotTone_len=0;
      
        private const UInt16 param_reserved_len7= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IEASAlarm_Custom_Param custom =
                param as IThingMagicNXPG2IEASAlarm_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (DivideRatio != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DivideRatio, DivideRatio_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagEncoding != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagEncoding, TagEncoding_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PilotTone != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PilotTone, PilotTone_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IEASAlarm</returns>
        public new static PARAM_ThingMagicNXPG2IEASAlarm FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IEASAlarm obj = new PARAM_ThingMagicNXPG2IEASAlarm();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.DivideRatio = (ENUM_ThingMagicGen2DivideRatio)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.TagEncoding = (ENUM_ThingMagicGen2TagEncoding)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.PilotTone = (bool)obj_val;
          
            cursor += param_reserved_len7;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IEASAlarm";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (DivideRatio != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DivideRatio>" + DivideRatio.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DivideRatio>";
            
	            xml_str += "\r\n";
	        }
        
            if (TagEncoding != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagEncoding>" + TagEncoding.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagEncoding>";
            
	            xml_str += "\r\n";
	        }
        
            if (PilotTone != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PilotTone>" + Util.ConvertValueTypeToString(PilotTone, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PilotTone>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IEASAlarm>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IEASAlarm</returns>
        public new static PARAM_ThingMagicNXPG2IEASAlarm  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IEASAlarm param = new PARAM_ThingMagicNXPG2IEASAlarm();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "DivideRatio");
        
            param.DivideRatio = (ENUM_ThingMagicGen2DivideRatio)Enum.Parse(typeof(ENUM_ThingMagicGen2DivideRatio), val);
          
            val = XmlUtil.GetNodeValue(node, "TagEncoding");
        
            param.TagEncoding = (ENUM_ThingMagicGen2TagEncoding)Enum.Parse(typeof(ENUM_ThingMagicGen2TagEncoding), val);
          
            val = XmlUtil.GetNodeValue(node, "PilotTone");
        
            param.PilotTone = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2IEASAlarm OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 46;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray EASAlarmCode=new ByteArray();
        private Int16 EASAlarmCode_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IEASAlarmOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2IEASAlarmOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EASAlarmCode != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EASAlarmCode.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EASAlarmCode, EASAlarmCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult obj = new PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EASAlarmCode = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IEASAlarmOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (EASAlarmCode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EASAlarmCode>" + Util.ConvertArrayTypeToString(EASAlarmCode, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EASAlarmCode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IEASAlarmOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult param = new PARAM_ThingMagicNXPG2IEASAlarmOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "EASAlarmCode");
        
            param.EASAlarmCode = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. DivideRatio specifies the Divide Ratio as per Gen2 (DR). TagEncoding specifies Gen2 M value. PilotTone is a boolean parameter. if true, there is a pilot tone in tag response otherwise no pilot tone.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XEASAlarm : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XEASAlarm()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 47;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public ENUM_ThingMagicGen2DivideRatio DivideRatio;
        private Int16 DivideRatio_len = 8;
        public ENUM_ThingMagicGen2TagEncoding TagEncoding;
        private Int16 TagEncoding_len = 8;
        public bool PilotTone=false;
        private Int16 PilotTone_len=0;
      
        private const UInt16 param_reserved_len7= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XEASAlarm_Custom_Param custom =
                param as IThingMagicNXPG2XEASAlarm_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (DivideRatio != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DivideRatio, DivideRatio_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagEncoding != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagEncoding, TagEncoding_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PilotTone != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PilotTone, PilotTone_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XEASAlarm</returns>
        public new static PARAM_ThingMagicNXPG2XEASAlarm FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XEASAlarm obj = new PARAM_ThingMagicNXPG2XEASAlarm();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.DivideRatio = (ENUM_ThingMagicGen2DivideRatio)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.TagEncoding = (ENUM_ThingMagicGen2TagEncoding)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.PilotTone = (bool)obj_val;
          
            cursor += param_reserved_len7;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XEASAlarm";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (DivideRatio != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DivideRatio>" + DivideRatio.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DivideRatio>";
            
	            xml_str += "\r\n";
	        }
        
            if (TagEncoding != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagEncoding>" + TagEncoding.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagEncoding>";
            
	            xml_str += "\r\n";
	        }
        
            if (PilotTone != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PilotTone>" + Util.ConvertValueTypeToString(PilotTone, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PilotTone>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XEASAlarm>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XEASAlarm</returns>
        public new static PARAM_ThingMagicNXPG2XEASAlarm  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XEASAlarm param = new PARAM_ThingMagicNXPG2XEASAlarm();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "DivideRatio");
        
            param.DivideRatio = (ENUM_ThingMagicGen2DivideRatio)Enum.Parse(typeof(ENUM_ThingMagicGen2DivideRatio), val);
          
            val = XmlUtil.GetNodeValue(node, "TagEncoding");
        
            param.TagEncoding = (ENUM_ThingMagicGen2TagEncoding)Enum.Parse(typeof(ENUM_ThingMagicGen2TagEncoding), val);
          
            val = XmlUtil.GetNodeValue(node, "PilotTone");
        
            param.PilotTone = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2XEASAlarm OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 48;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray EASAlarmCode=new ByteArray();
        private Int16 EASAlarmCode_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XEASAlarmOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2XEASAlarmOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EASAlarmCode != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EASAlarmCode.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EASAlarmCode, EASAlarmCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult obj = new PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.EASAlarmCode = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XEASAlarmOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (EASAlarmCode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EASAlarmCode>" + Util.ConvertArrayTypeToString(EASAlarmCode, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EASAlarmCode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XEASAlarmOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult param = new PARAM_ThingMagicNXPG2XEASAlarmOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "EASAlarmCode");
        
            param.EASAlarmCode = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2ICalibrate : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2ICalibrate()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 49;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2ICalibrate_Custom_Param custom =
                param as IThingMagicNXPG2ICalibrate_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2ICalibrate</returns>
        public new static PARAM_ThingMagicNXPG2ICalibrate FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2ICalibrate obj = new PARAM_ThingMagicNXPG2ICalibrate();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2ICalibrate";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2ICalibrate>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2ICalibrate</returns>
        public new static PARAM_ThingMagicNXPG2ICalibrate  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2ICalibrate param = new PARAM_ThingMagicNXPG2ICalibrate();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2ICalibrate OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2ICalibrateOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2ICalibrateOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 50;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray CalibrateData=new ByteArray();
        private Int16 CalibrateData_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2ICalibrateOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2ICalibrateOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CalibrateData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(CalibrateData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(CalibrateData, CalibrateData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2ICalibrateOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2ICalibrateOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2ICalibrateOpSpecResult obj = new PARAM_ThingMagicNXPG2ICalibrateOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.CalibrateData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2ICalibrateOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CalibrateData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CalibrateData>" + Util.ConvertArrayTypeToString(CalibrateData, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CalibrateData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2ICalibrateOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2ICalibrateOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2ICalibrateOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2ICalibrateOpSpecResult param = new PARAM_ThingMagicNXPG2ICalibrateOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CalibrateData");
        
            param.CalibrateData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XCalibrate : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XCalibrate()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 51;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XCalibrate_Custom_Param custom =
                param as IThingMagicNXPG2XCalibrate_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XCalibrate</returns>
        public new static PARAM_ThingMagicNXPG2XCalibrate FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XCalibrate obj = new PARAM_ThingMagicNXPG2XCalibrate();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XCalibrate";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XCalibrate>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XCalibrate</returns>
        public new static PARAM_ThingMagicNXPG2XCalibrate  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XCalibrate param = new PARAM_ThingMagicNXPG2XCalibrate();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2XCalibrate OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2XCalibrateOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2XCalibrateOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 52;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray CalibrateData=new ByteArray();
        private Int16 CalibrateData_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2XCalibrateOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2XCalibrateOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CalibrateData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(CalibrateData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(CalibrateData, CalibrateData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2XCalibrateOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XCalibrateOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2XCalibrateOpSpecResult obj = new PARAM_ThingMagicNXPG2XCalibrateOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.CalibrateData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2XCalibrateOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (CalibrateData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CalibrateData>" + Util.ConvertArrayTypeToString(CalibrateData, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CalibrateData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2XCalibrateOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2XCalibrateOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2XCalibrateOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2XCalibrateOpSpecResult param = new PARAM_ThingMagicNXPG2XCalibrateOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "CalibrateData");
        
            param.CalibrateData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. ThingMagicNXPConfigWord defines the configword to write on the tag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IChangeConfig : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IChangeConfig()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 53;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public PARAM_ThingMagicNXPConfigWord ThingMagicNXPConfigWord;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IChangeConfig_Custom_Param custom =
                param as IThingMagicNXPG2IChangeConfig_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPConfigWord != null)
            {
        ThingMagicNXPConfigWord.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeConfig</returns>
        public new static PARAM_ThingMagicNXPG2IChangeConfig FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IChangeConfig obj = new PARAM_ThingMagicNXPG2IChangeConfig();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            obj.ThingMagicNXPConfigWord = PARAM_ThingMagicNXPConfigWord.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IChangeConfig";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPConfigWord != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPConfigWord.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IChangeConfig>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeConfig</returns>
        public new static PARAM_ThingMagicNXPG2IChangeConfig  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IChangeConfig param = new PARAM_ThingMagicNXPG2IChangeConfig();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPConfigWord", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPConfigWord = PARAM_ThingMagicNXPConfigWord.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPConfigWord",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicNXPG2IChangeConfig OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 54;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 ConfigData=0;
        private Int16 ConfigData_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPG2IChangeConfigOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPG2IChangeConfigOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ConfigData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ConfigData, ConfigData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult obj = new PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.ConfigData = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPG2IChangeConfigOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ConfigData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ConfigData>" + Util.ConvertValueTypeToString(ConfigData, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ConfigData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPG2IChangeConfigOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult param = new PARAM_ThingMagicNXPG2IChangeConfigOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ConfigData");
        
            param.ConfigData = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the config word to write on NXP G2IL tags. Each field here represents the single bit in config word.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPConfigWord : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPConfigWord()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 55;
        }
      
        public bool PSFAlarm=false;
        private Int16 PSFAlarm_len=0;
      
        public bool ReadProtectTID=false;
        private Int16 ReadProtectTID_len=0;
      
        public bool ReadProtectEPC=false;
        private Int16 ReadProtectEPC_len=0;
      
        public bool ReadProtectUser=false;
        private Int16 ReadProtectUser_len=0;
      
        public bool PrivacyMode=false;
        private Int16 PrivacyMode_len=0;
      
        public bool DigitalOutput=false;
        private Int16 DigitalOutput_len=0;
      
        public bool MaxBackscatterStrength=false;
        private Int16 MaxBackscatterStrength_len=0;
      
        public bool ConditionalReadRangeReduction_OpenShort=false;
        private Int16 ConditionalReadRangeReduction_OpenShort_len=0;
      
        public bool ConditionalReadRangeReduction_OnOff=false;
        private Int16 ConditionalReadRangeReduction_OnOff_len=0;
      
        public bool DataMode=false;
        private Int16 DataMode_len=0;
      
        public bool TransparentMode=false;
        private Int16 TransparentMode_len=0;
      
        public bool InvertDigitalOutput=false;
        private Int16 InvertDigitalOutput_len=0;
      
        public bool ExternalSupply=false;
        private Int16 ExternalSupply_len=0;
      
        public bool TamperAlarm=false;
        private Int16 TamperAlarm_len=0;
      
        private const UInt16 param_reserved_len16= 2;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPConfigWord_Custom_Param custom =
                param as IThingMagicNXPConfigWord_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (PSFAlarm != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PSFAlarm, PSFAlarm_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadProtectTID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadProtectTID, ReadProtectTID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadProtectEPC != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadProtectEPC, ReadProtectEPC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadProtectUser != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadProtectUser, ReadProtectUser_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PrivacyMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PrivacyMode, PrivacyMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (DigitalOutput != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DigitalOutput, DigitalOutput_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (MaxBackscatterStrength != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxBackscatterStrength, MaxBackscatterStrength_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ConditionalReadRangeReduction_OpenShort != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ConditionalReadRangeReduction_OpenShort, ConditionalReadRangeReduction_OpenShort_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ConditionalReadRangeReduction_OnOff != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ConditionalReadRangeReduction_OnOff, ConditionalReadRangeReduction_OnOff_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (DataMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DataMode, DataMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TransparentMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TransparentMode, TransparentMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (InvertDigitalOutput != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(InvertDigitalOutput, InvertDigitalOutput_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ExternalSupply != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ExternalSupply, ExternalSupply_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TamperAlarm != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TamperAlarm, TamperAlarm_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len16;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPConfigWord</returns>
        public new static PARAM_ThingMagicNXPConfigWord FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPConfigWord obj = new PARAM_ThingMagicNXPConfigWord();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.PSFAlarm = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ReadProtectTID = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ReadProtectEPC = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ReadProtectUser = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.PrivacyMode = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.DigitalOutput = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.MaxBackscatterStrength = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ConditionalReadRangeReduction_OpenShort = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ConditionalReadRangeReduction_OnOff = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.DataMode = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.TransparentMode = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.InvertDigitalOutput = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ExternalSupply = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.TamperAlarm = (bool)obj_val;
          
            cursor += param_reserved_len16;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPConfigWord";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (PSFAlarm != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PSFAlarm>" + Util.ConvertValueTypeToString(PSFAlarm, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PSFAlarm>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadProtectTID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadProtectTID>" + Util.ConvertValueTypeToString(ReadProtectTID, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadProtectTID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadProtectEPC != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadProtectEPC>" + Util.ConvertValueTypeToString(ReadProtectEPC, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadProtectEPC>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadProtectUser != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadProtectUser>" + Util.ConvertValueTypeToString(ReadProtectUser, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadProtectUser>";
            
	            xml_str += "\r\n";
	        }
        
            if (PrivacyMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PrivacyMode>" + Util.ConvertValueTypeToString(PrivacyMode, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PrivacyMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (DigitalOutput != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DigitalOutput>" + Util.ConvertValueTypeToString(DigitalOutput, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "DigitalOutput>";
            
	            xml_str += "\r\n";
	        }
        
            if (MaxBackscatterStrength != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MaxBackscatterStrength>" + Util.ConvertValueTypeToString(MaxBackscatterStrength, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "MaxBackscatterStrength>";
            
	            xml_str += "\r\n";
	        }
        
            if (ConditionalReadRangeReduction_OpenShort != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ConditionalReadRangeReduction_OpenShort>" + Util.ConvertValueTypeToString(ConditionalReadRangeReduction_OpenShort, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ConditionalReadRangeReduction_OpenShort>";
            
	            xml_str += "\r\n";
	        }
        
            if (ConditionalReadRangeReduction_OnOff != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ConditionalReadRangeReduction_OnOff>" + Util.ConvertValueTypeToString(ConditionalReadRangeReduction_OnOff, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ConditionalReadRangeReduction_OnOff>";
            
	            xml_str += "\r\n";
	        }
        
            if (DataMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DataMode>" + Util.ConvertValueTypeToString(DataMode, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "DataMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (TransparentMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TransparentMode>" + Util.ConvertValueTypeToString(TransparentMode, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TransparentMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (InvertDigitalOutput != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "InvertDigitalOutput>" + Util.ConvertValueTypeToString(InvertDigitalOutput, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "InvertDigitalOutput>";
            
	            xml_str += "\r\n";
	        }
        
            if (ExternalSupply != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ExternalSupply>" + Util.ConvertValueTypeToString(ExternalSupply, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ExternalSupply>";
            
	            xml_str += "\r\n";
	        }
        
            if (TamperAlarm != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TamperAlarm>" + Util.ConvertValueTypeToString(TamperAlarm, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TamperAlarm>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPConfigWord>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPConfigWord</returns>
        public new static PARAM_ThingMagicNXPConfigWord  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPConfigWord param = new PARAM_ThingMagicNXPConfigWord();
    
            val = XmlUtil.GetNodeValue(node, "PSFAlarm");
        
            param.PSFAlarm = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadProtectTID");
        
            param.ReadProtectTID = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadProtectEPC");
        
            param.ReadProtectEPC = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadProtectUser");
        
            param.ReadProtectUser = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "PrivacyMode");
        
            param.PrivacyMode = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "DigitalOutput");
        
            param.DigitalOutput = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "MaxBackscatterStrength");
        
            param.MaxBackscatterStrength = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ConditionalReadRangeReduction_OpenShort");
        
            param.ConditionalReadRangeReduction_OpenShort = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ConditionalReadRangeReduction_OnOff");
        
            param.ConditionalReadRangeReduction_OnOff = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "DataMode");
        
            param.DataMode = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "TransparentMode");
        
            param.TransparentMode = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "InvertDigitalOutput");
        
            param.InvertDigitalOutput = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ExternalSupply");
        
            param.ExternalSupply = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "TamperAlarm");
        
            param.TamperAlarm = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicImpinjMonza4QTReadWrite : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicImpinjMonza4QTReadWrite()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 56;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public PARAM_ThingMagicMonza4ControlByte ThingMagicMonza4ControlByte;
                
        public PARAM_ThingMagicMonza4Payload ThingMagicMonza4Payload;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicImpinjMonza4QTReadWrite_Custom_Param custom =
                param as IThingMagicImpinjMonza4QTReadWrite_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicMonza4ControlByte != null)
            {
        ThingMagicMonza4ControlByte.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicMonza4Payload != null)
            {
        ThingMagicMonza4Payload.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicImpinjMonza4QTReadWrite</returns>
        public new static PARAM_ThingMagicImpinjMonza4QTReadWrite FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicImpinjMonza4QTReadWrite obj = new PARAM_ThingMagicImpinjMonza4QTReadWrite();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            obj.ThingMagicMonza4ControlByte = PARAM_ThingMagicMonza4ControlByte.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicMonza4Payload = PARAM_ThingMagicMonza4Payload.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicImpinjMonza4QTReadWrite";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicMonza4ControlByte != null)
            {
          
                xml_str += Util.Indent(ThingMagicMonza4ControlByte.ToString());
            
            }
        
            if (ThingMagicMonza4Payload != null)
            {
          
                xml_str += Util.Indent(ThingMagicMonza4Payload.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicImpinjMonza4QTReadWrite>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicImpinjMonza4QTReadWrite</returns>
        public new static PARAM_ThingMagicImpinjMonza4QTReadWrite  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicImpinjMonza4QTReadWrite param = new PARAM_ThingMagicImpinjMonza4QTReadWrite();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicMonza4ControlByte", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicMonza4ControlByte = PARAM_ThingMagicMonza4ControlByte.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicMonza4Payload", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicMonza4Payload = PARAM_ThingMagicMonza4Payload.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicMonza4ControlByte", "ThingMagicMonza4Payload",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicImpinjMonza4QTReadWrite OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 57;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 Payload=0;
        private Int16 Payload_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicImpinjMonza4QTReadWriteOpSpecResult_Custom_Param custom =
                param as IThingMagicImpinjMonza4QTReadWriteOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Payload != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Payload, Payload_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult obj = new PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.Payload = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicImpinjMonza4QTReadWriteOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Payload != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Payload>" + Util.ConvertValueTypeToString(Payload, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Payload>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicImpinjMonza4QTReadWriteOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult param = new PARAM_ThingMagicImpinjMonza4QTReadWriteOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "Payload");
        
            param.Payload = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The ReadWrite bit indicates whether the tag reads or writes QT control data. [ReadWrite=0 means read the QT control bits in cache, otherwise write the QT control bits]. If Read/Write=1, the Persistence field indicates whether the QT control is written to nonvolatile (NVM) or volatile memory. [Persistence=0 means write to volatile memory, otherwise write to NVM memory].
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicMonza4ControlByte : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicMonza4ControlByte()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 58;
        }
      
        public bool Persistance=false;
        private Int16 Persistance_len=0;
      
        public bool ReadWrite=false;
        private Int16 ReadWrite_len=0;
      
        private const UInt16 param_reserved_len4= 6;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicMonza4ControlByte_Custom_Param custom =
                param as IThingMagicMonza4ControlByte_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Persistance != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Persistance, Persistance_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadWrite != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadWrite, ReadWrite_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len4;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicMonza4ControlByte</returns>
        public new static PARAM_ThingMagicMonza4ControlByte FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicMonza4ControlByte obj = new PARAM_ThingMagicMonza4ControlByte();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Persistance = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ReadWrite = (bool)obj_val;
          
            cursor += param_reserved_len4;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicMonza4ControlByte";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Persistance != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Persistance>" + Util.ConvertValueTypeToString(Persistance, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Persistance>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadWrite != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadWrite>" + Util.ConvertValueTypeToString(ReadWrite, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadWrite>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicMonza4ControlByte>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicMonza4ControlByte</returns>
        public new static PARAM_ThingMagicMonza4ControlByte  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicMonza4ControlByte param = new PARAM_ThingMagicMonza4ControlByte();
    
            val = XmlUtil.GetNodeValue(node, "Persistance");
        
            param.Persistance = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadWrite");
        
            param.ReadWrite = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///QT_MEM is used to set the QT data profile. [If QT_MEM = 1, Tag uses Public Memory Map otherwise uses Private Memory Map]. QT_SR is used to set the access range. [if QT_SR = 1, Tag reduces range if in or about to be in OPEN or SECURED state. if QT_SR = 0, Tag does not reduce range].
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicMonza4Payload : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicMonza4Payload()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 59;
        }
      
        public bool QT_MEM=false;
        private Int16 QT_MEM_len=0;
      
        public bool QT_SR=false;
        private Int16 QT_SR_len=0;
      
        private const UInt16 param_reserved_len4= 14;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicMonza4Payload_Custom_Param custom =
                param as IThingMagicMonza4Payload_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (QT_MEM != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(QT_MEM, QT_MEM_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (QT_SR != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(QT_SR, QT_SR_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len4;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicMonza4Payload</returns>
        public new static PARAM_ThingMagicMonza4Payload FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicMonza4Payload obj = new PARAM_ThingMagicMonza4Payload();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.QT_MEM = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.QT_SR = (bool)obj_val;
          
            cursor += param_reserved_len4;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicMonza4Payload";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (QT_MEM != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "QT_MEM>" + Util.ConvertValueTypeToString(QT_MEM, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "QT_MEM>";
            
	            xml_str += "\r\n";
	        }
        
            if (QT_SR != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "QT_SR>" + Util.ConvertValueTypeToString(QT_SR, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "QT_SR>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicMonza4Payload>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicMonza4Payload</returns>
        public new static PARAM_ThingMagicMonza4Payload  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicMonza4Payload param = new PARAM_ThingMagicMonza4Payload();
    
            val = XmlUtil.GetNodeValue(node, "QT_MEM");
        
            param.QT_MEM = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "QT_SR");
        
            param.QT_SR = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The AccessPassword field is the password used by the Reader to transition the tag to the secure state. WriteData is the EPC to write.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicWriteTag : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicWriteTag()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 60;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public UInt16Array WriteData=new UInt16Array();
        private Int16 WriteData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicWriteTag_Custom_Param custom =
                param as IThingMagicWriteTag_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (WriteData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(WriteData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(WriteData, WriteData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicWriteTag</returns>
        public new static PARAM_ThingMagicWriteTag FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicWriteTag obj = new PARAM_ThingMagicWriteTag();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            obj.WriteData = (UInt16Array)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicWriteTag";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (WriteData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteData>" + Util.ConvertArrayTypeToString(WriteData, "u16v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicWriteTag>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicWriteTag</returns>
        public new static PARAM_ThingMagicWriteTag  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicWriteTag param = new PARAM_ThingMagicWriteTag();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "WriteData");
        
            param.WriteData = (UInt16Array)(Util.ParseArrayTypeFromString(val, "u16v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicWriteTag OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicWriteTagOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicWriteTagOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 61;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 NumWordsWritten=0;
        private Int16 NumWordsWritten_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicWriteTagOpSpecResult_Custom_Param custom =
                param as IThingMagicWriteTagOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NumWordsWritten != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumWordsWritten, NumWordsWritten_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicWriteTagOpSpecResult</returns>
        public new static PARAM_ThingMagicWriteTagOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicWriteTagOpSpecResult obj = new PARAM_ThingMagicWriteTagOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.NumWordsWritten = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicWriteTagOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (NumWordsWritten != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NumWordsWritten>" + Util.ConvertValueTypeToString(NumWordsWritten, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "NumWordsWritten>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicWriteTagOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicWriteTagOpSpecResult</returns>
        public new static PARAM_ThingMagicWriteTagOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicWriteTagOpSpecResult param = new PARAM_ThingMagicWriteTagOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NumWordsWritten");
        
            param.NumWordsWritten = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the ISO180006B tag specification.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BInventoryCommand : PARAM_Custom,IAccessCommand_Custom_Param,IAirProtocolInventoryCommandSettings_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BInventoryCommand()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 62;
        }
      
        public PARAM_ThingMagicISO180006BTagPattern ThingMagicISO180006BTagPattern;
                
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicISO180006BTagPattern != null)
            {
        ThingMagicISO180006BTagPattern.ToBitArray(ref bit_array, ref cursor);
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BInventoryCommand</returns>
        public new static PARAM_ThingMagicISO180006BInventoryCommand FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BInventoryCommand obj = new PARAM_ThingMagicISO180006BInventoryCommand();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicISO180006BTagPattern = PARAM_ThingMagicISO180006BTagPattern.FromBitArray(ref bit_array, ref cursor, length);
            
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BInventoryCommand";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicISO180006BTagPattern != null)
            {
          
                xml_str += Util.Indent(ThingMagicISO180006BTagPattern.ToString());
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BInventoryCommand>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BInventoryCommand</returns>
        public new static PARAM_ThingMagicISO180006BInventoryCommand  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BInventoryCommand param = new PARAM_ThingMagicISO180006BInventoryCommand();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicISO180006BTagPattern", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicISO180006BTagPattern = PARAM_ThingMagicISO180006BTagPattern.FromXmlNode(xnl[0]);
            }
              
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the ISO180006B tag pattern. Unlike C1G2 tag spec, this can be used for both inventory and tag operation.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BTagPattern : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BTagPattern()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 63;
        }
      
        public ENUM_ThingMagicISO180006BFilterType FilterType;
        private Int16 FilterType_len = 1;
        private const UInt16 param_reserved_len3= 7;
        
        public bool Invert=false;
        private Int16 Invert_len=0;
      
        private const UInt16 param_reserved_len5= 7;
        
        public TwoBits SelectOp=new TwoBits(0);
        private Int16 SelectOp_len=0;
      
        private const UInt16 param_reserved_len7= 6;
        
        public byte Address=0;
        private Int16 Address_len=0;
      
        public byte Mask=0;
        private Int16 Mask_len=0;
      
        public ByteArray TagData=new ByteArray();
        private Int16 TagData_len;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (FilterType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FilterType, FilterType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len3;
      
            if (Invert != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Invert, Invert_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (SelectOp != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SelectOp, SelectOp_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (Address != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Address, Address_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Mask != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mask, Mask_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(TagData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(TagData, TagData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BTagPattern</returns>
        public new static PARAM_ThingMagicISO180006BTagPattern FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BTagPattern obj = new PARAM_ThingMagicISO180006BTagPattern();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.FilterType = (ENUM_ThingMagicISO180006BFilterType)(UInt32)obj_val;
          
            cursor += param_reserved_len3;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Invert = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 2;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            obj.SelectOp = (TwoBits)obj_val;
          
            cursor += param_reserved_len7;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Address = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Mask = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.TagData = (ByteArray)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BTagPattern";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (FilterType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FilterType>" + FilterType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FilterType>";
            
	            xml_str += "\r\n";
	        }
        
            if (Invert != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Invert>" + Util.ConvertValueTypeToString(Invert, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Invert>";
            
	            xml_str += "\r\n";
	        }
        
            if (SelectOp != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SelectOp>" + SelectOp.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SelectOp>";
            
	            xml_str += "\r\n";
	        }
        
            if (Address != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Address>" + Util.ConvertValueTypeToString(Address, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Address>";
            
	            xml_str += "\r\n";
	        }
        
            if (Mask != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mask>" + Util.ConvertValueTypeToString(Mask, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Mask>";
            
	            xml_str += "\r\n";
	        }
        
            if (TagData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagData>" + Util.ConvertArrayTypeToString(TagData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagData>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BTagPattern>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BTagPattern</returns>
        public new static PARAM_ThingMagicISO180006BTagPattern  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BTagPattern param = new PARAM_ThingMagicISO180006BTagPattern();
    
            val = XmlUtil.GetNodeValue(node, "FilterType");
        
            param.FilterType = (ENUM_ThingMagicISO180006BFilterType)Enum.Parse(typeof(ENUM_ThingMagicISO180006BFilterType), val);
          
            val = XmlUtil.GetNodeValue(node, "Invert");
        
            param.Invert = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "SelectOp");
        
            param.SelectOp = TwoBits.FromString(val);
          
            val = XmlUtil.GetNodeValue(node, "Address");
        
            param.Address = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Mask");
        
            param.Mask = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "TagData");
        
            param.TagData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The parameter describes ISO180006B Read Operation.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BRead : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BRead()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 64;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 ByteAddress=0;
        private Int16 ByteAddress_len=0;
      
        public UInt16 ByteLen=0;
        private Int16 ByteLen_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ByteAddress != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ByteAddress, ByteAddress_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ByteLen != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ByteLen, ByteLen_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BRead</returns>
        public new static PARAM_ThingMagicISO180006BRead FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BRead obj = new PARAM_ThingMagicISO180006BRead();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.ByteAddress = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.ByteLen = (UInt16)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BRead";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ByteAddress != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ByteAddress>" + Util.ConvertValueTypeToString(ByteAddress, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ByteAddress>";
            
	            xml_str += "\r\n";
	        }
        
            if (ByteLen != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ByteLen>" + Util.ConvertValueTypeToString(ByteLen, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ByteLen>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BRead>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BRead</returns>
        public new static PARAM_ThingMagicISO180006BRead  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BRead param = new PARAM_ThingMagicISO180006BRead();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ByteAddress");
        
            param.ByteAddress = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ByteLen");
        
            param.ByteLen = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicISO180006BRead OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BReadOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BReadOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 65;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray ReadData=new ByteArray();
        private Int16 ReadData_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO180006BReadOpSpecResult_Custom_Param custom =
                param as IThingMagicISO180006BReadOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ReadData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReadData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReadData, ReadData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BReadOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BReadOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BReadOpSpecResult obj = new PARAM_ThingMagicISO180006BReadOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.ReadData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BReadOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ReadData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadData>" + Util.ConvertArrayTypeToString(ReadData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BReadOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BReadOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BReadOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BReadOpSpecResult param = new PARAM_ThingMagicISO180006BReadOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ReadData");
        
            param.ReadData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the custom air protocol.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomAirProtocols : PARAM_Custom,IAccessCommand_Custom_Param,IInventoryParameterSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomAirProtocols()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 66;
        }
      
        public ENUM_ThingMagicCustomAirProtocolList customProtocolId;
        private Int16 customProtocolId_len = 8;
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (customProtocolId != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(customProtocolId, customProtocolId_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomAirProtocols</returns>
        public new static PARAM_ThingMagicCustomAirProtocols FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomAirProtocols obj = new PARAM_ThingMagicCustomAirProtocols();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.customProtocolId = (ENUM_ThingMagicCustomAirProtocolList)(UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomAirProtocols";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (customProtocolId != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "customProtocolId>" + customProtocolId.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "customProtocolId>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomAirProtocols>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomAirProtocols</returns>
        public new static PARAM_ThingMagicCustomAirProtocols  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomAirProtocols param = new PARAM_ThingMagicCustomAirProtocols();
    
            val = XmlUtil.GetNodeValue(node, "customProtocolId");
        
            param.customProtocolId = (ENUM_ThingMagicCustomAirProtocolList)Enum.Parse(typeof(ENUM_ThingMagicCustomAirProtocolList), val);
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The parameter describes ISO180006B Write Operation.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BWrite : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BWrite()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 67;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 ByteAddress=0;
        private Int16 ByteAddress_len=0;
      
        public ByteArray WriteData=new ByteArray();
        private Int16 WriteData_len;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ByteAddress != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ByteAddress, ByteAddress_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (WriteData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(WriteData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(WriteData, WriteData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BWrite</returns>
        public new static PARAM_ThingMagicISO180006BWrite FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BWrite obj = new PARAM_ThingMagicISO180006BWrite();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.ByteAddress = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.WriteData = (ByteArray)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BWrite";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ByteAddress != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ByteAddress>" + Util.ConvertValueTypeToString(ByteAddress, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ByteAddress>";
            
	            xml_str += "\r\n";
	        }
        
            if (WriteData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteData>" + Util.ConvertArrayTypeToString(WriteData, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteData>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BWrite>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BWrite</returns>
        public new static PARAM_ThingMagicISO180006BWrite  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BWrite param = new PARAM_ThingMagicISO180006BWrite();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ByteAddress");
        
            param.ByteAddress = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "WriteData");
        
            param.WriteData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicISO180006BWrite OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BWriteOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BWriteOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 68;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 NumBytesWritten=0;
        private Int16 NumBytesWritten_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO180006BWriteOpSpecResult_Custom_Param custom =
                param as IThingMagicISO180006BWriteOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NumBytesWritten != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumBytesWritten, NumBytesWritten_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BWriteOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BWriteOpSpecResult obj = new PARAM_ThingMagicISO180006BWriteOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.NumBytesWritten = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BWriteOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (NumBytesWritten != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NumBytesWritten>" + Util.ConvertValueTypeToString(NumBytesWritten, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "NumBytesWritten>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BWriteOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BWriteOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BWriteOpSpecResult param = new PARAM_ThingMagicISO180006BWriteOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NumBytesWritten");
        
            param.NumBytesWritten = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///The parameter describes ISO180006B Lock Operation.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BLock : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BLock()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 69;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public byte Address=0;
        private Int16 Address_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Address != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Address, Address_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BLock</returns>
        public new static PARAM_ThingMagicISO180006BLock FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BLock obj = new PARAM_ThingMagicISO180006BLock();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Address = (byte)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BLock";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Address != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Address>" + Util.ConvertValueTypeToString(Address, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Address>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BLock>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BLock</returns>
        public new static PARAM_ThingMagicISO180006BLock  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BLock param = new PARAM_ThingMagicISO180006BLock();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "Address");
        
            param.Address = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagicISO180006BLock OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BLockOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BLockOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 70;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO180006BLockOpSpecResult_Custom_Param custom =
                param as IThingMagicISO180006BLockOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BLockOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BLockOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BLockOpSpecResult obj = new PARAM_ThingMagicISO180006BLockOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BLockOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BLockOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BLockOpSpecResult</returns>
        public new static PARAM_ThingMagicISO180006BLockOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BLockOpSpecResult param = new PARAM_ThingMagicISO180006BLockOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ISO18K6B protocol related custom parameters
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ISO18K6BCustomParameters : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ISO18K6BCustomParameters()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 71;
        }
      
        public PARAM_ThingMagicISO180006BDelimiter ThingMagicISO180006BDelimiter;
                
        public PARAM_ThingMagicISO18K6BModulationDepth ThingMagicISO18K6BModulationDepth;
                
        public PARAM_ThingMagicISO18K6BLinkFrequency ThingMagicISO18K6BLinkFrequency;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IISO18K6BCustomParameters_Custom_Param custom =
                param as IISO18K6BCustomParameters_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicISO180006BDelimiter != null)
            {
        ThingMagicISO180006BDelimiter.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicISO18K6BModulationDepth != null)
            {
        ThingMagicISO18K6BModulationDepth.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicISO18K6BLinkFrequency != null)
            {
        ThingMagicISO18K6BLinkFrequency.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ISO18K6BCustomParameters</returns>
        public new static PARAM_ISO18K6BCustomParameters FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ISO18K6BCustomParameters obj = new PARAM_ISO18K6BCustomParameters();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicISO180006BDelimiter = PARAM_ThingMagicISO180006BDelimiter.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicISO18K6BModulationDepth = PARAM_ThingMagicISO18K6BModulationDepth.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicISO18K6BLinkFrequency = PARAM_ThingMagicISO18K6BLinkFrequency.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ISO18K6BCustomParameters";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicISO180006BDelimiter != null)
            {
          
                xml_str += Util.Indent(ThingMagicISO180006BDelimiter.ToString());
            
            }
        
            if (ThingMagicISO18K6BModulationDepth != null)
            {
          
                xml_str += Util.Indent(ThingMagicISO18K6BModulationDepth.ToString());
            
            }
        
            if (ThingMagicISO18K6BLinkFrequency != null)
            {
          
                xml_str += Util.Indent(ThingMagicISO18K6BLinkFrequency.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ISO18K6BCustomParameters>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ISO18K6BCustomParameters</returns>
        public new static PARAM_ISO18K6BCustomParameters  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ISO18K6BCustomParameters param = new PARAM_ISO18K6BCustomParameters();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicISO180006BDelimiter", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicISO180006BDelimiter = PARAM_ThingMagicISO180006BDelimiter.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicISO18K6BModulationDepth", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicISO18K6BModulationDepth = PARAM_ThingMagicISO18K6BModulationDepth.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicISO18K6BLinkFrequency", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicISO18K6BLinkFrequency = PARAM_ThingMagicISO18K6BLinkFrequency.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicISO180006BDelimiter", "ThingMagicISO18K6BModulationDepth", "ThingMagicISO18K6BLinkFrequency",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter provides the custom ISO18K6B delimiter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO180006BDelimiter : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO180006BDelimiter()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 72;
        }
      
        public ENUM_ThingMagicCustom18K6BDelimiter ISO18K6BDelimiter;
        private Int16 ISO18K6BDelimiter_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO180006BDelimiter_Custom_Param custom =
                param as IThingMagicISO180006BDelimiter_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ISO18K6BDelimiter != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ISO18K6BDelimiter, ISO18K6BDelimiter_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO180006BDelimiter</returns>
        public new static PARAM_ThingMagicISO180006BDelimiter FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO180006BDelimiter obj = new PARAM_ThingMagicISO180006BDelimiter();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ISO18K6BDelimiter = (ENUM_ThingMagicCustom18K6BDelimiter)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO180006BDelimiter";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ISO18K6BDelimiter != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BDelimiter>" + ISO18K6BDelimiter.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BDelimiter>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO180006BDelimiter>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO180006BDelimiter</returns>
        public new static PARAM_ThingMagicISO180006BDelimiter  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO180006BDelimiter param = new PARAM_ThingMagicISO180006BDelimiter();
    
            val = XmlUtil.GetNodeValue(node, "ISO18K6BDelimiter");
        
            param.ISO18K6BDelimiter = (ENUM_ThingMagicCustom18K6BDelimiter)Enum.Parse(typeof(ENUM_ThingMagicCustom18K6BDelimiter), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter provides the custom ISO18K6B modulation depth.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO18K6BModulationDepth : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO18K6BModulationDepth()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 73;
        }
      
        public ENUM_ThingMagicCustom18K6BModulationDepth ISO18K6BModulationDepth;
        private Int16 ISO18K6BModulationDepth_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO18K6BModulationDepth_Custom_Param custom =
                param as IThingMagicISO18K6BModulationDepth_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ISO18K6BModulationDepth != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ISO18K6BModulationDepth, ISO18K6BModulationDepth_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO18K6BModulationDepth</returns>
        public new static PARAM_ThingMagicISO18K6BModulationDepth FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO18K6BModulationDepth obj = new PARAM_ThingMagicISO18K6BModulationDepth();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ISO18K6BModulationDepth = (ENUM_ThingMagicCustom18K6BModulationDepth)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO18K6BModulationDepth";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ISO18K6BModulationDepth != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BModulationDepth>" + ISO18K6BModulationDepth.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BModulationDepth>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO18K6BModulationDepth>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO18K6BModulationDepth</returns>
        public new static PARAM_ThingMagicISO18K6BModulationDepth  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO18K6BModulationDepth param = new PARAM_ThingMagicISO18K6BModulationDepth();
    
            val = XmlUtil.GetNodeValue(node, "ISO18K6BModulationDepth");
        
            param.ISO18K6BModulationDepth = (ENUM_ThingMagicCustom18K6BModulationDepth)Enum.Parse(typeof(ENUM_ThingMagicCustom18K6BModulationDepth), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter provides the custom ISO18K6B Link Frequency.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicISO18K6BLinkFrequency : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicISO18K6BLinkFrequency()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 74;
        }
      
        public ENUM_ThingMagicCustom18K6BLinkFrequency ISO18K6BLinkFrequency;
        private Int16 ISO18K6BLinkFrequency_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicISO18K6BLinkFrequency_Custom_Param custom =
                param as IThingMagicISO18K6BLinkFrequency_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ISO18K6BLinkFrequency != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ISO18K6BLinkFrequency, ISO18K6BLinkFrequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicISO18K6BLinkFrequency</returns>
        public new static PARAM_ThingMagicISO18K6BLinkFrequency FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicISO18K6BLinkFrequency obj = new PARAM_ThingMagicISO18K6BLinkFrequency();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ISO18K6BLinkFrequency = (ENUM_ThingMagicCustom18K6BLinkFrequency)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicISO18K6BLinkFrequency";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ISO18K6BLinkFrequency != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BLinkFrequency>" + ISO18K6BLinkFrequency.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ISO18K6BLinkFrequency>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicISO18K6BLinkFrequency>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicISO18K6BLinkFrequency</returns>
        public new static PARAM_ThingMagicISO18K6BLinkFrequency  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicISO18K6BLinkFrequency param = new PARAM_ThingMagicISO18K6BLinkFrequency();
    
            val = XmlUtil.GetNodeValue(node, "ISO18K6BLinkFrequency");
        
            param.ISO18K6BLinkFrequency = (ENUM_ThingMagicCustom18K6BLinkFrequency)Enum.Parse(typeof(ENUM_ThingMagicCustom18K6BLinkFrequency), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Sensor Value command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASensorValue : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASensorValue()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 76;
        }
      
        public ENUM_ThingMagicCustomIDSSensorType SensorType;
        private Int16 SensorType_len = 8;
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASensorValue_Custom_Param custom =
                param as IThingMagicIDSSL900ASensorValue_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (SensorType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SensorType, SensorType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASensorValue</returns>
        public new static PARAM_ThingMagicIDSSL900ASensorValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASensorValue obj = new PARAM_ThingMagicIDSSL900ASensorValue();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.SensorType = (ENUM_ThingMagicCustomIDSSensorType)(UInt32)obj_val;
          
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASensorValue";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (SensorType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorType>" + SensorType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorType>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASensorValue>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASensorValue</returns>
        public new static PARAM_ThingMagicIDSSL900ASensorValue  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASensorValue param = new PARAM_ThingMagicIDSSL900ASensorValue();
    
            val = XmlUtil.GetNodeValue(node, "SensorType");
        
            param.SensorType = (ENUM_ThingMagicCustomIDSSensorType)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSSensorType), val);
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Sensor Value command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ACommandRequest : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ACommandRequest()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 200;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public ENUM_ThingMagicCustomIDSPasswordLevel PasswordLevel;
        private Int16 PasswordLevel_len = 8;
        public byte CommandCode=0;
        private Int16 CommandCode_len=0;
      
        public UInt32 IDSPassword=0;
        private Int16 IDSPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ACommandRequest_Custom_Param custom =
                param as IThingMagicIDSSL900ACommandRequest_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PasswordLevel != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PasswordLevel, PasswordLevel_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CommandCode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CommandCode, CommandCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (IDSPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(IDSPassword, IDSPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ACommandRequest</returns>
        public new static PARAM_ThingMagicIDSSL900ACommandRequest FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ACommandRequest obj = new PARAM_ThingMagicIDSSL900ACommandRequest();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.PasswordLevel = (ENUM_ThingMagicCustomIDSPasswordLevel)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.CommandCode = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.IDSPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ACommandRequest";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (PasswordLevel != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PasswordLevel>" + PasswordLevel.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PasswordLevel>";
            
	            xml_str += "\r\n";
	        }
        
            if (CommandCode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CommandCode>" + Util.ConvertValueTypeToString(CommandCode, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CommandCode>";
            
	            xml_str += "\r\n";
	        }
        
            if (IDSPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "IDSPassword>" + Util.ConvertValueTypeToString(IDSPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "IDSPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ACommandRequest>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ACommandRequest</returns>
        public new static PARAM_ThingMagicIDSSL900ACommandRequest  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ACommandRequest param = new PARAM_ThingMagicIDSSL900ACommandRequest();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "PasswordLevel");
        
            param.PasswordLevel = (ENUM_ThingMagicCustomIDSPasswordLevel)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSPasswordLevel), val);
          
            val = XmlUtil.GetNodeValue(node, "CommandCode");
        
            param.CommandCode = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "IDSPassword");
        
            param.IDSPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get sensor value OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 77;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt16 reply=0;
        private Int16 reply_len=0;
      
        public UInt16 raw=0;
        private Int16 raw_len=0;
      
        public bool ADError=false;
        private Int16 ADError_len=0;
      
        private const UInt16 param_reserved_len7= 7;
        
        public byte RangeLimit=0;
        private Int16 RangeLimit_len=0;
      
        public UInt16 SensorValue=0;
        private Int16 SensorValue_len=0;
      
        public ByteArray SensorValueByteStream=new ByteArray();
        private Int16 SensorValueByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASensorValueOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASensorValueOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (reply != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(reply, reply_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (raw != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(raw, raw_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ADError != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ADError, ADError_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (RangeLimit != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RangeLimit, RangeLimit_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (SensorValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SensorValue, SensorValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (SensorValueByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(SensorValueByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(SensorValueByteStream, SensorValueByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.reply = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.raw = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ADError = (bool)obj_val;
          
            cursor += param_reserved_len7;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.RangeLimit = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.SensorValue = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.SensorValueByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASensorValueOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (reply != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "reply>" + Util.ConvertValueTypeToString(reply, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "reply>";
            
	            xml_str += "\r\n";
	        }
        
            if (raw != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "raw>" + Util.ConvertValueTypeToString(raw, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "raw>";
            
	            xml_str += "\r\n";
	        }
        
            if (ADError != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ADError>" + Util.ConvertValueTypeToString(ADError, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ADError>";
            
	            xml_str += "\r\n";
	        }
        
            if (RangeLimit != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RangeLimit>" + Util.ConvertValueTypeToString(RangeLimit, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "RangeLimit>";
            
	            xml_str += "\r\n";
	        }
        
            if (SensorValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorValue>" + Util.ConvertValueTypeToString(SensorValue, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "SensorValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (SensorValueByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorValueByteStream>" + Util.ConvertArrayTypeToString(SensorValueByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorValueByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASensorValueOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult param = new PARAM_ThingMagicIDSSL900ASensorValueOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "reply");
        
            param.reply = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "raw");
        
            param.raw = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ADError");
        
            param.ADError = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "RangeLimit");
        
            param.RangeLimit = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "SensorValue");
        
            param.SensorValue = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "SensorValueByteStream");
        
            param.SensorValueByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Log state command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetLogState : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetLogState()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 78;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetLogState_Custom_Param custom =
                param as IThingMagicIDSSL900AGetLogState_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetLogState</returns>
        public new static PARAM_ThingMagicIDSSL900AGetLogState FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetLogState obj = new PARAM_ThingMagicIDSSL900AGetLogState();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetLogState";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetLogState>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetLogState</returns>
        public new static PARAM_ThingMagicIDSSL900AGetLogState  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetLogState param = new PARAM_ThingMagicIDSSL900AGetLogState();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get Log State OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ALogStateOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ALogStateOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 79;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public PARAM_ThingMagicIDSLogState ThingMagicIDSLogState;
                
        public ByteArray LogStateByteStream=new ByteArray();
        private Int16 LogStateByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ALogStateOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ALogStateOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSLogState != null)
            {
        ThingMagicIDSLogState.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (LogStateByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(LogStateByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(LogStateByteStream, LogStateByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ALogStateOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ALogStateOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ALogStateOpSpecResult obj = new PARAM_ThingMagicIDSSL900ALogStateOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            obj.ThingMagicIDSLogState = PARAM_ThingMagicIDSLogState.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.LogStateByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ALogStateOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSLogState != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogState.ToString());
            
            }
        
            if (LogStateByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LogStateByteStream>" + Util.ConvertArrayTypeToString(LogStateByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LogStateByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ALogStateOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ALogStateOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ALogStateOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ALogStateOpSpecResult param = new PARAM_ThingMagicIDSSL900ALogStateOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogState", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogState = PARAM_ThingMagicIDSLogState.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "LogStateByteStream");
        
            param.LogStateByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSLogState",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get Log State OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogState : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogState()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 80;
        }
      
        public PARAM_ThingMagicIDSLogStateLimitCounter ThingMagicIDSLogStateLimitCounter;
                
        public PARAM_ThingMagicIDSLogStateSystemStatus ThingMagicIDSLogStateSystemStatus;
                
        public PARAM_ThingMagicIDSLogStateStatusFlag ThingMagicIDSLogStateStatusFlag;
                
        public PARAM_ThingMagicIDSSLBlock0 ThingMagicIDSSLBlock0;
                
        public PARAM_ThingMagicIDSSLBlock1 ThingMagicIDSSLBlock1;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogState_Custom_Param custom =
                param as IThingMagicIDSLogState_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSLogStateLimitCounter != null)
            {
        ThingMagicIDSLogStateLimitCounter.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSLogStateSystemStatus != null)
            {
        ThingMagicIDSLogStateSystemStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSLogStateStatusFlag != null)
            {
        ThingMagicIDSLogStateStatusFlag.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSSLBlock0 != null)
            {
        ThingMagicIDSSLBlock0.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSSLBlock1 != null)
            {
        ThingMagicIDSSLBlock1.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogState</returns>
        public new static PARAM_ThingMagicIDSLogState FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogState obj = new PARAM_ThingMagicIDSLogState();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSLogStateLimitCounter = PARAM_ThingMagicIDSLogStateLimitCounter.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSLogStateSystemStatus = PARAM_ThingMagicIDSLogStateSystemStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSLogStateStatusFlag = PARAM_ThingMagicIDSLogStateStatusFlag.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSSLBlock0 = PARAM_ThingMagicIDSSLBlock0.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSSLBlock1 = PARAM_ThingMagicIDSSLBlock1.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogState";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSLogStateLimitCounter != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogStateLimitCounter.ToString());
            
            }
        
            if (ThingMagicIDSLogStateSystemStatus != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogStateSystemStatus.ToString());
            
            }
        
            if (ThingMagicIDSLogStateStatusFlag != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogStateStatusFlag.ToString());
            
            }
        
            if (ThingMagicIDSSLBlock0 != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSLBlock0.ToString());
            
            }
        
            if (ThingMagicIDSSLBlock1 != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSLBlock1.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogState>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogState</returns>
        public new static PARAM_ThingMagicIDSLogState  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogState param = new PARAM_ThingMagicIDSLogState();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogStateLimitCounter", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogStateLimitCounter = PARAM_ThingMagicIDSLogStateLimitCounter.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogStateSystemStatus", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogStateSystemStatus = PARAM_ThingMagicIDSLogStateSystemStatus.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogStateStatusFlag", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogStateStatusFlag = PARAM_ThingMagicIDSLogStateStatusFlag.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSLBlock0", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSLBlock0 = PARAM_ThingMagicIDSSLBlock0.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSLBlock1", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSLBlock1 = PARAM_ThingMagicIDSSLBlock1.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSLogStateLimitCounter", "ThingMagicIDSLogStateSystemStatus", "ThingMagicIDSLogStateStatusFlag", "ThingMagicIDSSLBlock0", "ThingMagicIDSSLBlock1",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get Log State OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogStateLimitCounter : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogStateLimitCounter()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 81;
        }
      
        public byte extremeLower=0;
        private Int16 extremeLower_len=0;
      
        public byte lower=0;
        private Int16 lower_len=0;
      
        public byte upper=0;
        private Int16 upper_len=0;
      
        public byte extremeUpper=0;
        private Int16 extremeUpper_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogStateLimitCounter_Custom_Param custom =
                param as IThingMagicIDSLogStateLimitCounter_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (extremeLower != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(extremeLower, extremeLower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (lower != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(lower, lower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (upper != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(upper, upper_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (extremeUpper != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(extremeUpper, extremeUpper_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogStateLimitCounter</returns>
        public new static PARAM_ThingMagicIDSLogStateLimitCounter FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogStateLimitCounter obj = new PARAM_ThingMagicIDSLogStateLimitCounter();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.extremeLower = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.lower = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.upper = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.extremeUpper = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogStateLimitCounter";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (extremeLower != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "extremeLower>" + Util.ConvertValueTypeToString(extremeLower, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "extremeLower>";
            
	            xml_str += "\r\n";
	        }
        
            if (lower != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "lower>" + Util.ConvertValueTypeToString(lower, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "lower>";
            
	            xml_str += "\r\n";
	        }
        
            if (upper != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "upper>" + Util.ConvertValueTypeToString(upper, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "upper>";
            
	            xml_str += "\r\n";
	        }
        
            if (extremeUpper != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "extremeUpper>" + Util.ConvertValueTypeToString(extremeUpper, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "extremeUpper>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogStateLimitCounter>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogStateLimitCounter</returns>
        public new static PARAM_ThingMagicIDSLogStateLimitCounter  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogStateLimitCounter param = new PARAM_ThingMagicIDSLogStateLimitCounter();
    
            val = XmlUtil.GetNodeValue(node, "extremeLower");
        
            param.extremeLower = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "lower");
        
            param.lower = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "upper");
        
            param.upper = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "extremeUpper");
        
            param.extremeUpper = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get Log State OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogStateSystemStatus : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogStateSystemStatus()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 82;
        }
      
        public UInt16 MeasurementAddressPointer=0;
        private Int16 MeasurementAddressPointer_len=0;
      
        public byte NumMemReplacements=0;
        private Int16 NumMemReplacements_len=0;
      
        public UInt16 NumMeasurements=0;
        private Int16 NumMeasurements_len=0;
      
        public bool Active=false;
        private Int16 Active_len=0;
      
        private const UInt16 param_reserved_len6= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogStateSystemStatus_Custom_Param custom =
                param as IThingMagicIDSLogStateSystemStatus_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (MeasurementAddressPointer != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MeasurementAddressPointer, MeasurementAddressPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NumMemReplacements != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumMemReplacements, NumMemReplacements_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NumMeasurements != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumMeasurements, NumMeasurements_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Active != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Active, Active_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len6;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogStateSystemStatus</returns>
        public new static PARAM_ThingMagicIDSLogStateSystemStatus FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogStateSystemStatus obj = new PARAM_ThingMagicIDSLogStateSystemStatus();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.MeasurementAddressPointer = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.NumMemReplacements = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.NumMeasurements = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Active = (bool)obj_val;
          
            cursor += param_reserved_len6;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogStateSystemStatus";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (MeasurementAddressPointer != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MeasurementAddressPointer>" + Util.ConvertValueTypeToString(MeasurementAddressPointer, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "MeasurementAddressPointer>";
            
	            xml_str += "\r\n";
	        }
        
            if (NumMemReplacements != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NumMemReplacements>" + Util.ConvertValueTypeToString(NumMemReplacements, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "NumMemReplacements>";
            
	            xml_str += "\r\n";
	        }
        
            if (NumMeasurements != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NumMeasurements>" + Util.ConvertValueTypeToString(NumMeasurements, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "NumMeasurements>";
            
	            xml_str += "\r\n";
	        }
        
            if (Active != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Active>" + Util.ConvertValueTypeToString(Active, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Active>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogStateSystemStatus>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogStateSystemStatus</returns>
        public new static PARAM_ThingMagicIDSLogStateSystemStatus  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogStateSystemStatus param = new PARAM_ThingMagicIDSLogStateSystemStatus();
    
            val = XmlUtil.GetNodeValue(node, "MeasurementAddressPointer");
        
            param.MeasurementAddressPointer = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NumMemReplacements");
        
            param.NumMemReplacements = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "NumMeasurements");
        
            param.NumMeasurements = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "Active");
        
            param.Active = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS SL900A Get Log State OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogStateStatusFlag : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogStateStatusFlag()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 83;
        }
      
        public bool Active=false;
        private Int16 Active_len=0;
      
        public bool Full=false;
        private Int16 Full_len=0;
      
        public bool Overwritten=false;
        private Int16 Overwritten_len=0;
      
        public bool ADError=false;
        private Int16 ADError_len=0;
      
        public bool LowBattery=false;
        private Int16 LowBattery_len=0;
      
        public bool ShelfLifeLow=false;
        private Int16 ShelfLifeLow_len=0;
      
        public bool ShelfLifeHigh=false;
        private Int16 ShelfLifeHigh_len=0;
      
        public bool ShelfLifeExpired=false;
        private Int16 ShelfLifeExpired_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogStateStatusFlag_Custom_Param custom =
                param as IThingMagicIDSLogStateStatusFlag_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Active != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Active, Active_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Full != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Full, Full_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Overwritten != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Overwritten, Overwritten_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ADError != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ADError, ADError_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LowBattery != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LowBattery, LowBattery_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ShelfLifeLow != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ShelfLifeLow, ShelfLifeLow_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ShelfLifeHigh != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ShelfLifeHigh, ShelfLifeHigh_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ShelfLifeExpired != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ShelfLifeExpired, ShelfLifeExpired_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogStateStatusFlag</returns>
        public new static PARAM_ThingMagicIDSLogStateStatusFlag FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogStateStatusFlag obj = new PARAM_ThingMagicIDSLogStateStatusFlag();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Active = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Full = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Overwritten = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ADError = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.LowBattery = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ShelfLifeLow = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ShelfLifeHigh = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ShelfLifeExpired = (bool)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogStateStatusFlag";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Active != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Active>" + Util.ConvertValueTypeToString(Active, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Active>";
            
	            xml_str += "\r\n";
	        }
        
            if (Full != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Full>" + Util.ConvertValueTypeToString(Full, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Full>";
            
	            xml_str += "\r\n";
	        }
        
            if (Overwritten != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Overwritten>" + Util.ConvertValueTypeToString(Overwritten, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Overwritten>";
            
	            xml_str += "\r\n";
	        }
        
            if (ADError != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ADError>" + Util.ConvertValueTypeToString(ADError, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ADError>";
            
	            xml_str += "\r\n";
	        }
        
            if (LowBattery != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LowBattery>" + Util.ConvertValueTypeToString(LowBattery, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "LowBattery>";
            
	            xml_str += "\r\n";
	        }
        
            if (ShelfLifeLow != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ShelfLifeLow>" + Util.ConvertValueTypeToString(ShelfLifeLow, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ShelfLifeLow>";
            
	            xml_str += "\r\n";
	        }
        
            if (ShelfLifeHigh != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ShelfLifeHigh>" + Util.ConvertValueTypeToString(ShelfLifeHigh, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ShelfLifeHigh>";
            
	            xml_str += "\r\n";
	        }
        
            if (ShelfLifeExpired != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ShelfLifeExpired>" + Util.ConvertValueTypeToString(ShelfLifeExpired, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ShelfLifeExpired>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogStateStatusFlag>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogStateStatusFlag</returns>
        public new static PARAM_ThingMagicIDSLogStateStatusFlag  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogStateStatusFlag param = new PARAM_ThingMagicIDSLogStateStatusFlag();
    
            val = XmlUtil.GetNodeValue(node, "Active");
        
            param.Active = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "Full");
        
            param.Full = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "Overwritten");
        
            param.Overwritten = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ADError");
        
            param.ADError = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "LowBattery");
        
            param.LowBattery = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ShelfLifeLow");
        
            param.ShelfLifeLow = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ShelfLifeHigh");
        
            param.ShelfLifeHigh = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "ShelfLifeExpired");
        
            param.ShelfLifeExpired = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Log state command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetLogMode : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetLogMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 84;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public ENUM_ThingMagicCustomIDSLoggingForm LoggingForm;
        private Int16 LoggingForm_len = 8;
        public ENUM_ThingMagicCustomIDSStorageRule StorageRule;
        private Int16 StorageRule_len = 8;
        public bool Ext1Enable=false;
        private Int16 Ext1Enable_len=0;
      
        public bool Ext2Enable=false;
        private Int16 Ext2Enable_len=0;
      
        public bool TempEnable=false;
        private Int16 TempEnable_len=0;
      
        public bool BattEnable=false;
        private Int16 BattEnable_len=0;
      
        private const UInt16 param_reserved_len9= 4;
        
        public UInt16 LogInterval=0;
        private Int16 LogInterval_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetLogMode_Custom_Param custom =
                param as IThingMagicIDSSL900ASetLogMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (LoggingForm != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LoggingForm, LoggingForm_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (StorageRule != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StorageRule, StorageRule_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ext1Enable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext1Enable, Ext1Enable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ext2Enable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext2Enable, Ext2Enable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TempEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TempEnable, TempEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (BattEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BattEnable, BattEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len9;
      
            if (LogInterval != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LogInterval, LogInterval_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogMode</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetLogMode obj = new PARAM_ThingMagicIDSSL900ASetLogMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.LoggingForm = (ENUM_ThingMagicCustomIDSLoggingForm)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StorageRule = (ENUM_ThingMagicCustomIDSStorageRule)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Ext1Enable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Ext2Enable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.TempEnable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.BattEnable = (bool)obj_val;
          
            cursor += param_reserved_len9;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.LogInterval = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetLogMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (LoggingForm != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LoggingForm>" + LoggingForm.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LoggingForm>";
            
	            xml_str += "\r\n";
	        }
        
            if (StorageRule != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StorageRule>" + StorageRule.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StorageRule>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ext1Enable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext1Enable>" + Util.ConvertValueTypeToString(Ext1Enable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext1Enable>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ext2Enable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext2Enable>" + Util.ConvertValueTypeToString(Ext2Enable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext2Enable>";
            
	            xml_str += "\r\n";
	        }
        
            if (TempEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TempEnable>" + Util.ConvertValueTypeToString(TempEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TempEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (BattEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BattEnable>" + Util.ConvertValueTypeToString(BattEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "BattEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (LogInterval != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LogInterval>" + Util.ConvertValueTypeToString(LogInterval, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "LogInterval>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetLogMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogMode</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetLogMode param = new PARAM_ThingMagicIDSSL900ASetLogMode();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "LoggingForm");
        
            param.LoggingForm = (ENUM_ThingMagicCustomIDSLoggingForm)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSLoggingForm), val);
          
            val = XmlUtil.GetNodeValue(node, "StorageRule");
        
            param.StorageRule = (ENUM_ThingMagicCustomIDSStorageRule)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSStorageRule), val);
          
            val = XmlUtil.GetNodeValue(node, "Ext1Enable");
        
            param.Ext1Enable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "Ext2Enable");
        
            param.Ext2Enable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "TempEnable");
        
            param.TempEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "BattEnable");
        
            param.BattEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "LogInterval");
        
            param.LogInterval = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Startlog OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 85;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetLogModeOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASetLogModeOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetLogModeOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetLogModeOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult param = new PARAM_ThingMagicIDSSL900ASetLogModeOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Start Log command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AStartLog : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AStartLog()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 86;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public UInt32 StartTime=0;
        private Int16 StartTime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AStartLog_Custom_Param custom =
                param as IThingMagicIDSSL900AStartLog_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (StartTime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StartTime, StartTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AStartLog</returns>
        public new static PARAM_ThingMagicIDSSL900AStartLog FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AStartLog obj = new PARAM_ThingMagicIDSSL900AStartLog();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StartTime = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AStartLog";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (StartTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StartTime>" + Util.ConvertValueTypeToString(StartTime, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "StartTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AStartLog>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AStartLog</returns>
        public new static PARAM_ThingMagicIDSSL900AStartLog  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AStartLog param = new PARAM_ThingMagicIDSSL900AStartLog();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "StartTime");
        
            param.StartTime = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Startlog OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AStartLogOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AStartLogOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 87;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AStartLogOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AStartLogOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AStartLogOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AStartLogOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AStartLogOpSpecResult obj = new PARAM_ThingMagicIDSSL900AStartLogOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AStartLogOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AStartLogOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AStartLogOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AStartLogOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AStartLogOpSpecResult param = new PARAM_ThingMagicIDSSL900AStartLogOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS End log command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AEndLog : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AEndLog()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 88;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AEndLog_Custom_Param custom =
                param as IThingMagicIDSSL900AEndLog_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AEndLog</returns>
        public new static PARAM_ThingMagicIDSSL900AEndLog FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AEndLog obj = new PARAM_ThingMagicIDSSL900AEndLog();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AEndLog";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AEndLog>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AEndLog</returns>
        public new static PARAM_ThingMagicIDSSL900AEndLog  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AEndLog param = new PARAM_ThingMagicIDSSL900AEndLog();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Endlog OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AEndLogOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AEndLogOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 89;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AEndLogOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AEndLogOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AEndLogOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AEndLogOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AEndLogOpSpecResult obj = new PARAM_ThingMagicIDSSL900AEndLogOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AEndLogOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AEndLogOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AEndLogOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AEndLogOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AEndLogOpSpecResult param = new PARAM_ThingMagicIDSSL900AEndLogOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Initialize command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AInitialize : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AInitialize()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 90;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public PARAM_ThingMagicIDSDelayTime ThingMagicIDSDelayTime;
                
        public PARAM_ThingMagicIDSApplicationData ThingMagicIDSApplicationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AInitialize_Custom_Param custom =
                param as IThingMagicIDSSL900AInitialize_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSDelayTime != null)
            {
        ThingMagicIDSDelayTime.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSApplicationData != null)
            {
        ThingMagicIDSApplicationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AInitialize</returns>
        public new static PARAM_ThingMagicIDSSL900AInitialize FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AInitialize obj = new PARAM_ThingMagicIDSSL900AInitialize();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSDelayTime = PARAM_ThingMagicIDSDelayTime.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSApplicationData = PARAM_ThingMagicIDSApplicationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AInitialize";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (ThingMagicIDSDelayTime != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSDelayTime.ToString());
            
            }
        
            if (ThingMagicIDSApplicationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSApplicationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AInitialize>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AInitialize</returns>
        public new static PARAM_ThingMagicIDSSL900AInitialize  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AInitialize param = new PARAM_ThingMagicIDSSL900AInitialize();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSDelayTime", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSDelayTime = PARAM_ThingMagicIDSDelayTime.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSApplicationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSApplicationData = PARAM_ThingMagicIDSApplicationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest", "ThingMagicIDSDelayTime", "ThingMagicIDSApplicationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Initialize OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AInitializeOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AInitializeOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 91;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AInitializeOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AInitializeOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AInitializeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AInitializeOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AInitializeOpSpecResult obj = new PARAM_ThingMagicIDSSL900AInitializeOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AInitializeOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AInitializeOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AInitializeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AInitializeOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AInitializeOpSpecResult param = new PARAM_ThingMagicIDSSL900AInitializeOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Measurement Setup command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetMeasurementSetup : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetMeasurementSetup()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 92;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetMeasurementSetup_Custom_Param custom =
                param as IThingMagicIDSSL900AGetMeasurementSetup_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetMeasurementSetup</returns>
        public new static PARAM_ThingMagicIDSSL900AGetMeasurementSetup FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetMeasurementSetup obj = new PARAM_ThingMagicIDSSL900AGetMeasurementSetup();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetMeasurementSetup";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetMeasurementSetup>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetMeasurementSetup</returns>
        public new static PARAM_ThingMagicIDSSL900AGetMeasurementSetup  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetMeasurementSetup param = new PARAM_ThingMagicIDSSL900AGetMeasurementSetup();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Get Measurement Setup OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 93;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public PARAM_ThingMagicIDSStartTime ThingMagicIDSStartTime;
                
        public PARAM_ThingMagicIDSLogLimits ThingMagicIDSLogLimits;
                
        public PARAM_ThingMagicIDSLogMode ThingMagicIDSLogMode;
                
        public UInt16 logInterval=0;
        private Int16 logInterval_len=0;
      
        public PARAM_ThingMagicIDSDelayTime ThingMagicIDSDelayTime;
                
        public PARAM_ThingMagicIDSApplicationData ThingMagicIDSApplicationData;
                
        public ByteArray measurementByteStream=new ByteArray();
        private Int16 measurementByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetMeasurementSetupOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AGetMeasurementSetupOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSStartTime != null)
            {
        ThingMagicIDSStartTime.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSLogLimits != null)
            {
        ThingMagicIDSLogLimits.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSLogMode != null)
            {
        ThingMagicIDSLogMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (logInterval != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(logInterval, logInterval_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSDelayTime != null)
            {
        ThingMagicIDSDelayTime.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSApplicationData != null)
            {
        ThingMagicIDSApplicationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (measurementByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(measurementByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(measurementByteStream, measurementByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult obj = new PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            obj.ThingMagicIDSStartTime = PARAM_ThingMagicIDSStartTime.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSLogLimits = PARAM_ThingMagicIDSLogLimits.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSLogMode = PARAM_ThingMagicIDSLogMode.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.logInterval = (UInt16)obj_val;
          
            obj.ThingMagicIDSDelayTime = PARAM_ThingMagicIDSDelayTime.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSApplicationData = PARAM_ThingMagicIDSApplicationData.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.measurementByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSStartTime != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSStartTime.ToString());
            
            }
        
            if (ThingMagicIDSLogLimits != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogLimits.ToString());
            
            }
        
            if (ThingMagicIDSLogMode != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogMode.ToString());
            
            }
        
            if (logInterval != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "logInterval>" + Util.ConvertValueTypeToString(logInterval, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "logInterval>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSDelayTime != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSDelayTime.ToString());
            
            }
        
            if (ThingMagicIDSApplicationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSApplicationData.ToString());
            
            }
        
            if (measurementByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "measurementByteStream>" + Util.ConvertArrayTypeToString(measurementByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "measurementByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult param = new PARAM_ThingMagicIDSSL900AGetMeasurementSetupOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSStartTime", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSStartTime = PARAM_ThingMagicIDSStartTime.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogLimits", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogLimits = PARAM_ThingMagicIDSLogLimits.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogMode = PARAM_ThingMagicIDSLogMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "logInterval");
        
            param.logInterval = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSDelayTime", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSDelayTime = PARAM_ThingMagicIDSDelayTime.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSApplicationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSApplicationData = PARAM_ThingMagicIDSApplicationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "measurementByteStream");
        
            param.measurementByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSStartTime", "ThingMagicIDSLogLimits", "ThingMagicIDSLogMode", "ThingMagicIDSDelayTime", "ThingMagicIDSApplicationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Calibration Data command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetCalibrationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetCalibrationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 94;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetCalibrationData_Custom_Param custom =
                param as IThingMagicIDSSL900AGetCalibrationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetCalibrationData</returns>
        public new static PARAM_ThingMagicIDSSL900AGetCalibrationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetCalibrationData obj = new PARAM_ThingMagicIDSSL900AGetCalibrationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetCalibrationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetCalibrationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetCalibrationData</returns>
        public new static PARAM_ThingMagicIDSSL900AGetCalibrationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetCalibrationData param = new PARAM_ThingMagicIDSSL900AGetCalibrationData();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Get Calibration Data OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 95;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public PARAM_ThingMagicIDSCalibrationData ThingMagicIDSCalibrationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetCalibrationDataOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AGetCalibrationDataOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSCalibrationData != null)
            {
        ThingMagicIDSCalibrationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult obj = new PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            obj.ThingMagicIDSCalibrationData = PARAM_ThingMagicIDSCalibrationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetCalibrationDataOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSCalibrationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSCalibrationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetCalibrationDataOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult param = new PARAM_ThingMagicIDSSL900AGetCalibrationDataOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSCalibrationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSCalibrationData = PARAM_ThingMagicIDSCalibrationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSCalibrationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Set Calibration Data command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetCalibrationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetCalibrationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 96;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public PARAM_ThingMagicIDSCalibrationData ThingMagicIDSCalibrationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetCalibrationData_Custom_Param custom =
                param as IThingMagicIDSSL900ASetCalibrationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSCalibrationData != null)
            {
        ThingMagicIDSCalibrationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetCalibrationData</returns>
        public new static PARAM_ThingMagicIDSSL900ASetCalibrationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetCalibrationData obj = new PARAM_ThingMagicIDSSL900ASetCalibrationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSCalibrationData = PARAM_ThingMagicIDSCalibrationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetCalibrationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (ThingMagicIDSCalibrationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSCalibrationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetCalibrationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetCalibrationData</returns>
        public new static PARAM_ThingMagicIDSSL900ASetCalibrationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetCalibrationData param = new PARAM_ThingMagicIDSSL900ASetCalibrationData();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSCalibrationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSCalibrationData = PARAM_ThingMagicIDSCalibrationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest", "ThingMagicIDSCalibrationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Set Calibration Data OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 97;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetCalibrationDataOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASetCalibrationDataOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetCalibrationDataOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetCalibrationDataOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult param = new PARAM_ThingMagicIDSSL900ASetCalibrationDataOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Set SFE Parameters command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetSFEParams : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetSFEParams()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 98;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public PARAM_ThingMagicIDSSFEParam ThingMagicIDSSFEParam;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetSFEParams_Custom_Param custom =
                param as IThingMagicIDSSL900ASetSFEParams_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSSFEParam != null)
            {
        ThingMagicIDSSFEParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetSFEParams</returns>
        public new static PARAM_ThingMagicIDSSL900ASetSFEParams FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetSFEParams obj = new PARAM_ThingMagicIDSSL900ASetSFEParams();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSSFEParam = PARAM_ThingMagicIDSSFEParam.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetSFEParams";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (ThingMagicIDSSFEParam != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSFEParam.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetSFEParams>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetSFEParams</returns>
        public new static PARAM_ThingMagicIDSSL900ASetSFEParams  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetSFEParams param = new PARAM_ThingMagicIDSSL900ASetSFEParams();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSFEParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSFEParam = PARAM_ThingMagicIDSSFEParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest", "ThingMagicIDSSFEParam",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Set SFE Parameters OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 99;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetSFEParamsOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASetSFEParamsOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetSFEParamsOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetSFEParamsOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult param = new PARAM_ThingMagicIDSSL900ASetSFEParamsOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Access FIFO status command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFOStatus : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFOStatus()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 100;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFOStatus_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFOStatus_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOStatus</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOStatus FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFOStatus obj = new PARAM_ThingMagicIDSSL900AAccessFIFOStatus();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFOStatus";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFOStatus>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOStatus</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOStatus  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFOStatus param = new PARAM_ThingMagicIDSSL900AAccessFIFOStatus();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Access FIFO Status OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 101;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public bool FIFOStatusBusy=false;
        private Int16 FIFOStatusBusy_len=0;
      
        public bool FIFOStatusDataReady=false;
        private Int16 FIFOStatusDataReady_len=0;
      
        public bool FIFOStatusNoData=false;
        private Int16 FIFOStatusNoData_len=0;
      
        private const UInt16 param_reserved_len7= 5;
        
        public byte numValidBytes=0;
        private Int16 numValidBytes_len=0;
      
        public bool FIFOSource=false;
        private Int16 FIFOSource_len=0;
      
        private const UInt16 param_reserved_len10= 7;
        
        public byte FIFOStatusRawByte=0;
        private Int16 FIFOStatusRawByte_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFOStatusOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFOStatusOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (FIFOStatusBusy != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOStatusBusy, FIFOStatusBusy_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (FIFOStatusDataReady != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOStatusDataReady, FIFOStatusDataReady_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (FIFOStatusNoData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOStatusNoData, FIFOStatusNoData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len7;
      
            if (numValidBytes != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(numValidBytes, numValidBytes_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (FIFOSource != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOSource, FIFOSource_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len10;
      
            if (FIFOStatusRawByte != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOStatusRawByte, FIFOStatusRawByte_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult obj = new PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.FIFOStatusBusy = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.FIFOStatusDataReady = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.FIFOStatusNoData = (bool)obj_val;
          
            cursor += param_reserved_len7;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.numValidBytes = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.FIFOSource = (bool)obj_val;
          
            cursor += param_reserved_len10;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.FIFOStatusRawByte = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (FIFOStatusBusy != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOStatusBusy>" + Util.ConvertValueTypeToString(FIFOStatusBusy, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOStatusBusy>";
            
	            xml_str += "\r\n";
	        }
        
            if (FIFOStatusDataReady != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOStatusDataReady>" + Util.ConvertValueTypeToString(FIFOStatusDataReady, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOStatusDataReady>";
            
	            xml_str += "\r\n";
	        }
        
            if (FIFOStatusNoData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOStatusNoData>" + Util.ConvertValueTypeToString(FIFOStatusNoData, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOStatusNoData>";
            
	            xml_str += "\r\n";
	        }
        
            if (numValidBytes != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "numValidBytes>" + Util.ConvertValueTypeToString(numValidBytes, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "numValidBytes>";
            
	            xml_str += "\r\n";
	        }
        
            if (FIFOSource != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOSource>" + Util.ConvertValueTypeToString(FIFOSource, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOSource>";
            
	            xml_str += "\r\n";
	        }
        
            if (FIFOStatusRawByte != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOStatusRawByte>" + Util.ConvertValueTypeToString(FIFOStatusRawByte, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOStatusRawByte>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult param = new PARAM_ThingMagicIDSSL900AAccessFIFOStatusOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "FIFOStatusBusy");
        
            param.FIFOStatusBusy = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "FIFOStatusDataReady");
        
            param.FIFOStatusDataReady = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "FIFOStatusNoData");
        
            param.FIFOStatusNoData = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "numValidBytes");
        
            param.numValidBytes = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "FIFOSource");
        
            param.FIFOSource = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "FIFOStatusRawByte");
        
            param.FIFOStatusRawByte = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Get Battery Level command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetBatteryLevel : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetBatteryLevel()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 102;
        }
      
        public byte BatteryTrigger=0;
        private Int16 BatteryTrigger_len=0;
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetBatteryLevel_Custom_Param custom =
                param as IThingMagicIDSSL900AGetBatteryLevel_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (BatteryTrigger != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BatteryTrigger, BatteryTrigger_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetBatteryLevel</returns>
        public new static PARAM_ThingMagicIDSSL900AGetBatteryLevel FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetBatteryLevel obj = new PARAM_ThingMagicIDSSL900AGetBatteryLevel();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.BatteryTrigger = (byte)obj_val;
          
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetBatteryLevel";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (BatteryTrigger != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BatteryTrigger>" + Util.ConvertValueTypeToString(BatteryTrigger, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "BatteryTrigger>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetBatteryLevel>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetBatteryLevel</returns>
        public new static PARAM_ThingMagicIDSSL900AGetBatteryLevel  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetBatteryLevel param = new PARAM_ThingMagicIDSSL900AGetBatteryLevel();
    
            val = XmlUtil.GetNodeValue(node, "BatteryTrigger");
        
            param.BatteryTrigger = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic IDS Get Battery Level OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 103;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public PARAM_ThingMagicIDSBatteryLevel ThingMagicIDSBatteryLevel;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AGetBatteryLevelOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AGetBatteryLevelOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicIDSBatteryLevel != null)
            {
        ThingMagicIDSBatteryLevel.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult obj = new PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            obj.ThingMagicIDSBatteryLevel = PARAM_ThingMagicIDSBatteryLevel.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AGetBatteryLevelOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicIDSBatteryLevel != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSBatteryLevel.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AGetBatteryLevelOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult param = new PARAM_ThingMagicIDSSL900AGetBatteryLevelOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSBatteryLevel", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSBatteryLevel = PARAM_ThingMagicIDSBatteryLevel.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSBatteryLevel",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS delay time paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSDelayTime : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSDelayTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 104;
        }
      
        public byte delayMode=0;
        private Int16 delayMode_len=0;
      
        public UInt16 delayTime=0;
        private Int16 delayTime_len=0;
      
        public bool timerEnable=false;
        private Int16 timerEnable_len=0;
      
        private const UInt16 param_reserved_len5= 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSDelayTime_Custom_Param custom =
                param as IThingMagicIDSDelayTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (delayMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(delayMode, delayMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (delayTime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(delayTime, delayTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (timerEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(timerEnable, timerEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSDelayTime</returns>
        public new static PARAM_ThingMagicIDSDelayTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSDelayTime obj = new PARAM_ThingMagicIDSDelayTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.delayMode = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.delayTime = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.timerEnable = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSDelayTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (delayMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "delayMode>" + Util.ConvertValueTypeToString(delayMode, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "delayMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (delayTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "delayTime>" + Util.ConvertValueTypeToString(delayTime, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "delayTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (timerEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "timerEnable>" + Util.ConvertValueTypeToString(timerEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "timerEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSDelayTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSDelayTime</returns>
        public new static PARAM_ThingMagicIDSDelayTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSDelayTime param = new PARAM_ThingMagicIDSDelayTime();
    
            val = XmlUtil.GetNodeValue(node, "delayMode");
        
            param.delayMode = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "delayTime");
        
            param.delayTime = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "timerEnable");
        
            param.timerEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS Application Data paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSApplicationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSApplicationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 105;
        }
      
        public byte brokenWordPointer=0;
        private Int16 brokenWordPointer_len=0;
      
        public UInt16 numberOfWords=0;
        private Int16 numberOfWords_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSApplicationData_Custom_Param custom =
                param as IThingMagicIDSApplicationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (brokenWordPointer != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(brokenWordPointer, brokenWordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (numberOfWords != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(numberOfWords, numberOfWords_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSApplicationData</returns>
        public new static PARAM_ThingMagicIDSApplicationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSApplicationData obj = new PARAM_ThingMagicIDSApplicationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.brokenWordPointer = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.numberOfWords = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSApplicationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (brokenWordPointer != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "brokenWordPointer>" + Util.ConvertValueTypeToString(brokenWordPointer, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "brokenWordPointer>";
            
	            xml_str += "\r\n";
	        }
        
            if (numberOfWords != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "numberOfWords>" + Util.ConvertValueTypeToString(numberOfWords, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "numberOfWords>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSApplicationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSApplicationData</returns>
        public new static PARAM_ThingMagicIDSApplicationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSApplicationData param = new PARAM_ThingMagicIDSApplicationData();
    
            val = XmlUtil.GetNodeValue(node, "brokenWordPointer");
        
            param.brokenWordPointer = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "numberOfWords");
        
            param.numberOfWords = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS Log Mode paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogMode : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 106;
        }
      
        public bool Ext1Enable=false;
        private Int16 Ext1Enable_len=0;
      
        public bool Ext2Enable=false;
        private Int16 Ext2Enable_len=0;
      
        public bool TempEnable=false;
        private Int16 TempEnable_len=0;
      
        public bool BattEnable=false;
        private Int16 BattEnable_len=0;
      
        private const UInt16 param_reserved_len6= 4;
        
        public ENUM_ThingMagicCustomIDSStorageRule StorageRule;
        private Int16 StorageRule_len = 8;
        public ENUM_ThingMagicCustomIDSLoggingForm LoggingForm;
        private Int16 LoggingForm_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogMode_Custom_Param custom =
                param as IThingMagicIDSLogMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Ext1Enable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext1Enable, Ext1Enable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ext2Enable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext2Enable, Ext2Enable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TempEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TempEnable, TempEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (BattEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BattEnable, BattEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len6;
      
            if (StorageRule != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StorageRule, StorageRule_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LoggingForm != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LoggingForm, LoggingForm_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogMode</returns>
        public new static PARAM_ThingMagicIDSLogMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogMode obj = new PARAM_ThingMagicIDSLogMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Ext1Enable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Ext2Enable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.TempEnable = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.BattEnable = (bool)obj_val;
          
            cursor += param_reserved_len6;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StorageRule = (ENUM_ThingMagicCustomIDSStorageRule)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.LoggingForm = (ENUM_ThingMagicCustomIDSLoggingForm)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Ext1Enable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext1Enable>" + Util.ConvertValueTypeToString(Ext1Enable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext1Enable>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ext2Enable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext2Enable>" + Util.ConvertValueTypeToString(Ext2Enable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext2Enable>";
            
	            xml_str += "\r\n";
	        }
        
            if (TempEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TempEnable>" + Util.ConvertValueTypeToString(TempEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TempEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (BattEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BattEnable>" + Util.ConvertValueTypeToString(BattEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "BattEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (StorageRule != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StorageRule>" + StorageRule.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StorageRule>";
            
	            xml_str += "\r\n";
	        }
        
            if (LoggingForm != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LoggingForm>" + LoggingForm.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LoggingForm>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogMode</returns>
        public new static PARAM_ThingMagicIDSLogMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogMode param = new PARAM_ThingMagicIDSLogMode();
    
            val = XmlUtil.GetNodeValue(node, "Ext1Enable");
        
            param.Ext1Enable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "Ext2Enable");
        
            param.Ext2Enable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "TempEnable");
        
            param.TempEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "BattEnable");
        
            param.BattEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "StorageRule");
        
            param.StorageRule = (ENUM_ThingMagicCustomIDSStorageRule)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSStorageRule), val);
          
            val = XmlUtil.GetNodeValue(node, "LoggingForm");
        
            param.LoggingForm = (ENUM_ThingMagicCustomIDSLoggingForm)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSLoggingForm), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS Log Limits paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSLogLimits : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSLogLimits()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 107;
        }
      
        public UInt16 extremeLower=0;
        private Int16 extremeLower_len=0;
      
        public UInt16 lower=0;
        private Int16 lower_len=0;
      
        public UInt16 upper=0;
        private Int16 upper_len=0;
      
        public UInt16 extremeUpper=0;
        private Int16 extremeUpper_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSLogLimits_Custom_Param custom =
                param as IThingMagicIDSLogLimits_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (extremeLower != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(extremeLower, extremeLower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (lower != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(lower, lower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (upper != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(upper, upper_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (extremeUpper != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(extremeUpper, extremeUpper_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSLogLimits</returns>
        public new static PARAM_ThingMagicIDSLogLimits FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSLogLimits obj = new PARAM_ThingMagicIDSLogLimits();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.extremeLower = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.lower = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.upper = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.extremeUpper = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSLogLimits";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (extremeLower != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "extremeLower>" + Util.ConvertValueTypeToString(extremeLower, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "extremeLower>";
            
	            xml_str += "\r\n";
	        }
        
            if (lower != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "lower>" + Util.ConvertValueTypeToString(lower, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "lower>";
            
	            xml_str += "\r\n";
	        }
        
            if (upper != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "upper>" + Util.ConvertValueTypeToString(upper, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "upper>";
            
	            xml_str += "\r\n";
	        }
        
            if (extremeUpper != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "extremeUpper>" + Util.ConvertValueTypeToString(extremeUpper, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "extremeUpper>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSLogLimits>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSLogLimits</returns>
        public new static PARAM_ThingMagicIDSLogLimits  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSLogLimits param = new PARAM_ThingMagicIDSLogLimits();
    
            val = XmlUtil.GetNodeValue(node, "extremeLower");
        
            param.extremeLower = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "lower");
        
            param.lower = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "upper");
        
            param.upper = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "extremeUpper");
        
            param.extremeUpper = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS Start Time paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSStartTime : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSStartTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 108;
        }
      
        public byte seconds=0;
        private Int16 seconds_len=0;
      
        public byte minutes=0;
        private Int16 minutes_len=0;
      
        public byte hours=0;
        private Int16 hours_len=0;
      
        public byte day=0;
        private Int16 day_len=0;
      
        public byte month=0;
        private Int16 month_len=0;
      
        public byte year=0;
        private Int16 year_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSStartTime_Custom_Param custom =
                param as IThingMagicIDSStartTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (seconds != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(seconds, seconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (minutes != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(minutes, minutes_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (hours != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(hours, hours_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (day != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(day, day_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (month != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(month, month_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (year != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(year, year_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSStartTime</returns>
        public new static PARAM_ThingMagicIDSStartTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSStartTime obj = new PARAM_ThingMagicIDSStartTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.seconds = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.minutes = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.hours = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.day = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.month = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.year = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSStartTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (seconds != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "seconds>" + Util.ConvertValueTypeToString(seconds, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "seconds>";
            
	            xml_str += "\r\n";
	        }
        
            if (minutes != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "minutes>" + Util.ConvertValueTypeToString(minutes, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "minutes>";
            
	            xml_str += "\r\n";
	        }
        
            if (hours != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "hours>" + Util.ConvertValueTypeToString(hours, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "hours>";
            
	            xml_str += "\r\n";
	        }
        
            if (day != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "day>" + Util.ConvertValueTypeToString(day, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "day>";
            
	            xml_str += "\r\n";
	        }
        
            if (month != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "month>" + Util.ConvertValueTypeToString(month, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "month>";
            
	            xml_str += "\r\n";
	        }
        
            if (year != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "year>" + Util.ConvertValueTypeToString(year, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "year>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSStartTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSStartTime</returns>
        public new static PARAM_ThingMagicIDSStartTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSStartTime param = new PARAM_ThingMagicIDSStartTime();
    
            val = XmlUtil.GetNodeValue(node, "seconds");
        
            param.seconds = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "minutes");
        
            param.minutes = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "hours");
        
            param.hours = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "day");
        
            param.day = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "month");
        
            param.month = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "year");
        
            param.year = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS SFE paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSFEParam : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSFEParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 109;
        }
      
        public UInt16 raw=0;
        private Int16 raw_len=0;
      
        public byte range=0;
        private Int16 range_len=0;
      
        public byte seti=0;
        private Int16 seti_len=0;
      
        public byte Ext1=0;
        private Int16 Ext1_len=0;
      
        public byte Ext2=0;
        private Int16 Ext2_len=0;
      
        public bool AutoRangeDisable=false;
        private Int16 AutoRangeDisable_len=0;
      
        private const UInt16 param_reserved_len8= 7;
        
        public byte VerifySensorID=0;
        private Int16 VerifySensorID_len=0;
      
        public ENUM_ThingMagicCustomIDSSFEType SFEType;
        private Int16 SFEType_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSFEParam_Custom_Param custom =
                param as IThingMagicIDSSFEParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (raw != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(raw, raw_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (range != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(range, range_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (seti != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(seti, seti_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ext1 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext1, Ext1_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ext2 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ext2, Ext2_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AutoRangeDisable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AutoRangeDisable, AutoRangeDisable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len8;
      
            if (VerifySensorID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(VerifySensorID, VerifySensorID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (SFEType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SFEType, SFEType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSFEParam</returns>
        public new static PARAM_ThingMagicIDSSFEParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSFEParam obj = new PARAM_ThingMagicIDSSFEParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.raw = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.range = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.seti = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Ext1 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Ext2 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.AutoRangeDisable = (bool)obj_val;
          
            cursor += param_reserved_len8;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.VerifySensorID = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.SFEType = (ENUM_ThingMagicCustomIDSSFEType)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSFEParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (raw != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "raw>" + Util.ConvertValueTypeToString(raw, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "raw>";
            
	            xml_str += "\r\n";
	        }
        
            if (range != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "range>" + Util.ConvertValueTypeToString(range, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "range>";
            
	            xml_str += "\r\n";
	        }
        
            if (seti != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "seti>" + Util.ConvertValueTypeToString(seti, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "seti>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ext1 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext1>" + Util.ConvertValueTypeToString(Ext1, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext1>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ext2 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ext2>" + Util.ConvertValueTypeToString(Ext2, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ext2>";
            
	            xml_str += "\r\n";
	        }
        
            if (AutoRangeDisable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AutoRangeDisable>" + Util.ConvertValueTypeToString(AutoRangeDisable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AutoRangeDisable>";
            
	            xml_str += "\r\n";
	        }
        
            if (VerifySensorID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "VerifySensorID>" + Util.ConvertValueTypeToString(VerifySensorID, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "VerifySensorID>";
            
	            xml_str += "\r\n";
	        }
        
            if (SFEType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SFEType>" + SFEType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SFEType>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSFEParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSFEParam</returns>
        public new static PARAM_ThingMagicIDSSFEParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSFEParam param = new PARAM_ThingMagicIDSSFEParam();
    
            val = XmlUtil.GetNodeValue(node, "raw");
        
            param.raw = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "range");
        
            param.range = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "seti");
        
            param.seti = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Ext1");
        
            param.Ext1 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Ext2");
        
            param.Ext2 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "AutoRangeDisable");
        
            param.AutoRangeDisable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "VerifySensorID");
        
            param.VerifySensorID = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "SFEType");
        
            param.SFEType = (ENUM_ThingMagicCustomIDSSFEType)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSSFEType), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter defines the individual fields in IDS Calibration paramter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSCalibrationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSCalibrationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 110;
        }
      
        public UInt64 raw=0;
        private Int16 raw_len=0;
      
        public byte ad1=0;
        private Int16 ad1_len=0;
      
        public byte coars1=0;
        private Int16 coars1_len=0;
      
        public byte ad2=0;
        private Int16 ad2_len=0;
      
        public byte coars2=0;
        private Int16 coars2_len=0;
      
        public bool gndSwitch=false;
        private Int16 gndSwitch_len=0;
      
        private const UInt16 param_reserved_len8= 7;
        
        public byte selp12=0;
        private Int16 selp12_len=0;
      
        public byte adf=0;
        private Int16 adf_len=0;
      
        public byte df=0;
        private Int16 df_len=0;
      
        public bool swExtEn=false;
        private Int16 swExtEn_len=0;
      
        private const UInt16 param_reserved_len13= 7;
        
        public byte selp22=0;
        private Int16 selp22_len=0;
      
        public byte irlev=0;
        private Int16 irlev_len=0;
      
        public byte ringCal=0;
        private Int16 ringCal_len=0;
      
        public byte offInt=0;
        private Int16 offInt_len=0;
      
        public byte reftc=0;
        private Int16 reftc_len=0;
      
        public bool excRes=false;
        private Int16 excRes_len=0;
      
        private const UInt16 param_reserved_len20= 7;
        
        public byte RFU=0;
        private Int16 RFU_len=0;
      
        public byte CalibrationType=0;
        private Int16 CalibrationType_len=0;
      
        public ByteArray calibrationValueByteStream=new ByteArray();
        private Int16 calibrationValueByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSCalibrationData_Custom_Param custom =
                param as IThingMagicIDSCalibrationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (raw != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(raw, raw_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ad1 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ad1, ad1_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (coars1 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(coars1, coars1_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ad2 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ad2, ad2_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (coars2 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(coars2, coars2_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (gndSwitch != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(gndSwitch, gndSwitch_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len8;
      
            if (selp12 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(selp12, selp12_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (adf != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(adf, adf_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (df != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(df, df_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (swExtEn != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(swExtEn, swExtEn_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len13;
      
            if (selp22 != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(selp22, selp22_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (irlev != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(irlev, irlev_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ringCal != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ringCal, ringCal_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (offInt != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(offInt, offInt_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (reftc != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(reftc, reftc_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (excRes != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(excRes, excRes_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len20;
      
            if (RFU != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RFU, RFU_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CalibrationType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CalibrationType, CalibrationType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (calibrationValueByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(calibrationValueByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(calibrationValueByteStream, calibrationValueByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSCalibrationData</returns>
        public new static PARAM_ThingMagicIDSCalibrationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSCalibrationData obj = new PARAM_ThingMagicIDSCalibrationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 64;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            obj.raw = (UInt64)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ad1 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.coars1 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ad2 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.coars2 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.gndSwitch = (bool)obj_val;
          
            cursor += param_reserved_len8;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.selp12 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.adf = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.df = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.swExtEn = (bool)obj_val;
          
            cursor += param_reserved_len13;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.selp22 = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.irlev = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ringCal = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.offInt = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.reftc = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.excRes = (bool)obj_val;
          
            cursor += param_reserved_len20;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.RFU = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.CalibrationType = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.calibrationValueByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSCalibrationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (raw != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "raw>" + Util.ConvertValueTypeToString(raw, "u64", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "raw>";
            
	            xml_str += "\r\n";
	        }
        
            if (ad1 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ad1>" + Util.ConvertValueTypeToString(ad1, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ad1>";
            
	            xml_str += "\r\n";
	        }
        
            if (coars1 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "coars1>" + Util.ConvertValueTypeToString(coars1, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "coars1>";
            
	            xml_str += "\r\n";
	        }
        
            if (ad2 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ad2>" + Util.ConvertValueTypeToString(ad2, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ad2>";
            
	            xml_str += "\r\n";
	        }
        
            if (coars2 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "coars2>" + Util.ConvertValueTypeToString(coars2, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "coars2>";
            
	            xml_str += "\r\n";
	        }
        
            if (gndSwitch != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "gndSwitch>" + Util.ConvertValueTypeToString(gndSwitch, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "gndSwitch>";
            
	            xml_str += "\r\n";
	        }
        
            if (selp12 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "selp12>" + Util.ConvertValueTypeToString(selp12, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "selp12>";
            
	            xml_str += "\r\n";
	        }
        
            if (adf != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "adf>" + Util.ConvertValueTypeToString(adf, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "adf>";
            
	            xml_str += "\r\n";
	        }
        
            if (df != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "df>" + Util.ConvertValueTypeToString(df, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "df>";
            
	            xml_str += "\r\n";
	        }
        
            if (swExtEn != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "swExtEn>" + Util.ConvertValueTypeToString(swExtEn, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "swExtEn>";
            
	            xml_str += "\r\n";
	        }
        
            if (selp22 != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "selp22>" + Util.ConvertValueTypeToString(selp22, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "selp22>";
            
	            xml_str += "\r\n";
	        }
        
            if (irlev != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "irlev>" + Util.ConvertValueTypeToString(irlev, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "irlev>";
            
	            xml_str += "\r\n";
	        }
        
            if (ringCal != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ringCal>" + Util.ConvertValueTypeToString(ringCal, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ringCal>";
            
	            xml_str += "\r\n";
	        }
        
            if (offInt != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "offInt>" + Util.ConvertValueTypeToString(offInt, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "offInt>";
            
	            xml_str += "\r\n";
	        }
        
            if (reftc != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "reftc>" + Util.ConvertValueTypeToString(reftc, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "reftc>";
            
	            xml_str += "\r\n";
	        }
        
            if (excRes != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "excRes>" + Util.ConvertValueTypeToString(excRes, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "excRes>";
            
	            xml_str += "\r\n";
	        }
        
            if (RFU != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RFU>" + Util.ConvertValueTypeToString(RFU, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "RFU>";
            
	            xml_str += "\r\n";
	        }
        
            if (CalibrationType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CalibrationType>" + Util.ConvertValueTypeToString(CalibrationType, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CalibrationType>";
            
	            xml_str += "\r\n";
	        }
        
            if (calibrationValueByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "calibrationValueByteStream>" + Util.ConvertArrayTypeToString(calibrationValueByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "calibrationValueByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSCalibrationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSCalibrationData</returns>
        public new static PARAM_ThingMagicIDSCalibrationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSCalibrationData param = new PARAM_ThingMagicIDSCalibrationData();
    
            val = XmlUtil.GetNodeValue(node, "raw");
        
            param.raw = (UInt64)(Util.ParseValueTypeFromString(val, "u64", ""));
          
            val = XmlUtil.GetNodeValue(node, "ad1");
        
            param.ad1 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "coars1");
        
            param.coars1 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "ad2");
        
            param.ad2 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "coars2");
        
            param.coars2 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "gndSwitch");
        
            param.gndSwitch = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "selp12");
        
            param.selp12 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "adf");
        
            param.adf = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "df");
        
            param.df = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "swExtEn");
        
            param.swExtEn = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "selp22");
        
            param.selp22 = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "irlev");
        
            param.irlev = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "ringCal");
        
            param.ringCal = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "offInt");
        
            param.offInt = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "reftc");
        
            param.reftc = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "excRes");
        
            param.excRes = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "RFU");
        
            param.RFU = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "CalibrationType");
        
            param.CalibrationType = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "calibrationValueByteStream");
        
            param.calibrationValueByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Access FIFO Read command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFORead : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFORead()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 111;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public byte FIFOReadLength=0;
        private Int16 FIFOReadLength_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFORead_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFORead_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (FIFOReadLength != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FIFOReadLength, FIFOReadLength_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFORead</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFORead FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFORead obj = new PARAM_ThingMagicIDSSL900AAccessFIFORead();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.FIFOReadLength = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFORead";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (FIFOReadLength != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "FIFOReadLength>" + Util.ConvertValueTypeToString(FIFOReadLength, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "FIFOReadLength>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFORead>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFORead</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFORead  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFORead param = new PARAM_ThingMagicIDSSL900AAccessFIFORead();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "FIFOReadLength");
        
            param.FIFOReadLength = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the custom IDS Access FIFO Read Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 112;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray readPayLoad=new ByteArray();
        private Int16 readPayLoad_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFOReadOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFOReadOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (readPayLoad != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(readPayLoad.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(readPayLoad, readPayLoad_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult obj = new PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.readPayLoad = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFOReadOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (readPayLoad != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "readPayLoad>" + Util.ConvertArrayTypeToString(readPayLoad, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "readPayLoad>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFOReadOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult param = new PARAM_ThingMagicIDSSL900AAccessFIFOReadOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "readPayLoad");
        
            param.readPayLoad = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Access FIFO write command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFOWrite : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFOWrite()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 113;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public ByteArray writePayLoad=new ByteArray();
        private Int16 writePayLoad_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFOWrite_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFOWrite_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (writePayLoad != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(writePayLoad.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(writePayLoad, writePayLoad_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOWrite</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOWrite FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFOWrite obj = new PARAM_ThingMagicIDSSL900AAccessFIFOWrite();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.writePayLoad = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFOWrite";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (writePayLoad != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "writePayLoad>" + Util.ConvertArrayTypeToString(writePayLoad, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "writePayLoad>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFOWrite>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOWrite</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOWrite  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFOWrite param = new PARAM_ThingMagicIDSSL900AAccessFIFOWrite();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "writePayLoad");
        
            param.writePayLoad = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the custom IDS Access FIFO Write Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 114;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900AAccessFIFOWriteOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900AAccessFIFOWriteOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult obj = new PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult param = new PARAM_ThingMagicIDSSL900AAccessFIFOWriteOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Set Log Limits command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetLogLimits : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetLogLimits()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 115;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public PARAM_ThingMagicIDSLogLimits ThingMagicIDSLogLimits;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetLogLimits_Custom_Param custom =
                param as IThingMagicIDSSL900ASetLogLimits_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSLogLimits != null)
            {
        ThingMagicIDSLogLimits.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogLimits</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogLimits FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetLogLimits obj = new PARAM_ThingMagicIDSSL900ASetLogLimits();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSLogLimits = PARAM_ThingMagicIDSLogLimits.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetLogLimits";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (ThingMagicIDSLogLimits != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSLogLimits.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetLogLimits>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogLimits</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogLimits  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetLogLimits param = new PARAM_ThingMagicIDSSL900ASetLogLimits();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSLogLimits", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSLogLimits = PARAM_ThingMagicIDSLogLimits.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest", "ThingMagicIDSLogLimits",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the custom IDS Set Log Limits Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 116;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetLogLimitsOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASetLogLimitsOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetLogLimitsOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetLogLimitsOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult param = new PARAM_ThingMagicIDSSL900ASetLogLimitsOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom IDS Set Password command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetIDSPassword : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetIDSPassword()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 117;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public ENUM_ThingMagicCustomIDSPasswordLevel NewPasswordLevel;
        private Int16 NewPasswordLevel_len = 8;
        public UInt32 NewIDSPassword=0;
        private Int16 NewIDSPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetIDSPassword_Custom_Param custom =
                param as IThingMagicIDSSL900ASetIDSPassword_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (NewPasswordLevel != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NewPasswordLevel, NewPasswordLevel_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NewIDSPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NewIDSPassword, NewIDSPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetIDSPassword</returns>
        public new static PARAM_ThingMagicIDSSL900ASetIDSPassword FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetIDSPassword obj = new PARAM_ThingMagicIDSSL900ASetIDSPassword();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.NewPasswordLevel = (ENUM_ThingMagicCustomIDSPasswordLevel)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.NewIDSPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetIDSPassword";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (NewPasswordLevel != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NewPasswordLevel>" + NewPasswordLevel.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NewPasswordLevel>";
            
	            xml_str += "\r\n";
	        }
        
            if (NewIDSPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NewIDSPassword>" + Util.ConvertValueTypeToString(NewIDSPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "NewIDSPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetIDSPassword>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetIDSPassword</returns>
        public new static PARAM_ThingMagicIDSSL900ASetIDSPassword  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetIDSPassword param = new PARAM_ThingMagicIDSSL900ASetIDSPassword();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "NewPasswordLevel");
        
            param.NewPasswordLevel = (ENUM_ThingMagicCustomIDSPasswordLevel)Enum.Parse(typeof(ENUM_ThingMagicCustomIDSPasswordLevel), val);
          
            val = XmlUtil.GetNodeValue(node, "NewIDSPassword");
        
            param.NewIDSPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the custom IDS SetPassword Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 118;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSL900ASetPasswordOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSL900ASetPasswordOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult obj = new PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSL900ASetPasswordOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSL900ASetPasswordOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult param = new PARAM_ThingMagicIDSSL900ASetPasswordOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in Battery Level .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSBatteryLevel : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSBatteryLevel()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 120;
        }
      
        public UInt16 reply=0;
        private Int16 reply_len=0;
      
        public bool ADError=false;
        private Int16 ADError_len=0;
      
        private const UInt16 param_reserved_len4= 7;
        
        public byte batteryType=0;
        private Int16 batteryType_len=0;
      
        public UInt16 batteryValue=0;
        private Int16 batteryValue_len=0;
      
        public ByteArray batteryValueByteStream=new ByteArray();
        private Int16 batteryValueByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSBatteryLevel_Custom_Param custom =
                param as IThingMagicIDSBatteryLevel_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (reply != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(reply, reply_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ADError != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ADError, ADError_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len4;
      
            if (batteryType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(batteryType, batteryType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (batteryValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(batteryValue, batteryValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (batteryValueByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(batteryValueByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(batteryValueByteStream, batteryValueByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSBatteryLevel</returns>
        public new static PARAM_ThingMagicIDSBatteryLevel FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSBatteryLevel obj = new PARAM_ThingMagicIDSBatteryLevel();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.reply = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ADError = (bool)obj_val;
          
            cursor += param_reserved_len4;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.batteryType = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.batteryValue = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.batteryValueByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSBatteryLevel";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (reply != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "reply>" + Util.ConvertValueTypeToString(reply, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "reply>";
            
	            xml_str += "\r\n";
	        }
        
            if (ADError != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ADError>" + Util.ConvertValueTypeToString(ADError, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ADError>";
            
	            xml_str += "\r\n";
	        }
        
            if (batteryType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "batteryType>" + Util.ConvertValueTypeToString(batteryType, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "batteryType>";
            
	            xml_str += "\r\n";
	        }
        
            if (batteryValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "batteryValue>" + Util.ConvertValueTypeToString(batteryValue, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "batteryValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (batteryValueByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "batteryValueByteStream>" + Util.ConvertArrayTypeToString(batteryValueByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "batteryValueByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSBatteryLevel>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSBatteryLevel</returns>
        public new static PARAM_ThingMagicIDSBatteryLevel  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSBatteryLevel param = new PARAM_ThingMagicIDSBatteryLevel();
    
            val = XmlUtil.GetNodeValue(node, "reply");
        
            param.reply = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ADError");
        
            param.ADError = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "batteryType");
        
            param.batteryType = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "batteryValue");
        
            param.batteryValue = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "batteryValueByteStream");
        
            param.batteryValueByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for Set Shelf life IDS custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSetShelfLife : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSetShelfLife()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 121;
        }
      
        public PARAM_ThingMagicIDSSL900ACommandRequest ThingMagicIDSSL900ACommandRequest;
                
        public PARAM_ThingMagicIDSSLBlock0 ThingMagicIDSSLBlock0;
                
        public PARAM_ThingMagicIDSSLBlock1 ThingMagicIDSSLBlock1;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSetShelfLife_Custom_Param custom =
                param as IThingMagicIDSSetShelfLife_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
        ThingMagicIDSSL900ACommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSSLBlock0 != null)
            {
        ThingMagicIDSSLBlock0.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicIDSSLBlock1 != null)
            {
        ThingMagicIDSSLBlock1.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSetShelfLife</returns>
        public new static PARAM_ThingMagicIDSSetShelfLife FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSetShelfLife obj = new PARAM_ThingMagicIDSSetShelfLife();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSSLBlock0 = PARAM_ThingMagicIDSSLBlock0.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicIDSSLBlock1 = PARAM_ThingMagicIDSSLBlock1.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSetShelfLife";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicIDSSL900ACommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSL900ACommandRequest.ToString());
            
            }
        
            if (ThingMagicIDSSLBlock0 != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSLBlock0.ToString());
            
            }
        
            if (ThingMagicIDSSLBlock1 != null)
            {
          
                xml_str += Util.Indent(ThingMagicIDSSLBlock1.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSetShelfLife>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSetShelfLife</returns>
        public new static PARAM_ThingMagicIDSSetShelfLife  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSetShelfLife param = new PARAM_ThingMagicIDSSetShelfLife();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSL900ACommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSL900ACommandRequest = PARAM_ThingMagicIDSSL900ACommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSLBlock0", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSLBlock0 = PARAM_ThingMagicIDSSLBlock0.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicIDSSLBlock1", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicIDSSLBlock1 = PARAM_ThingMagicIDSSLBlock1.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicIDSSL900ACommandRequest", "ThingMagicIDSSLBlock0", "ThingMagicIDSSLBlock1",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the Shelf life block 0 custom parameter .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSLBlock0 : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSLBlock0()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 122;
        }
      
        public UInt32 raw=0;
        private Int16 raw_len=0;
      
        public byte TimeMax=0;
        private Int16 TimeMax_len=0;
      
        public byte TimeMin=0;
        private Int16 TimeMin_len=0;
      
        public byte TimeStd=0;
        private Int16 TimeStd_len=0;
      
        public byte Ea=0;
        private Int16 Ea_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSLBlock0_Custom_Param custom =
                param as IThingMagicIDSSLBlock0_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (raw != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(raw, raw_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TimeMax != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TimeMax, TimeMax_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TimeMin != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TimeMin, TimeMin_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TimeStd != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TimeStd, TimeStd_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Ea != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Ea, Ea_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSLBlock0</returns>
        public new static PARAM_ThingMagicIDSSLBlock0 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSLBlock0 obj = new PARAM_ThingMagicIDSSLBlock0();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.raw = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.TimeMax = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.TimeMin = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.TimeStd = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Ea = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSLBlock0";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (raw != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "raw>" + Util.ConvertValueTypeToString(raw, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "raw>";
            
	            xml_str += "\r\n";
	        }
        
            if (TimeMax != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TimeMax>" + Util.ConvertValueTypeToString(TimeMax, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TimeMax>";
            
	            xml_str += "\r\n";
	        }
        
            if (TimeMin != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TimeMin>" + Util.ConvertValueTypeToString(TimeMin, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TimeMin>";
            
	            xml_str += "\r\n";
	        }
        
            if (TimeStd != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TimeStd>" + Util.ConvertValueTypeToString(TimeStd, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TimeStd>";
            
	            xml_str += "\r\n";
	        }
        
            if (Ea != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Ea>" + Util.ConvertValueTypeToString(Ea, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Ea>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSLBlock0>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSLBlock0</returns>
        public new static PARAM_ThingMagicIDSSLBlock0  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSLBlock0 param = new PARAM_ThingMagicIDSSLBlock0();
    
            val = XmlUtil.GetNodeValue(node, "raw");
        
            param.raw = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "TimeMax");
        
            param.TimeMax = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "TimeMin");
        
            param.TimeMin = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "TimeStd");
        
            param.TimeStd = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Ea");
        
            param.Ea = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the Shelf life blok 1 custom parameter
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSLBlock1 : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSLBlock1()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 123;
        }
      
        public UInt32 raw=0;
        private Int16 raw_len=0;
      
        public UInt16 SLInit=0;
        private Int16 SLInit_len=0;
      
        public UInt16 TInit=0;
        private Int16 TInit_len=0;
      
        public byte SensorID=0;
        private Int16 SensorID_len=0;
      
        public bool enableNegative=false;
        private Int16 enableNegative_len=0;
      
        public bool algorithmEnable=false;
        private Int16 algorithmEnable_len=0;
      
        private const UInt16 param_reserved_len8= 6;
        
        public byte RFU=0;
        private Int16 RFU_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSLBlock1_Custom_Param custom =
                param as IThingMagicIDSSLBlock1_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (raw != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(raw, raw_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (SLInit != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SLInit, SLInit_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TInit != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TInit, TInit_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (SensorID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SensorID, SensorID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (enableNegative != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(enableNegative, enableNegative_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (algorithmEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(algorithmEnable, algorithmEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len8;
      
            if (RFU != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RFU, RFU_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSLBlock1</returns>
        public new static PARAM_ThingMagicIDSSLBlock1 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSLBlock1 obj = new PARAM_ThingMagicIDSSLBlock1();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.raw = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.SLInit = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.TInit = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.SensorID = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.enableNegative = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.algorithmEnable = (bool)obj_val;
          
            cursor += param_reserved_len8;
      
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.RFU = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSLBlock1";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (raw != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "raw>" + Util.ConvertValueTypeToString(raw, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "raw>";
            
	            xml_str += "\r\n";
	        }
        
            if (SLInit != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SLInit>" + Util.ConvertValueTypeToString(SLInit, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "SLInit>";
            
	            xml_str += "\r\n";
	        }
        
            if (TInit != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TInit>" + Util.ConvertValueTypeToString(TInit, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TInit>";
            
	            xml_str += "\r\n";
	        }
        
            if (SensorID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "SensorID>" + Util.ConvertValueTypeToString(SensorID, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "SensorID>";
            
	            xml_str += "\r\n";
	        }
        
            if (enableNegative != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "enableNegative>" + Util.ConvertValueTypeToString(enableNegative, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "enableNegative>";
            
	            xml_str += "\r\n";
	        }
        
            if (algorithmEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "algorithmEnable>" + Util.ConvertValueTypeToString(algorithmEnable, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "algorithmEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (RFU != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "RFU>" + Util.ConvertValueTypeToString(RFU, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "RFU>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSLBlock1>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSLBlock1</returns>
        public new static PARAM_ThingMagicIDSSLBlock1  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSLBlock1 param = new PARAM_ThingMagicIDSSLBlock1();
    
            val = XmlUtil.GetNodeValue(node, "raw");
        
            param.raw = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "SLInit");
        
            param.SLInit = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "TInit");
        
            param.TInit = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "SensorID");
        
            param.SensorID = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "enableNegative");
        
            param.enableNegative = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "algorithmEnable");
        
            param.algorithmEnable = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "RFU");
        
            param.RFU = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in Set Shelf life IDS command response parameter .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicIDSSetShelfLifeOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicIDSSetShelfLifeOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 124;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicIDSSetShelfLifeOpSpecResult_Custom_Param custom =
                param as IThingMagicIDSSetShelfLifeOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicIDSSetShelfLifeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSetShelfLifeOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicIDSSetShelfLifeOpSpecResult obj = new PARAM_ThingMagicIDSSetShelfLifeOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicIDSSetShelfLifeOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicIDSSetShelfLifeOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicIDSSetShelfLifeOpSpecResult</returns>
        public new static PARAM_ThingMagicIDSSetShelfLifeOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicIDSSetShelfLifeOpSpecResult param = new PARAM_ThingMagicIDSSetShelfLifeOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic Hop Time parameter 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicHopTime : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicHopTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 125;
        }
      
        public UInt32 HopTime=0;
        private Int16 HopTime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicHopTime_Custom_Param custom =
                param as IThingMagicHopTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (HopTime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HopTime, HopTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicHopTime</returns>
        public new static PARAM_ThingMagicHopTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicHopTime obj = new PARAM_ThingMagicHopTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.HopTime = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicHopTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (HopTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "HopTime>" + Util.ConvertValueTypeToString(HopTime, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "HopTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicHopTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicHopTime</returns>
        public new static PARAM_ThingMagicHopTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicHopTime param = new PARAM_ThingMagicHopTime();
    
            val = XmlUtil.GetNodeValue(node, "HopTime");
        
            param.HopTime = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for Activate Secure Mode Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVActivateSecureMode : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVActivateSecureMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 126;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVActivateSecureMode_Custom_Param custom =
                param as IThingMagicDenatranIAVActivateSecureMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSecureMode</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSecureMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVActivateSecureMode obj = new PARAM_ThingMagicDenatranIAVActivateSecureMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVActivateSecureMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVActivateSecureMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSecureMode</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSecureMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVActivateSecureMode param = new PARAM_ThingMagicDenatranIAVActivateSecureMode();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the Activate Secure Mode Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 127;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray ActivateSecureModeByteStream=new ByteArray();
        private Int16 ActivateSecureModeByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVActivateSecureModeOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVActivateSecureModeOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ActivateSecureModeByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ActivateSecureModeByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ActivateSecureModeByteStream, ActivateSecureModeByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult obj = new PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.ActivateSecureModeByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVActivateSecureModeOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ActivateSecureModeByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ActivateSecureModeByteStream>" + Util.ConvertArrayTypeToString(ActivateSecureModeByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ActivateSecureModeByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVActivateSecureModeOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult param = new PARAM_ThingMagicDenatranIAVActivateSecureModeOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ActivateSecureModeByteStream");
        
            param.ActivateSecureModeByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for Authenticate OBU Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVAuthenticateOBU : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVAuthenticateOBU()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 128;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVAuthenticateOBU_Custom_Param custom =
                param as IThingMagicDenatranIAVAuthenticateOBU_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVAuthenticateOBU</returns>
        public new static PARAM_ThingMagicDenatranIAVAuthenticateOBU FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVAuthenticateOBU obj = new PARAM_ThingMagicDenatranIAVAuthenticateOBU();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVAuthenticateOBU";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVAuthenticateOBU>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVAuthenticateOBU</returns>
        public new static PARAM_ThingMagicDenatranIAVAuthenticateOBU  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVAuthenticateOBU param = new PARAM_ThingMagicDenatranIAVAuthenticateOBU();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the Authenticate OBU Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 129;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray AuthenitcateOBUByteStream=new ByteArray();
        private Int16 AuthenitcateOBUByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVAuthenticateOBUOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVAuthenticateOBUOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AuthenitcateOBUByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(AuthenitcateOBUByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(AuthenitcateOBUByteStream, AuthenitcateOBUByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult obj = new PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.AuthenitcateOBUByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVAuthenticateOBUOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AuthenitcateOBUByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AuthenitcateOBUByteStream>" + Util.ConvertArrayTypeToString(AuthenitcateOBUByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AuthenitcateOBUByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVAuthenticateOBUOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult param = new PARAM_ThingMagicDenatranIAVAuthenticateOBUOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AuthenitcateOBUByteStream");
        
            param.AuthenitcateOBUByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for Activate Siniav mode Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVActivateSiniavMode : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVActivateSiniavMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 130;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public ByteArray tokenData=new ByteArray();
        private Int16 tokenData_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVActivateSiniavMode_Custom_Param custom =
                param as IThingMagicDenatranIAVActivateSiniavMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (tokenData != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(tokenData.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(tokenData, tokenData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSiniavMode</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSiniavMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVActivateSiniavMode obj = new PARAM_ThingMagicDenatranIAVActivateSiniavMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.tokenData = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVActivateSiniavMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (tokenData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "tokenData>" + Util.ConvertArrayTypeToString(tokenData, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "tokenData>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVActivateSiniavMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSiniavMode</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSiniavMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVActivateSiniavMode param = new PARAM_ThingMagicDenatranIAVActivateSiniavMode();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "tokenData");
        
            param.tokenData = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the Activate Siniav Mode Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 131;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray ActivateSiniavModeByteStream=new ByteArray();
        private Int16 ActivateSiniavModeByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVActivateSiniavModeOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVActivateSiniavModeOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ActivateSiniavModeByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ActivateSiniavModeByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ActivateSiniavModeByteStream, ActivateSiniavModeByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult obj = new PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.ActivateSiniavModeByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVActivateSiniavModeOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (ActivateSiniavModeByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ActivateSiniavModeByteStream>" + Util.ConvertArrayTypeToString(ActivateSiniavModeByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ActivateSiniavModeByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVActivateSiniavModeOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult param = new PARAM_ThingMagicDenatranIAVActivateSiniavModeOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ActivateSiniavModeByteStream");
        
            param.ActivateSiniavModeByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for OBU Authenticate ID Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateID : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateID()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 132;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateID_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateID_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateID</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateID obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateID();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateID";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateID>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateID</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateID  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateID param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateID();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the OBU Authenticate ID Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 133;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray OBUAuthenticateIDByteStream=new ByteArray();
        private Int16 OBUAuthenticateIDByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OBUAuthenticateIDByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(OBUAuthenticateIDByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(OBUAuthenticateIDByteStream, OBUAuthenticateIDByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.OBUAuthenticateIDByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (OBUAuthenticateIDByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateIDByteStream>" + Util.ConvertArrayTypeToString(OBUAuthenticateIDByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateIDByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateIDOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "OBUAuthenticateIDByteStream");
        
            param.OBUAuthenticateIDByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for OBU Authenticate Full Pass 1 Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1 : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 134;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateFullPass1_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateFullPass1_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1 obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateFullPass1";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateFullPass1>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1 param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the OBU Authenticate Full Pass 1 Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 135;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray OBUAuthenticateFullPass1ByteStream=new ByteArray();
        private Int16 OBUAuthenticateFullPass1ByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OBUAuthenticateFullPass1ByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(OBUAuthenticateFullPass1ByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(OBUAuthenticateFullPass1ByteStream, OBUAuthenticateFullPass1ByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.OBUAuthenticateFullPass1ByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (OBUAuthenticateFullPass1ByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateFullPass1ByteStream>" + Util.ConvertArrayTypeToString(OBUAuthenticateFullPass1ByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateFullPass1ByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass1OpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "OBUAuthenticateFullPass1ByteStream");
        
            param.OBUAuthenticateFullPass1ByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for OBU Authenticate Full Pass 2 Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2 : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 136;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateFullPass2_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateFullPass2_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2 obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateFullPass2";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateFullPass2>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2 param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the OBU Authenticate Full Pass 2 Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 137;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray OBUAuthenticateFullPass2ByteStream=new ByteArray();
        private Int16 OBUAuthenticateFullPass2ByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OBUAuthenticateFullPass2ByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(OBUAuthenticateFullPass2ByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(OBUAuthenticateFullPass2ByteStream, OBUAuthenticateFullPass2ByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult obj = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.OBUAuthenticateFullPass2ByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (OBUAuthenticateFullPass2ByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateFullPass2ByteStream>" + Util.ConvertArrayTypeToString(OBUAuthenticateFullPass2ByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUAuthenticateFullPass2ByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult param = new PARAM_ThingMagicDenatranIAVOBUAuthenticateFullPass2OpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "OBUAuthenticateFullPass2ByteStream");
        
            param.OBUAuthenticateFullPass2ByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for OBU Read From Memory Map Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUReadFromMemMap : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUReadFromMemMap()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 138;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public UInt16 ReadPtr=0;
        private Int16 ReadPtr_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUReadFromMemMap_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUReadFromMemMap_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ReadPtr != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReadPtr, ReadPtr_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUReadFromMemMap</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUReadFromMemMap FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUReadFromMemMap obj = new PARAM_ThingMagicDenatranIAVOBUReadFromMemMap();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.ReadPtr = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUReadFromMemMap";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (ReadPtr != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReadPtr>" + Util.ConvertValueTypeToString(ReadPtr, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ReadPtr>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUReadFromMemMap>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUReadFromMemMap</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUReadFromMemMap  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUReadFromMemMap param = new PARAM_ThingMagicDenatranIAVOBUReadFromMemMap();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "ReadPtr");
        
            param.ReadPtr = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the OBU Read From Memory Map Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 139;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray OBUReadMemoryMapByteStream=new ByteArray();
        private Int16 OBUReadMemoryMapByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OBUReadMemoryMapByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(OBUReadMemoryMapByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(OBUReadMemoryMapByteStream, OBUReadMemoryMapByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult obj = new PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.OBUReadMemoryMapByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (OBUReadMemoryMapByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUReadMemoryMapByteStream>" + Util.ConvertArrayTypeToString(OBUReadMemoryMapByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUReadMemoryMapByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult param = new PARAM_ThingMagicDenatranIAVOBUReadFromMemMapOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "OBUReadMemoryMapByteStream");
        
            param.OBUReadMemoryMapByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for OBU Write To Memory Map Denatran IAV custom opspec command .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUWriteToMemMap : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUWriteToMemMap()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 140;
        }
      
        public PARAM_ThingMagicDenatranIAVCommandRequest ThingMagicDenatranIAVCommandRequest;
                
        public UInt16 WritePtr=0;
        private Int16 WritePtr_len=0;
      
        public UInt16 WordData=0;
        private Int16 WordData_len=0;
      
        public ByteArray TagIdentification=new ByteArray();
        private Int16 TagIdentification_len=0;
      
        public ByteArray DataBuf=new ByteArray();
        private Int16 DataBuf_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUWriteToMemMap_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUWriteToMemMap_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
        ThingMagicDenatranIAVCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (WritePtr != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WritePtr, WritePtr_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (WordData != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordData, WordData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagIdentification != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(TagIdentification.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(TagIdentification, TagIdentification_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (DataBuf != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(DataBuf.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(DataBuf, DataBuf_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUWriteToMemMap</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUWriteToMemMap FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUWriteToMemMap obj = new PARAM_ThingMagicDenatranIAVOBUWriteToMemMap();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.WritePtr = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.WordData = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.TagIdentification = (ByteArray)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.DataBuf = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUWriteToMemMap";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicDenatranIAVCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicDenatranIAVCommandRequest.ToString());
            
            }
        
            if (WritePtr != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WritePtr>" + Util.ConvertValueTypeToString(WritePtr, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "WritePtr>";
            
	            xml_str += "\r\n";
	        }
        
            if (WordData != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WordData>" + Util.ConvertValueTypeToString(WordData, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "WordData>";
            
	            xml_str += "\r\n";
	        }
        
            if (TagIdentification != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagIdentification>" + Util.ConvertArrayTypeToString(TagIdentification, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagIdentification>";
            
	            xml_str += "\r\n";
	        }
        
            if (DataBuf != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DataBuf>" + Util.ConvertArrayTypeToString(DataBuf, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "DataBuf>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUWriteToMemMap>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUWriteToMemMap</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUWriteToMemMap  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUWriteToMemMap param = new PARAM_ThingMagicDenatranIAVOBUWriteToMemMap();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicDenatranIAVCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicDenatranIAVCommandRequest = PARAM_ThingMagicDenatranIAVCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            val = XmlUtil.GetNodeValue(node, "WritePtr");
        
            param.WritePtr = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "WordData");
        
            param.WordData = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "TagIdentification");
        
            param.TagIdentification = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            val = XmlUtil.GetNodeValue(node, "DataBuf");
        
            param.DataBuf = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] { "ThingMagicDenatranIAVCommandRequest",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields in the OBU Write To Memory Map Denatran IAV custom Opspec result.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 141;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray OBUWriteMemoryMapByteStream=new ByteArray();
        private Int16 OBUWriteMemoryMapByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult_Custom_Param custom =
                param as IThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OBUWriteMemoryMapByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(OBUWriteMemoryMapByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(OBUWriteMemoryMapByteStream, OBUWriteMemoryMapByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult obj = new PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.OBUWriteMemoryMapByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (OBUWriteMemoryMapByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUWriteMemoryMapByteStream>" + Util.ConvertArrayTypeToString(OBUWriteMemoryMapByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OBUWriteMemoryMapByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult</returns>
        public new static PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult param = new PARAM_ThingMagicDenatranIAVOBUWriteToMemMapOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "OBUWriteMemoryMapByteStream");
        
            param.OBUWriteMemoryMapByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom Denatran IAV request command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicDenatranIAVCommandRequest : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicDenatranIAVCommandRequest()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 201;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public byte PayLoad=0;
        private Int16 PayLoad_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicDenatranIAVCommandRequest_Custom_Param custom =
                param as IThingMagicDenatranIAVCommandRequest_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PayLoad != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PayLoad, PayLoad_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicDenatranIAVCommandRequest</returns>
        public new static PARAM_ThingMagicDenatranIAVCommandRequest FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicDenatranIAVCommandRequest obj = new PARAM_ThingMagicDenatranIAVCommandRequest();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.PayLoad = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicDenatranIAVCommandRequest";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (PayLoad != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PayLoad>" + Util.ConvertValueTypeToString(PayLoad, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "PayLoad>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicDenatranIAVCommandRequest>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicDenatranIAVCommandRequest</returns>
        public new static PARAM_ThingMagicDenatranIAVCommandRequest  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicDenatranIAVCommandRequest param = new PARAM_ThingMagicDenatranIAVCommandRequest();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "PayLoad");
        
            param.PayLoad = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures additional parameters to be reported via the TagReportData parameter.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicTagReportContentSelector : PARAM_Custom,IROReportSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicTagReportContentSelector()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 142;
        }
      
        public ENUM_ThingMagicPhaseMode PhaseMode;
        private Int16 PhaseMode_len = 8;
        public PARAM_MetadataGPIOMode MetadataGPIOMode;
                
        public PARAM_MetadataGen2QMode MetadataGen2QMode;
                
        public PARAM_MetadataGen2LFMode MetadataGen2LFMode;
                
        public PARAM_MetadataGen2TargetMode MetadataGen2TargetMode;
                
        public PARAM_MetadataDataMode MetadataDataMode;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicTagReportContentSelector_Custom_Param custom =
                param as IThingMagicTagReportContentSelector_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (PhaseMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PhaseMode, PhaseMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (MetadataGPIOMode != null)
            {
        MetadataGPIOMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (MetadataGen2QMode != null)
            {
        MetadataGen2QMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (MetadataGen2LFMode != null)
            {
        MetadataGen2LFMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (MetadataGen2TargetMode != null)
            {
        MetadataGen2TargetMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (MetadataDataMode != null)
            {
        MetadataDataMode.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicTagReportContentSelector</returns>
        public new static PARAM_ThingMagicTagReportContentSelector FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicTagReportContentSelector obj = new PARAM_ThingMagicTagReportContentSelector();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.PhaseMode = (ENUM_ThingMagicPhaseMode)(UInt32)obj_val;
          
            obj.MetadataGPIOMode = PARAM_MetadataGPIOMode.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.MetadataGen2QMode = PARAM_MetadataGen2QMode.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.MetadataGen2LFMode = PARAM_MetadataGen2LFMode.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.MetadataGen2TargetMode = PARAM_MetadataGen2TargetMode.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.MetadataDataMode = PARAM_MetadataDataMode.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicTagReportContentSelector";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (PhaseMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PhaseMode>" + PhaseMode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PhaseMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (MetadataGPIOMode != null)
            {
          
                xml_str += Util.Indent(MetadataGPIOMode.ToString());
            
            }
        
            if (MetadataGen2QMode != null)
            {
          
                xml_str += Util.Indent(MetadataGen2QMode.ToString());
            
            }
        
            if (MetadataGen2LFMode != null)
            {
          
                xml_str += Util.Indent(MetadataGen2LFMode.ToString());
            
            }
        
            if (MetadataGen2TargetMode != null)
            {
          
                xml_str += Util.Indent(MetadataGen2TargetMode.ToString());
            
            }
        
            if (MetadataDataMode != null)
            {
          
                xml_str += Util.Indent(MetadataDataMode.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicTagReportContentSelector>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicTagReportContentSelector</returns>
        public new static PARAM_ThingMagicTagReportContentSelector  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicTagReportContentSelector param = new PARAM_ThingMagicTagReportContentSelector();
    
            val = XmlUtil.GetNodeValue(node, "PhaseMode");
        
            param.PhaseMode = (ENUM_ThingMagicPhaseMode)Enum.Parse(typeof(ENUM_ThingMagicPhaseMode), val);
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "MetadataGPIOMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.MetadataGPIOMode = PARAM_MetadataGPIOMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "MetadataGen2QMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.MetadataGen2QMode = PARAM_MetadataGen2QMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "MetadataGen2LFMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.MetadataGen2LFMode = PARAM_MetadataGen2LFMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "MetadataGen2TargetMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.MetadataGen2TargetMode = PARAM_MetadataGen2TargetMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "MetadataDataMode", nsmgr);
            if (xnl.Count != 0)
            {
                param.MetadataDataMode = PARAM_MetadataDataMode.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "MetadataGPIOMode", "MetadataGen2QMode", "MetadataGen2LFMode", "MetadataGen2TargetMode", "MetadataDataMode",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures the metadata GPIO flag information.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_MetadataGPIOMode : PARAM_Custom,IThingMagicTagReportContentSelector_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_MetadataGPIOMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 220;
        }
      
        public ENUM_ThingMagicMetadataFlagStatus Mode;
        private Int16 Mode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IMetadataGPIOMode_Custom_Param custom =
                param as IMetadataGPIOMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Mode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mode, Mode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_MetadataGPIOMode</returns>
        public new static PARAM_MetadataGPIOMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_MetadataGPIOMode obj = new PARAM_MetadataGPIOMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Mode = (ENUM_ThingMagicMetadataFlagStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"MetadataGPIOMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Mode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>" + Mode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":MetadataGPIOMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_MetadataGPIOMode</returns>
        public new static PARAM_MetadataGPIOMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_MetadataGPIOMode param = new PARAM_MetadataGPIOMode();
    
            val = XmlUtil.GetNodeValue(node, "Mode");
        
            param.Mode = (ENUM_ThingMagicMetadataFlagStatus)Enum.Parse(typeof(ENUM_ThingMagicMetadataFlagStatus), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures the metadata Gen2Q flag information.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_MetadataGen2QMode : PARAM_Custom,IThingMagicTagReportContentSelector_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_MetadataGen2QMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 221;
        }
      
        public ENUM_ThingMagicMetadataFlagStatus Mode;
        private Int16 Mode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IMetadataGen2QMode_Custom_Param custom =
                param as IMetadataGen2QMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Mode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mode, Mode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_MetadataGen2QMode</returns>
        public new static PARAM_MetadataGen2QMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_MetadataGen2QMode obj = new PARAM_MetadataGen2QMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Mode = (ENUM_ThingMagicMetadataFlagStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"MetadataGen2QMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Mode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>" + Mode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":MetadataGen2QMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_MetadataGen2QMode</returns>
        public new static PARAM_MetadataGen2QMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_MetadataGen2QMode param = new PARAM_MetadataGen2QMode();
    
            val = XmlUtil.GetNodeValue(node, "Mode");
        
            param.Mode = (ENUM_ThingMagicMetadataFlagStatus)Enum.Parse(typeof(ENUM_ThingMagicMetadataFlagStatus), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures the metadata Gen2LF flag information.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_MetadataGen2LFMode : PARAM_Custom,IThingMagicTagReportContentSelector_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_MetadataGen2LFMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 222;
        }
      
        public ENUM_ThingMagicMetadataFlagStatus Mode;
        private Int16 Mode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IMetadataGen2LFMode_Custom_Param custom =
                param as IMetadataGen2LFMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Mode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mode, Mode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_MetadataGen2LFMode</returns>
        public new static PARAM_MetadataGen2LFMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_MetadataGen2LFMode obj = new PARAM_MetadataGen2LFMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Mode = (ENUM_ThingMagicMetadataFlagStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"MetadataGen2LFMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Mode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>" + Mode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":MetadataGen2LFMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_MetadataGen2LFMode</returns>
        public new static PARAM_MetadataGen2LFMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_MetadataGen2LFMode param = new PARAM_MetadataGen2LFMode();
    
            val = XmlUtil.GetNodeValue(node, "Mode");
        
            param.Mode = (ENUM_ThingMagicMetadataFlagStatus)Enum.Parse(typeof(ENUM_ThingMagicMetadataFlagStatus), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures the metadata Gen2 TagetMode flag.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_MetadataGen2TargetMode : PARAM_Custom,IThingMagicTagReportContentSelector_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_MetadataGen2TargetMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 223;
        }
      
        public ENUM_ThingMagicMetadataFlagStatus Mode;
        private Int16 Mode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IMetadataGen2TargetMode_Custom_Param custom =
                param as IMetadataGen2TargetMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Mode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mode, Mode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_MetadataGen2TargetMode</returns>
        public new static PARAM_MetadataGen2TargetMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_MetadataGen2TargetMode obj = new PARAM_MetadataGen2TargetMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Mode = (ENUM_ThingMagicMetadataFlagStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"MetadataGen2TargetMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Mode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>" + Mode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":MetadataGen2TargetMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_MetadataGen2TargetMode</returns>
        public new static PARAM_MetadataGen2TargetMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_MetadataGen2TargetMode param = new PARAM_MetadataGen2TargetMode();
    
            val = XmlUtil.GetNodeValue(node, "Mode");
        
            param.Mode = (ENUM_ThingMagicMetadataFlagStatus)Enum.Parse(typeof(ENUM_ThingMagicMetadataFlagStatus), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures the metadata tagop data information.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_MetadataDataMode : PARAM_Custom,IThingMagicTagReportContentSelector_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_MetadataDataMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 230;
        }
      
        public ENUM_ThingMagicMetadataFlagStatus Mode;
        private Int16 Mode_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IMetadataDataMode_Custom_Param custom =
                param as IMetadataDataMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Mode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Mode, Mode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_MetadataDataMode</returns>
        public new static PARAM_MetadataDataMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_MetadataDataMode obj = new PARAM_MetadataDataMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Mode = (ENUM_ThingMagicMetadataFlagStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"MetadataDataMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Mode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>" + Mode.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Mode>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":MetadataDataMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_MetadataDataMode</returns>
        public new static PARAM_MetadataDataMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_MetadataDataMode param = new PARAM_MetadataDataMode();
    
            val = XmlUtil.GetNodeValue(node, "Mode");
        
            param.Mode = (ENUM_ThingMagicMetadataFlagStatus)Enum.Parse(typeof(ENUM_ThingMagicMetadataFlagStatus), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter reports the RF phase .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicRFPhase : PARAM_Custom,ITagReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicRFPhase()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 143;
        }
      
        public UInt16 Phase=0;
        private Int16 Phase_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicRFPhase_Custom_Param custom =
                param as IThingMagicRFPhase_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Phase != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Phase, Phase_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicRFPhase</returns>
        public new static PARAM_ThingMagicRFPhase FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicRFPhase obj = new PARAM_ThingMagicRFPhase();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.Phase = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicRFPhase";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Phase != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Phase>" + Util.ConvertValueTypeToString(Phase, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Phase>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicRFPhase>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicRFPhase</returns>
        public new static PARAM_ThingMagicRFPhase  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicRFPhase param = new PARAM_ThingMagicRFPhase();
    
            val = XmlUtil.GetNodeValue(node, "Phase");
        
            param.Phase = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom GPIO status details.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicMetadataGPIO : PARAM_Custom,ITagReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicMetadataGPIO()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 224;
        }
      
        public PARAM_GPIOStatus[] GPIOStatus;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicMetadataGPIO_Custom_Param custom =
                param as IThingMagicMetadataGPIO_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (GPIOStatus != null)
            {
        
                len = GPIOStatus.Length;
                for (int i=0; i<len;i++)
                {
                    GPIOStatus[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicMetadataGPIO</returns>
        public new static PARAM_ThingMagicMetadataGPIO FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicMetadataGPIO obj = new PARAM_ThingMagicMetadataGPIO();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            param_list = new ArrayList();
            PARAM_GPIOStatus _param_GPIOStatus;
            while ((_param_GPIOStatus = PARAM_GPIOStatus.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_GPIOStatus);
            }

            if (param_list.Count > 0)
            {
                obj.GPIOStatus = new PARAM_GPIOStatus[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.GPIOStatus[i] = (PARAM_GPIOStatus)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicMetadataGPIO";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (GPIOStatus != null)
            {
          
                len = GPIOStatus.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(GPIOStatus[i].ToString());
                }
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicMetadataGPIO>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicMetadataGPIO</returns>
        public new static PARAM_ThingMagicMetadataGPIO  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicMetadataGPIO param = new PARAM_ThingMagicMetadataGPIO();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIOStatus", nsmgr);
            if (xnl.Count != 0)
            {
                param.GPIOStatus = new PARAM_GPIOStatus[xnl.Count];
                for (int i=0; i<xnl.Count; i++)
                {
                    param.GPIOStatus[i] = PARAM_GPIOStatus.FromXmlNode(xnl[i]);
                }
            }
              
            }
      
            {
        
            string[] excl = new string[] { "GPIOStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific GPIO Status 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_GPIOStatus : PARAM_Custom,IThingMagicMetadataGPIO_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_GPIOStatus()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 225;
        }
      
        public byte id=0;
        private Int16 id_len=0;
      
        public bool Status=false;
        private Int16 Status_len=0;
      
        public bool Direction=false;
        private Int16 Direction_len=0;
      
        private const UInt16 param_reserved_len5= 6;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGPIOStatus_Custom_Param custom =
                param as IGPIOStatus_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (id != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(id, id_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Status != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Status, Status_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Direction != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Direction, Direction_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len5;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_GPIOStatus</returns>
        public new static PARAM_GPIOStatus FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPIOStatus obj = new PARAM_GPIOStatus();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.id = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Status = (bool)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.Direction = (bool)obj_val;
          
            cursor += param_reserved_len5;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"GPIOStatus";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (id != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "id>" + Util.ConvertValueTypeToString(id, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "id>";
            
	            xml_str += "\r\n";
	        }
        
            if (Status != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Status>" + Util.ConvertValueTypeToString(Status, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Status>";
            
	            xml_str += "\r\n";
	        }
        
            if (Direction != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Direction>" + Util.ConvertValueTypeToString(Direction, "u1", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Direction>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":GPIOStatus>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_GPIOStatus</returns>
        public new static PARAM_GPIOStatus  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_GPIOStatus param = new PARAM_GPIOStatus();
    
            val = XmlUtil.GetNodeValue(node, "id");
        
            param.id = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Status");
        
            param.Status = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            val = XmlUtil.GetNodeValue(node, "Direction");
        
            param.Direction = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom Gen2Q Value.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicMetadataGen2 : PARAM_Custom,ITagReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicMetadataGen2()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 226;
        }
      
        public PARAM_Gen2QResponse Gen2QResponse;
                
        public PARAM_Gen2LFResponse Gen2LFResponse;
                
        public PARAM_Gen2TargetResponse Gen2TargetResponse;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicMetadataGen2_Custom_Param custom =
                param as IThingMagicMetadataGen2_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Gen2QResponse != null)
            {
        Gen2QResponse.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Gen2LFResponse != null)
            {
        Gen2LFResponse.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Gen2TargetResponse != null)
            {
        Gen2TargetResponse.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicMetadataGen2</returns>
        public new static PARAM_ThingMagicMetadataGen2 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicMetadataGen2 obj = new PARAM_ThingMagicMetadataGen2();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.Gen2QResponse = PARAM_Gen2QResponse.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.Gen2LFResponse = PARAM_Gen2LFResponse.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.Gen2TargetResponse = PARAM_Gen2TargetResponse.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicMetadataGen2";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Gen2QResponse != null)
            {
          
                xml_str += Util.Indent(Gen2QResponse.ToString());
            
            }
        
            if (Gen2LFResponse != null)
            {
          
                xml_str += Util.Indent(Gen2LFResponse.ToString());
            
            }
        
            if (Gen2TargetResponse != null)
            {
          
                xml_str += Util.Indent(Gen2TargetResponse.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicMetadataGen2>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicMetadataGen2</returns>
        public new static PARAM_ThingMagicMetadataGen2  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicMetadataGen2 param = new PARAM_ThingMagicMetadataGen2();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2QResponse", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2QResponse = PARAM_Gen2QResponse.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2LFResponse", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2LFResponse = PARAM_Gen2LFResponse.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Gen2TargetResponse", nsmgr);
            if (xnl.Count != 0)
            {
                param.Gen2TargetResponse = PARAM_Gen2TargetResponse.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "Gen2QResponse", "Gen2LFResponse", "Gen2TargetResponse",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom Gen2Q Value.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2QResponse : PARAM_Custom,IThingMagicMetadataGen2_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2QResponse()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 227;
        }
      
        public byte QValue=0;
        private Int16 QValue_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2QResponse_Custom_Param custom =
                param as IGen2QResponse_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (QValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(QValue, QValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2QResponse</returns>
        public new static PARAM_Gen2QResponse FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2QResponse obj = new PARAM_Gen2QResponse();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.QValue = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2QResponse";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (QValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "QValue>" + Util.ConvertValueTypeToString(QValue, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "QValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2QResponse>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2QResponse</returns>
        public new static PARAM_Gen2QResponse  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2QResponse param = new PARAM_Gen2QResponse();
    
            val = XmlUtil.GetNodeValue(node, "QValue");
        
            param.QValue = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom Gen2LF Value.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2LFResponse : PARAM_Custom,IThingMagicMetadataGen2_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2LFResponse()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 228;
        }
      
        public UInt16 LFValue=0;
        private Int16 LFValue_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2LFResponse_Custom_Param custom =
                param as IGen2LFResponse_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (LFValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LFValue, LFValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2LFResponse</returns>
        public new static PARAM_Gen2LFResponse FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2LFResponse obj = new PARAM_Gen2LFResponse();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.LFValue = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2LFResponse";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (LFValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LFValue>" + Util.ConvertValueTypeToString(LFValue, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "LFValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2LFResponse>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2LFResponse</returns>
        public new static PARAM_Gen2LFResponse  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2LFResponse param = new PARAM_Gen2LFResponse();
    
            val = XmlUtil.GetNodeValue(node, "LFValue");
        
            param.LFValue = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom Gen2 Target Value.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_Gen2TargetResponse : PARAM_Custom,IThingMagicMetadataGen2_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_Gen2TargetResponse()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 229;
        }
      
        public byte TargetValue=0;
        private Int16 TargetValue_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IGen2TargetResponse_Custom_Param custom =
                param as IGen2TargetResponse_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (TargetValue != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TargetValue, TargetValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_Gen2TargetResponse</returns>
        public new static PARAM_Gen2TargetResponse FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Gen2TargetResponse obj = new PARAM_Gen2TargetResponse();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.TargetValue = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"Gen2TargetResponse";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (TargetValue != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TargetValue>" + Util.ConvertValueTypeToString(TargetValue, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "TargetValue>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":Gen2TargetResponse>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_Gen2TargetResponse</returns>
        public new static PARAM_Gen2TargetResponse  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_Gen2TargetResponse param = new PARAM_Gen2TargetResponse();
    
            val = XmlUtil.GetNodeValue(node, "TargetValue");
        
            param.TargetValue = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter configures FastSearch Mode.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicFastSearchMode : PARAM_Custom,IC1G2InventoryCommand_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicFastSearchMode()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 144;
        }
      
        public ENUM_ThingMagicFastSearchValue ThingMagicFastSearch;
        private Int16 ThingMagicFastSearch_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicFastSearchMode_Custom_Param custom =
                param as IThingMagicFastSearchMode_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ThingMagicFastSearch != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ThingMagicFastSearch, ThingMagicFastSearch_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicFastSearchMode</returns>
        public new static PARAM_ThingMagicFastSearchMode FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicFastSearchMode obj = new PARAM_ThingMagicFastSearchMode();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ThingMagicFastSearch = (ENUM_ThingMagicFastSearchValue)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicFastSearchMode";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ThingMagicFastSearch != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ThingMagicFastSearch>" + ThingMagicFastSearch.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ThingMagicFastSearch>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicFastSearchMode>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicFastSearchMode</returns>
        public new static PARAM_ThingMagicFastSearchMode  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicFastSearchMode param = new PARAM_ThingMagicFastSearchMode();
    
            val = XmlUtil.GetNodeValue(node, "ThingMagicFastSearch");
        
            param.ThingMagicFastSearch = (ENUM_ThingMagicFastSearchValue)Enum.Parse(typeof(ENUM_ThingMagicFastSearchValue), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic Async OFF time 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicAsyncOFFTime : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicAsyncOFFTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 145;
        }
      
        public UInt32 AsyncOFFTime=0;
        private Int16 AsyncOFFTime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicAsyncOFFTime_Custom_Param custom =
                param as IThingMagicAsyncOFFTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AsyncOFFTime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AsyncOFFTime, AsyncOFFTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicAsyncOFFTime</returns>
        public new static PARAM_ThingMagicAsyncOFFTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicAsyncOFFTime obj = new PARAM_ThingMagicAsyncOFFTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AsyncOFFTime = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicAsyncOFFTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AsyncOFFTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AsyncOFFTime>" + Util.ConvertValueTypeToString(AsyncOFFTime, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AsyncOFFTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicAsyncOFFTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicAsyncOFFTime</returns>
        public new static PARAM_ThingMagicAsyncOFFTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicAsyncOFFTime param = new PARAM_ThingMagicAsyncOFFTime();
    
            val = XmlUtil.GetNodeValue(node, "AsyncOFFTime");
        
            param.AsyncOFFTime = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic Async ON time 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicAsyncONTime : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicAsyncONTime()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 179;
        }
      
        public UInt32 AsyncONTime=0;
        private Int16 AsyncONTime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicAsyncONTime_Custom_Param custom =
                param as IThingMagicAsyncONTime_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AsyncONTime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AsyncONTime, AsyncONTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicAsyncONTime</returns>
        public new static PARAM_ThingMagicAsyncONTime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicAsyncONTime obj = new PARAM_ThingMagicAsyncONTime();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AsyncONTime = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicAsyncONTime";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AsyncONTime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AsyncONTime>" + Util.ConvertValueTypeToString(AsyncONTime, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AsyncONTime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicAsyncONTime>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicAsyncONTime</returns>
        public new static PARAM_ThingMagicAsyncONTime  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicAsyncONTime param = new PARAM_ThingMagicAsyncONTime();
    
            val = XmlUtil.GetNodeValue(node, "AsyncONTime");
        
            param.AsyncONTime = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic Licensed features  
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicLicensedFeatures : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicLicensedFeatures()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 146;
        }
      
        public ByteArray LicensedFeatures=new ByteArray();
        private Int16 LicensedFeatures_len;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicLicensedFeatures_Custom_Param custom =
                param as IThingMagicLicensedFeatures_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (LicensedFeatures != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(LicensedFeatures.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(LicensedFeatures, LicensedFeatures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicLicensedFeatures</returns>
        public new static PARAM_ThingMagicLicensedFeatures FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicLicensedFeatures obj = new PARAM_ThingMagicLicensedFeatures();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.LicensedFeatures = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicLicensedFeatures";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (LicensedFeatures != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LicensedFeatures>" + Util.ConvertArrayTypeToString(LicensedFeatures, "u8v", "Hex") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LicensedFeatures>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicLicensedFeatures>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicLicensedFeatures</returns>
        public new static PARAM_ThingMagicLicensedFeatures  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicLicensedFeatures param = new PARAM_ThingMagicLicensedFeatures();
    
            val = XmlUtil.GetNodeValue(node, "LicensedFeatures");
        
            param.LicensedFeatures = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", "Hex"));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic Licensed features  
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicSelectedProtocols : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicSelectedProtocols()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 147;
        }
      
        public PARAM_SelectedProtocol[] SelectedProtocol;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicSelectedProtocols_Custom_Param custom =
                param as IThingMagicSelectedProtocols_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (SelectedProtocol != null)
            {
        
                len = SelectedProtocol.Length;
                for (int i=0; i<len;i++)
                {
                    SelectedProtocol[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicSelectedProtocols</returns>
        public new static PARAM_ThingMagicSelectedProtocols FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicSelectedProtocols obj = new PARAM_ThingMagicSelectedProtocols();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            param_list = new ArrayList();
            PARAM_SelectedProtocol _param_SelectedProtocol;
            while ((_param_SelectedProtocol = PARAM_SelectedProtocol.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_SelectedProtocol);
            }

            if (param_list.Count > 0)
            {
                obj.SelectedProtocol = new PARAM_SelectedProtocol[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.SelectedProtocol[i] = (PARAM_SelectedProtocol)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicSelectedProtocols";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (SelectedProtocol != null)
            {
          
                len = SelectedProtocol.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(SelectedProtocol[i].ToString());
                }
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicSelectedProtocols>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicSelectedProtocols</returns>
        public new static PARAM_ThingMagicSelectedProtocols  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicSelectedProtocols param = new PARAM_ThingMagicSelectedProtocols();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "SelectedProtocol", nsmgr);
            if (xnl.Count != 0)
            {
                param.SelectedProtocol = new PARAM_SelectedProtocol[xnl.Count];
                for (int i=0; i<xnl.Count; i++)
                {
                    param.SelectedProtocol[i] = PARAM_SelectedProtocol.FromXmlNode(xnl[i]);
                }
            }
              
            }
      
            {
        
            string[] excl = new string[] { "SelectedProtocol",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic Module user selected protocols 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_SelectedProtocol : PARAM_Custom
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_SelectedProtocol()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 148;
        }
      
        public ENUM_ProtocolID Protocol;
        private Int16 Protocol_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ISelectedProtocol_Custom_Param custom =
                param as ISelectedProtocol_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Protocol != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Protocol, Protocol_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_SelectedProtocol</returns>
        public new static PARAM_SelectedProtocol FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_SelectedProtocol obj = new PARAM_SelectedProtocol();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Protocol = (ENUM_ProtocolID)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"SelectedProtocol";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Protocol != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>" + Protocol.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":SelectedProtocol>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_SelectedProtocol</returns>
        public new static PARAM_SelectedProtocol  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_SelectedProtocol param = new PARAM_SelectedProtocol();
    
            val = XmlUtil.GetNodeValue(node, "Protocol");
        
            param.Protocol = (ENUM_ProtocolID)Enum.Parse(typeof(ENUM_ProtocolID), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP Readbuffer command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPReadbuffer : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPReadbuffer()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 154;
        }
      
        public UInt16 wordPointer=0;
        private Int16 wordPointer_len=0;
      
        public UInt16 bitCount=0;
        private Int16 bitCount_len=0;
      
        public ENUM_ThingMagicCustomNXPAuthenticationType Authtype;
        private Int16 Authtype_len = 8;
        public byte subCommand=0;
        private Int16 subCommand_len=0;
      
        public PARAM_ThingMagicNXPCommandRequest ThingMagicNXPCommandRequest;
                
        public PARAM_ThingMagicNXPTAM1AuthenticationData ThingMagicNXPTAM1AuthenticationData;
                
        public PARAM_ThingMagicNXPTAM2AuthenticationData ThingMagicNXPTAM2AuthenticationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPReadbuffer_Custom_Param custom =
                param as IThingMagicNXPReadbuffer_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (wordPointer != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(wordPointer, wordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (bitCount != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(bitCount, bitCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Authtype != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Authtype, Authtype_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (subCommand != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(subCommand, subCommand_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPCommandRequest != null)
            {
        ThingMagicNXPCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
        ThingMagicNXPTAM1AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicNXPTAM2AuthenticationData != null)
            {
        ThingMagicNXPTAM2AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPReadbuffer</returns>
        public new static PARAM_ThingMagicNXPReadbuffer FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPReadbuffer obj = new PARAM_ThingMagicNXPReadbuffer();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.wordPointer = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.bitCount = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Authtype = (ENUM_ThingMagicCustomNXPAuthenticationType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.subCommand = (byte)obj_val;
          
            obj.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicNXPTAM2AuthenticationData = PARAM_ThingMagicNXPTAM2AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPReadbuffer";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (wordPointer != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "wordPointer>" + Util.ConvertValueTypeToString(wordPointer, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "wordPointer>";
            
	            xml_str += "\r\n";
	        }
        
            if (bitCount != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "bitCount>" + Util.ConvertValueTypeToString(bitCount, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "bitCount>";
            
	            xml_str += "\r\n";
	        }
        
            if (Authtype != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Authtype>" + Authtype.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Authtype>";
            
	            xml_str += "\r\n";
	        }
        
            if (subCommand != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "subCommand>" + Util.ConvertValueTypeToString(subCommand, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "subCommand>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPCommandRequest.ToString());
            
            }
        
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM1AuthenticationData.ToString());
            
            }
        
            if (ThingMagicNXPTAM2AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM2AuthenticationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPReadbuffer>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPReadbuffer</returns>
        public new static PARAM_ThingMagicNXPReadbuffer  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPReadbuffer param = new PARAM_ThingMagicNXPReadbuffer();
    
            val = XmlUtil.GetNodeValue(node, "wordPointer");
        
            param.wordPointer = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "bitCount");
        
            param.bitCount = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "Authtype");
        
            param.Authtype = (ENUM_ThingMagicCustomNXPAuthenticationType)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPAuthenticationType), val);
          
            val = XmlUtil.GetNodeValue(node, "subCommand");
        
            param.subCommand = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM1AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM2AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM2AuthenticationData = PARAM_ThingMagicNXPTAM2AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPCommandRequest", "ThingMagicNXPTAM1AuthenticationData", "ThingMagicNXPTAM2AuthenticationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic NXP Readbuffer OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPReadbufferOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPReadbufferOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 155;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray NXPReadbufferByteStream=new ByteArray();
        private Int16 NXPReadbufferByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPReadbufferOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPReadbufferOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NXPReadbufferByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(NXPReadbufferByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(NXPReadbufferByteStream, NXPReadbufferByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPReadbufferOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPReadbufferOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPReadbufferOpSpecResult obj = new PARAM_ThingMagicNXPReadbufferOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.NXPReadbufferByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPReadbufferOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (NXPReadbufferByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPReadbufferByteStream>" + Util.ConvertArrayTypeToString(NXPReadbufferByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPReadbufferByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPReadbufferOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPReadbufferOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPReadbufferOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPReadbufferOpSpecResult param = new PARAM_ThingMagicNXPReadbufferOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NXPReadbufferByteStream");
        
            param.NXPReadbufferByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP Authentication Value command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPAuthentication : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPAuthentication()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 150;
        }
      
        public ENUM_ThingMagicCustomNXPAuthenticationType authType;
        private Int16 authType_len = 8;
        public byte subCommand=0;
        private Int16 subCommand_len=0;
      
        public PARAM_ThingMagicNXPCommandRequest ThingMagicNXPCommandRequest;
                
        public PARAM_ThingMagicNXPTAM1AuthenticationData ThingMagicNXPTAM1AuthenticationData;
                
        public PARAM_ThingMagicNXPTAM2AuthenticationData ThingMagicNXPTAM2AuthenticationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPAuthentication_Custom_Param custom =
                param as IThingMagicNXPAuthentication_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (authType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(authType, authType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (subCommand != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(subCommand, subCommand_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPCommandRequest != null)
            {
        ThingMagicNXPCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
        ThingMagicNXPTAM1AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicNXPTAM2AuthenticationData != null)
            {
        ThingMagicNXPTAM2AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPAuthentication</returns>
        public new static PARAM_ThingMagicNXPAuthentication FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPAuthentication obj = new PARAM_ThingMagicNXPAuthentication();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.authType = (ENUM_ThingMagicCustomNXPAuthenticationType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.subCommand = (byte)obj_val;
          
            obj.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicNXPTAM2AuthenticationData = PARAM_ThingMagicNXPTAM2AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPAuthentication";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (authType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "authType>" + authType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "authType>";
            
	            xml_str += "\r\n";
	        }
        
            if (subCommand != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "subCommand>" + Util.ConvertValueTypeToString(subCommand, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "subCommand>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPCommandRequest.ToString());
            
            }
        
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM1AuthenticationData.ToString());
            
            }
        
            if (ThingMagicNXPTAM2AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM2AuthenticationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPAuthentication>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPAuthentication</returns>
        public new static PARAM_ThingMagicNXPAuthentication  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPAuthentication param = new PARAM_ThingMagicNXPAuthentication();
    
            val = XmlUtil.GetNodeValue(node, "authType");
        
            param.authType = (ENUM_ThingMagicCustomNXPAuthenticationType)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPAuthenticationType), val);
          
            val = XmlUtil.GetNodeValue(node, "subCommand");
        
            param.subCommand = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM1AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM2AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM2AuthenticationData = PARAM_ThingMagicNXPTAM2AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPCommandRequest", "ThingMagicNXPTAM1AuthenticationData", "ThingMagicNXPTAM2AuthenticationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic NXP Authentication Value OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPAuthenticationOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPAuthenticationOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 151;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray NXPAuthenticationByteStream=new ByteArray();
        private Int16 NXPAuthenticationByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPAuthenticationOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPAuthenticationOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NXPAuthenticationByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(NXPAuthenticationByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(NXPAuthenticationByteStream, NXPAuthenticationByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPAuthenticationOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPAuthenticationOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPAuthenticationOpSpecResult obj = new PARAM_ThingMagicNXPAuthenticationOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.NXPAuthenticationByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPAuthenticationOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (NXPAuthenticationByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPAuthenticationByteStream>" + Util.ConvertArrayTypeToString(NXPAuthenticationByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPAuthenticationByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPAuthenticationOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPAuthenticationOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPAuthenticationOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPAuthenticationOpSpecResult param = new PARAM_ThingMagicNXPAuthenticationOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NXPAuthenticationByteStream");
        
            param.NXPAuthenticationByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP TAM2 Authentication Value command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPTAM2AuthenticationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IThingMagicNXPAuthentication_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPTAM2AuthenticationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 152;
        }
      
        public UInt16 offset=0;
        private Int16 offset_len=0;
      
        public byte ProtMode=0;
        private Int16 ProtMode_len=0;
      
        public byte BlockCount=0;
        private Int16 BlockCount_len=0;
      
        public ENUM_ThingMagicNXPProfileType profile;
        private Int16 profile_len = 8;
        public PARAM_ThingMagicNXPTAM1AuthenticationData ThingMagicNXPTAM1AuthenticationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPTAM2AuthenticationData_Custom_Param custom =
                param as IThingMagicNXPTAM2AuthenticationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (offset != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(offset, offset_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ProtMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ProtMode, ProtMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (BlockCount != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BlockCount, BlockCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (profile != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(profile, profile_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
        ThingMagicNXPTAM1AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPTAM2AuthenticationData</returns>
        public new static PARAM_ThingMagicNXPTAM2AuthenticationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPTAM2AuthenticationData obj = new PARAM_ThingMagicNXPTAM2AuthenticationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.offset = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.ProtMode = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.BlockCount = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.profile = (ENUM_ThingMagicNXPProfileType)(UInt32)obj_val;
          
            obj.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPTAM2AuthenticationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (offset != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "offset>" + Util.ConvertValueTypeToString(offset, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "offset>";
            
	            xml_str += "\r\n";
	        }
        
            if (ProtMode != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ProtMode>" + Util.ConvertValueTypeToString(ProtMode, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "ProtMode>";
            
	            xml_str += "\r\n";
	        }
        
            if (BlockCount != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BlockCount>" + Util.ConvertValueTypeToString(BlockCount, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "BlockCount>";
            
	            xml_str += "\r\n";
	        }
        
            if (profile != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "profile>" + profile.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "profile>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM1AuthenticationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPTAM2AuthenticationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPTAM2AuthenticationData</returns>
        public new static PARAM_ThingMagicNXPTAM2AuthenticationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPTAM2AuthenticationData param = new PARAM_ThingMagicNXPTAM2AuthenticationData();
    
            val = XmlUtil.GetNodeValue(node, "offset");
        
            param.offset = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "ProtMode");
        
            param.ProtMode = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "BlockCount");
        
            param.BlockCount = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "profile");
        
            param.profile = (ENUM_ThingMagicNXPProfileType)Enum.Parse(typeof(ENUM_ThingMagicNXPProfileType), val);
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM1AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPTAM1AuthenticationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPCommandRequest : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPCommandRequest()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 160;
        }
      
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public UInt32 AccessPassword=0;
        private Int16 AccessPassword_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPCommandRequest_Custom_Param custom =
                param as IThingMagicNXPCommandRequest_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (AccessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPCommandRequest</returns>
        public new static PARAM_ThingMagicNXPCommandRequest FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPCommandRequest obj = new PARAM_ThingMagicNXPCommandRequest();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessPassword = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPCommandRequest";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (AccessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AccessPassword>" + Util.ConvertValueTypeToString(AccessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "AccessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPCommandRequest>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPCommandRequest</returns>
        public new static PARAM_ThingMagicNXPCommandRequest  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPCommandRequest param = new PARAM_ThingMagicNXPCommandRequest();
    
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "AccessPassword");
        
            param.AccessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Gen2 protocol extension value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicGEN2ProtocolExtension : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicGEN2ProtocolExtension()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 161;
        }
      
        public byte GEN2ProtocolExtension=0;
        private Int16 GEN2ProtocolExtension_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicGEN2ProtocolExtension_Custom_Param custom =
                param as IThingMagicGEN2ProtocolExtension_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (GEN2ProtocolExtension != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GEN2ProtocolExtension, GEN2ProtocolExtension_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicGEN2ProtocolExtension</returns>
        public new static PARAM_ThingMagicGEN2ProtocolExtension FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicGEN2ProtocolExtension obj = new PARAM_ThingMagicGEN2ProtocolExtension();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.GEN2ProtocolExtension = (byte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicGEN2ProtocolExtension";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (GEN2ProtocolExtension != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "GEN2ProtocolExtension>" + Util.ConvertValueTypeToString(GEN2ProtocolExtension, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "GEN2ProtocolExtension>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicGEN2ProtocolExtension>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicGEN2ProtocolExtension</returns>
        public new static PARAM_ThingMagicGEN2ProtocolExtension  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicGEN2ProtocolExtension param = new PARAM_ThingMagicGEN2ProtocolExtension();
    
            val = XmlUtil.GetNodeValue(node, "GEN2ProtocolExtension");
        
            param.GEN2ProtocolExtension = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP Untraceable command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPUntraceable : PARAM_Custom,IAccessCommandOpSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPUntraceable()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 156;
        }
      
        public ENUM_ThingMagicCustomNXPUntraceableEPC epc;
        private Int16 epc_len = 8;
        public UInt32 epcLength=0;
        private Int16 epcLength_len=0;
      
        public ENUM_ThingMagicCustomNXPUntraceableTID tid;
        private Int16 tid_len = 8;
        public ENUM_ThingMagicCustomNXPUntraceableUserMemory userMemory;
        private Int16 userMemory_len = 8;
        public ENUM_ThingMagicCustomNXPUntraceableRange range;
        private Int16 range_len = 8;
        public byte subCommand=0;
        private Int16 subCommand_len=0;
      
        public PARAM_ThingMagicNXPCommandRequest ThingMagicNXPCommandRequest;
                
        public PARAM_ThingMagicNXPUntraceableAuthentication ThingMagicNXPUntraceableAuthentication;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPUntraceable_Custom_Param custom =
                param as IThingMagicNXPUntraceable_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (epc != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(epc, epc_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (epcLength != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(epcLength, epcLength_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (tid != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(tid, tid_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (userMemory != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(userMemory, userMemory_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (range != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(range, range_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (subCommand != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(subCommand, subCommand_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPCommandRequest != null)
            {
        ThingMagicNXPCommandRequest.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ThingMagicNXPUntraceableAuthentication != null)
            {
        ThingMagicNXPUntraceableAuthentication.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPUntraceable</returns>
        public new static PARAM_ThingMagicNXPUntraceable FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPUntraceable obj = new PARAM_ThingMagicNXPUntraceable();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.epc = (ENUM_ThingMagicCustomNXPUntraceableEPC)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.epcLength = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.tid = (ENUM_ThingMagicCustomNXPUntraceableTID)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.userMemory = (ENUM_ThingMagicCustomNXPUntraceableUserMemory)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.range = (ENUM_ThingMagicCustomNXPUntraceableRange)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.subCommand = (byte)obj_val;
          
            obj.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ThingMagicNXPUntraceableAuthentication = PARAM_ThingMagicNXPUntraceableAuthentication.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPUntraceable";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (epc != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "epc>" + epc.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "epc>";
            
	            xml_str += "\r\n";
	        }
        
            if (epcLength != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "epcLength>" + Util.ConvertValueTypeToString(epcLength, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "epcLength>";
            
	            xml_str += "\r\n";
	        }
        
            if (tid != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "tid>" + tid.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "tid>";
            
	            xml_str += "\r\n";
	        }
        
            if (userMemory != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "userMemory>" + userMemory.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "userMemory>";
            
	            xml_str += "\r\n";
	        }
        
            if (range != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "range>" + range.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "range>";
            
	            xml_str += "\r\n";
	        }
        
            if (subCommand != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "subCommand>" + Util.ConvertValueTypeToString(subCommand, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "subCommand>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPCommandRequest != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPCommandRequest.ToString());
            
            }
        
            if (ThingMagicNXPUntraceableAuthentication != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPUntraceableAuthentication.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPUntraceable>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPUntraceable</returns>
        public new static PARAM_ThingMagicNXPUntraceable  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPUntraceable param = new PARAM_ThingMagicNXPUntraceable();
    
            val = XmlUtil.GetNodeValue(node, "epc");
        
            param.epc = (ENUM_ThingMagicCustomNXPUntraceableEPC)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPUntraceableEPC), val);
          
            val = XmlUtil.GetNodeValue(node, "epcLength");
        
            param.epcLength = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "tid");
        
            param.tid = (ENUM_ThingMagicCustomNXPUntraceableTID)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPUntraceableTID), val);
          
            val = XmlUtil.GetNodeValue(node, "userMemory");
        
            param.userMemory = (ENUM_ThingMagicCustomNXPUntraceableUserMemory)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPUntraceableUserMemory), val);
          
            val = XmlUtil.GetNodeValue(node, "range");
        
            param.range = (ENUM_ThingMagicCustomNXPUntraceableRange)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPUntraceableRange), val);
          
            val = XmlUtil.GetNodeValue(node, "subCommand");
        
            param.subCommand = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPCommandRequest", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPCommandRequest = PARAM_ThingMagicNXPCommandRequest.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPUntraceableAuthentication", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPUntraceableAuthentication = PARAM_ThingMagicNXPUntraceableAuthentication.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPCommandRequest", "ThingMagicNXPUntraceableAuthentication",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter is the result of an ThingMagic NXP untraceable OpSpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPUntraceableOpSpecResult : PARAM_Custom,IAccessCommandOpSpecResult_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPUntraceableOpSpecResult()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 157;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID=0;
        private Int16 OpSpecID_len=0;
      
        public ByteArray NXPUntraceableByteStream=new ByteArray();
        private Int16 NXPUntraceableByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPUntraceableOpSpecResult_Custom_Param custom =
                param as IThingMagicNXPUntraceableOpSpecResult_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (OpSpecID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NXPUntraceableByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(NXPUntraceableByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(NXPUntraceableByteStream, NXPUntraceableByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPUntraceableOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPUntraceableOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPUntraceableOpSpecResult obj = new PARAM_ThingMagicNXPUntraceableOpSpecResult();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.OpSpecID = (UInt16)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.NXPUntraceableByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPUntraceableOpSpecResult";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (OpSpecID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "OpSpecID>" + Util.ConvertValueTypeToString(OpSpecID, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "OpSpecID>";
            
	            xml_str += "\r\n";
	        }
        
            if (NXPUntraceableByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPUntraceableByteStream>" + Util.ConvertArrayTypeToString(NXPUntraceableByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NXPUntraceableByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPUntraceableOpSpecResult>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPUntraceableOpSpecResult</returns>
        public new static PARAM_ThingMagicNXPUntraceableOpSpecResult  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPUntraceableOpSpecResult param = new PARAM_ThingMagicNXPUntraceableOpSpecResult();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            val = XmlUtil.GetNodeValue(node, "OpSpecID");
        
            param.OpSpecID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            val = XmlUtil.GetNodeValue(node, "NXPUntraceableByteStream");
        
            param.NXPUntraceableByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP Untraceable authentication command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPUntraceableAuthentication : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IThingMagicNXPUntraceable_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPUntraceableAuthentication()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 158;
        }
      
        public ENUM_ThingMagicCustomNXPUntraceableAuthType authType;
        private Int16 authType_len = 8;
        public UInt32 accessPassword=0;
        private Int16 accessPassword_len=0;
      
        public PARAM_ThingMagicNXPTAM1AuthenticationData ThingMagicNXPTAM1AuthenticationData;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPUntraceableAuthentication_Custom_Param custom =
                param as IThingMagicNXPUntraceableAuthentication_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (authType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(authType, authType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (accessPassword != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(accessPassword, accessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
        ThingMagicNXPTAM1AuthenticationData.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPUntraceableAuthentication</returns>
        public new static PARAM_ThingMagicNXPUntraceableAuthentication FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPUntraceableAuthentication obj = new PARAM_ThingMagicNXPUntraceableAuthentication();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.authType = (ENUM_ThingMagicCustomNXPUntraceableAuthType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.accessPassword = (UInt32)obj_val;
          
            obj.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPUntraceableAuthentication";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (authType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "authType>" + authType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "authType>";
            
	            xml_str += "\r\n";
	        }
        
            if (accessPassword != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "accessPassword>" + Util.ConvertValueTypeToString(accessPassword, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "accessPassword>";
            
	            xml_str += "\r\n";
	        }
        
            if (ThingMagicNXPTAM1AuthenticationData != null)
            {
          
                xml_str += Util.Indent(ThingMagicNXPTAM1AuthenticationData.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPUntraceableAuthentication>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPUntraceableAuthentication</returns>
        public new static PARAM_ThingMagicNXPUntraceableAuthentication  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPUntraceableAuthentication param = new PARAM_ThingMagicNXPUntraceableAuthentication();
    
            val = XmlUtil.GetNodeValue(node, "authType");
        
            param.authType = (ENUM_ThingMagicCustomNXPUntraceableAuthType)Enum.Parse(typeof(ENUM_ThingMagicCustomNXPUntraceableAuthType), val);
          
            val = XmlUtil.GetNodeValue(node, "accessPassword");
        
            param.accessPassword = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ThingMagicNXPTAM1AuthenticationData", nsmgr);
            if (xnl.Count != 0)
            {
                param.ThingMagicNXPTAM1AuthenticationData = PARAM_ThingMagicNXPTAM1AuthenticationData.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ThingMagicNXPTAM1AuthenticationData",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom NXP Authentication Value command.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicNXPTAM1AuthenticationData : PARAM_Custom,IAccessCommandOpSpec_Custom_Param,IThingMagicNXPTAM2AuthenticationData_Custom_Param,IThingMagicNXPAuthentication_Custom_Param,IThingMagicNXPUntraceableAuthentication_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicNXPTAM1AuthenticationData()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 153;
        }
      
        public byte Authentication=0;
        private Int16 Authentication_len=0;
      
        public byte CSI=0;
        private Int16 CSI_len=0;
      
        public byte keyID=0;
        private Int16 keyID_len=0;
      
        public byte KeyLength=0;
        private Int16 KeyLength_len=0;
      
        public ByteArray Key=new ByteArray();
        private Int16 Key_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicNXPTAM1AuthenticationData_Custom_Param custom =
                param as IThingMagicNXPTAM1AuthenticationData_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Authentication != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Authentication, Authentication_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (CSI != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CSI, CSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (keyID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(keyID, keyID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KeyLength != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KeyLength, KeyLength_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Key != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(Key.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(Key, Key_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicNXPTAM1AuthenticationData</returns>
        public new static PARAM_ThingMagicNXPTAM1AuthenticationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicNXPTAM1AuthenticationData obj = new PARAM_ThingMagicNXPTAM1AuthenticationData();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Authentication = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.CSI = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.keyID = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.KeyLength = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.Key = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicNXPTAM1AuthenticationData";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Authentication != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Authentication>" + Util.ConvertValueTypeToString(Authentication, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Authentication>";
            
	            xml_str += "\r\n";
	        }
        
            if (CSI != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "CSI>" + Util.ConvertValueTypeToString(CSI, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "CSI>";
            
	            xml_str += "\r\n";
	        }
        
            if (keyID != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "keyID>" + Util.ConvertValueTypeToString(keyID, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "keyID>";
            
	            xml_str += "\r\n";
	        }
        
            if (KeyLength != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KeyLength>" + Util.ConvertValueTypeToString(KeyLength, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "KeyLength>";
            
	            xml_str += "\r\n";
	        }
        
            if (Key != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Key>" + Util.ConvertArrayTypeToString(Key, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Key>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicNXPTAM1AuthenticationData>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicNXPTAM1AuthenticationData</returns>
        public new static PARAM_ThingMagicNXPTAM1AuthenticationData  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicNXPTAM1AuthenticationData param = new PARAM_ThingMagicNXPTAM1AuthenticationData();
    
            val = XmlUtil.GetNodeValue(node, "Authentication");
        
            param.Authentication = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "CSI");
        
            param.CSI = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "keyID");
        
            param.keyID = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "KeyLength");
        
            param.KeyLength = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Key");
        
            param.Key = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the custom protocol ID.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomProtocolID : PARAM_Custom,ITagReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomProtocolID()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 175;
        }
      
        public ENUM_ThingMagicCustomProtocol ProtocolId;
        private Int16 ProtocolId_len = 8;
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ProtocolId != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ProtocolId, ProtocolId_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomProtocolID</returns>
        public new static PARAM_ThingMagicCustomProtocolID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomProtocolID obj = new PARAM_ThingMagicCustomProtocolID();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ProtocolId = (ENUM_ThingMagicCustomProtocol)(UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomProtocolID";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ProtocolId != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ProtocolId>" + ProtocolId.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ProtocolId>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomProtocolID>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomProtocolID</returns>
        public new static PARAM_ThingMagicCustomProtocolID  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomProtocolID param = new PARAM_ThingMagicCustomProtocolID();
    
            val = XmlUtil.GetNodeValue(node, "ProtocolId");
        
            param.ProtocolId = (ENUM_ThingMagicCustomProtocol)Enum.Parse(typeof(ENUM_ThingMagicCustomProtocol), val);
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the custom Read plan weight.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomReadplanWeight : PARAM_Custom,IInventoryParameterSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomReadplanWeight()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 176;
        }
      
        public UInt32 planWeight=0;
        private Int16 planWeight_len=0;
      
        public UInt32 multiPlanWeight=0;
        private Int16 multiPlanWeight_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (planWeight != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(planWeight, planWeight_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (multiPlanWeight != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(multiPlanWeight, multiPlanWeight_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomReadplanWeight</returns>
        public new static PARAM_ThingMagicCustomReadplanWeight FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomReadplanWeight obj = new PARAM_ThingMagicCustomReadplanWeight();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.planWeight = (UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.multiPlanWeight = (UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomReadplanWeight";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (planWeight != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "planWeight>" + Util.ConvertValueTypeToString(planWeight, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "planWeight>";
            
	            xml_str += "\r\n";
	        }
        
            if (multiPlanWeight != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "multiPlanWeight>" + Util.ConvertValueTypeToString(multiPlanWeight, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "multiPlanWeight>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomReadplanWeight>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomReadplanWeight</returns>
        public new static PARAM_ThingMagicCustomReadplanWeight  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomReadplanWeight param = new PARAM_ThingMagicCustomReadplanWeight();
    
            val = XmlUtil.GetNodeValue(node, "planWeight");
        
            param.planWeight = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            val = XmlUtil.GetNodeValue(node, "multiPlanWeight");
        
            param.multiPlanWeight = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes thingmagic custom antenna returnloss param details.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicAntennaReturnloss : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicAntennaReturnloss()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 181;
        }
      
        public PARAM_ReturnlossValue[] ReturnlossValue;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicAntennaReturnloss_Custom_Param custom =
                param as IThingMagicAntennaReturnloss_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ReturnlossValue != null)
            {
        
                len = ReturnlossValue.Length;
                for (int i=0; i<len;i++)
                {
                    ReturnlossValue[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicAntennaReturnloss</returns>
        public new static PARAM_ThingMagicAntennaReturnloss FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicAntennaReturnloss obj = new PARAM_ThingMagicAntennaReturnloss();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            param_list = new ArrayList();
            PARAM_ReturnlossValue _param_ReturnlossValue;
            while ((_param_ReturnlossValue = PARAM_ReturnlossValue.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_ReturnlossValue);
            }

            if (param_list.Count > 0)
            {
                obj.ReturnlossValue = new PARAM_ReturnlossValue[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.ReturnlossValue[i] = (PARAM_ReturnlossValue)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicAntennaReturnloss";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ReturnlossValue != null)
            {
          
                len = ReturnlossValue.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(ReturnlossValue[i].ToString());
                }
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicAntennaReturnloss>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicAntennaReturnloss</returns>
        public new static PARAM_ThingMagicAntennaReturnloss  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicAntennaReturnloss param = new PARAM_ThingMagicAntennaReturnloss();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReturnlossValue", nsmgr);
            if (xnl.Count != 0)
            {
                param.ReturnlossValue = new PARAM_ReturnlossValue[xnl.Count];
                for (int i=0; i<xnl.Count; i++)
                {
                    param.ReturnlossValue[i] = PARAM_ReturnlossValue.FromXmlNode(xnl[i]);
                }
            }
              
            }
      
            {
        
            string[] excl = new string[] { "ReturnlossValue",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the ThingMagic specific antenna port return loss value 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ReturnlossValue : PARAM_Custom,IThingMagicAntennaReturnloss_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ReturnlossValue()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 182;
        }
      
        public byte Port=0;
        private Int16 Port_len=0;
      
        public Int32 Value=0;
        private Int16 Value_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IReturnlossValue_Custom_Param custom =
                param as IReturnlossValue_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Port != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Port, Port_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Value != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Value, Value_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ReturnlossValue</returns>
        public new static PARAM_ReturnlossValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReturnlossValue obj = new PARAM_ReturnlossValue();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.Port = (byte)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(Int32), field_len);
            obj.Value = (Int32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ReturnlossValue";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Port != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Port>" + Util.ConvertValueTypeToString(Port, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Port>";
            
	            xml_str += "\r\n";
	        }
        
            if (Value != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Value>" + Util.ConvertValueTypeToString(Value, "s32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Value>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ReturnlossValue>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ReturnlossValue</returns>
        public new static PARAM_ReturnlossValue  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ReturnlossValue param = new PARAM_ReturnlossValue();
    
            val = XmlUtil.GetNodeValue(node, "Port");
        
            param.Port = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            val = XmlUtil.GetNodeValue(node, "Value");
        
            param.Value = (Int32)(Util.ParseValueTypeFromString(val, "s32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the custom inventory spec ID.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomInventorySpecID : PARAM_Custom,IAccessSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomInventorySpecID()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 183;
        }
      
        public UInt32 InventorySpecId=0;
        private Int16 InventorySpecId_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (InventorySpecId != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(InventorySpecId, InventorySpecId_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomInventorySpecID</returns>
        public new static PARAM_ThingMagicCustomInventorySpecID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomInventorySpecID obj = new PARAM_ThingMagicCustomInventorySpecID();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.InventorySpecId = (UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomInventorySpecID";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (InventorySpecId != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "InventorySpecId>" + Util.ConvertValueTypeToString(InventorySpecId, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "InventorySpecId>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomInventorySpecID>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomInventorySpecID</returns>
        public new static PARAM_ThingMagicCustomInventorySpecID  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomInventorySpecID param = new PARAM_ThingMagicCustomInventorySpecID();
    
            val = XmlUtil.GetNodeValue(node, "InventorySpecId");
        
            param.InventorySpecId = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic MetaData 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicMetadata : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicMetadata()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 194;
        }
      
        public ENUM_ThingMagicCustomMetadataFlag Metadata;
        private Int16 Metadata_len = 16;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicMetadata_Custom_Param custom =
                param as IThingMagicMetadata_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Metadata != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Metadata, Metadata_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicMetadata</returns>
        public new static PARAM_ThingMagicMetadata FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicMetadata obj = new PARAM_ThingMagicMetadata();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Metadata = (ENUM_ThingMagicCustomMetadataFlag)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicMetadata";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Metadata != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Metadata>" + Metadata.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Metadata>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicMetadata>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicMetadata</returns>
        public new static PARAM_ThingMagicMetadata  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicMetadata param = new PARAM_ThingMagicMetadata();
    
            val = XmlUtil.GetNodeValue(node, "Metadata");
        
            param.Metadata = (ENUM_ThingMagicCustomMetadataFlag)Enum.Parse(typeof(ENUM_ThingMagicCustomMetadataFlag), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic StatsEnable 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicStatsEnable : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicStatsEnable()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 195;
        }
      
        public ENUM_ThingMagicCustomStatsEnableFlag StatsEnable;
        private Int16 StatsEnable_len = 16;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicStatsEnable_Custom_Param custom =
                param as IThingMagicStatsEnable_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (StatsEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StatsEnable, StatsEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicStatsEnable</returns>
        public new static PARAM_ThingMagicStatsEnable FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicStatsEnable obj = new PARAM_ThingMagicStatsEnable();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicStatsEnable";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (StatsEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>" + StatsEnable.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicStatsEnable>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicStatsEnable</returns>
        public new static PARAM_ThingMagicStatsEnable  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicStatsEnable param = new PARAM_ThingMagicStatsEnable();
    
            val = XmlUtil.GetNodeValue(node, "StatsEnable");
        
            param.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)Enum.Parse(typeof(ENUM_ThingMagicCustomStatsEnableFlag), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the custom ThingMagic StatsValue 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicReaderStats : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicReaderStats()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 196;
        }
      
        public PARAM_CustomStatsValue CustomStatsValue;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicReaderStats_Custom_Param custom =
                param as IThingMagicReaderStats_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (CustomStatsValue != null)
            {
        CustomStatsValue.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicReaderStats</returns>
        public new static PARAM_ThingMagicReaderStats FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicReaderStats obj = new PARAM_ThingMagicReaderStats();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            obj.CustomStatsValue = PARAM_CustomStatsValue.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicReaderStats";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (CustomStatsValue != null)
            {
          
                xml_str += Util.Indent(CustomStatsValue.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicReaderStats>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicReaderStats</returns>
        public new static PARAM_ThingMagicReaderStats  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicReaderStats param = new PARAM_ThingMagicReaderStats();
    
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "CustomStatsValue", nsmgr);
            if (xnl.Count != 0)
            {
                param.CustomStatsValue = PARAM_CustomStatsValue.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "CustomStatsValue",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom RFSurveySpec.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_CustomRFSurveySpec : PARAM_Custom,IRFSurveySpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_CustomRFSurveySpec()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 218;
        }
      
        public ENUM_ThingMagicCustomStatsEnableFlag StatsEnable;
        private Int16 StatsEnable_len = 16;
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (StatsEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StatsEnable, StatsEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_CustomRFSurveySpec</returns>
        public new static PARAM_CustomRFSurveySpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_CustomRFSurveySpec obj = new PARAM_CustomRFSurveySpec();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)(UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"CustomRFSurveySpec";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (StatsEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>" + StatsEnable.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":CustomRFSurveySpec>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_CustomRFSurveySpec</returns>
        public new static PARAM_CustomRFSurveySpec  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_CustomRFSurveySpec param = new PARAM_CustomRFSurveySpec();
    
            val = XmlUtil.GetNodeValue(node, "StatsEnable");
        
            param.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)Enum.Parse(typeof(ENUM_ThingMagicCustomStatsEnableFlag), val);
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter defines the fields required for custom Reader stats value.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_CustomStatsValue : PARAM_Custom,IThingMagicReaderStats_Custom_Param,IRFSurveyReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_CustomStatsValue()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 197;
        }
      
        public ENUM_ThingMagicCustomStatsEnableFlag StatsEnable;
        private Int16 StatsEnable_len = 16;
        public PARAM_TemperatureParam TemperatureParam;
                
        public PARAM_ProtocolParam ProtocolParam;
                
        public PARAM_AntennaParam AntennaParam;
                
        public PARAM_FrequencyParam FrequencyParam;
                
        public PARAM_ConnectedAntennaList ConnectedAntennaList;
                
        public PARAM_perAntennaStatsList[] perAntennaStatsList;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ICustomStatsValue_Custom_Param custom =
                param as ICustomStatsValue_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (StatsEnable != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StatsEnable, StatsEnable_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TemperatureParam != null)
            {
        TemperatureParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ProtocolParam != null)
            {
        ProtocolParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (AntennaParam != null)
            {
        AntennaParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (FrequencyParam != null)
            {
        FrequencyParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ConnectedAntennaList != null)
            {
        ConnectedAntennaList.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (perAntennaStatsList != null)
            {
        
                len = perAntennaStatsList.Length;
                for (int i=0; i<len;i++)
                {
                    perAntennaStatsList[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_CustomStatsValue</returns>
        public new static PARAM_CustomStatsValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_CustomStatsValue obj = new PARAM_CustomStatsValue();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)(UInt32)obj_val;
          
            obj.TemperatureParam = PARAM_TemperatureParam.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ProtocolParam = PARAM_ProtocolParam.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.AntennaParam = PARAM_AntennaParam.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.FrequencyParam = PARAM_FrequencyParam.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.ConnectedAntennaList = PARAM_ConnectedAntennaList.FromBitArray(ref bit_array, ref cursor, length);
            
            param_list = new ArrayList();
            PARAM_perAntennaStatsList _param_perAntennaStatsList;
            while ((_param_perAntennaStatsList = PARAM_perAntennaStatsList.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                param_list.Add(_param_perAntennaStatsList);
            }

            if (param_list.Count > 0)
            {
                obj.perAntennaStatsList = new PARAM_perAntennaStatsList[param_list.Count];
                for (int i=0; i<param_list.Count; i++)
                {
                    obj.perAntennaStatsList[i] = (PARAM_perAntennaStatsList)param_list[i];
                }
            }
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"CustomStatsValue";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (StatsEnable != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>" + StatsEnable.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "StatsEnable>";
            
	            xml_str += "\r\n";
	        }
        
            if (TemperatureParam != null)
            {
          
                xml_str += Util.Indent(TemperatureParam.ToString());
            
            }
        
            if (ProtocolParam != null)
            {
          
                xml_str += Util.Indent(ProtocolParam.ToString());
            
            }
        
            if (AntennaParam != null)
            {
          
                xml_str += Util.Indent(AntennaParam.ToString());
            
            }
        
            if (FrequencyParam != null)
            {
          
                xml_str += Util.Indent(FrequencyParam.ToString());
            
            }
        
            if (ConnectedAntennaList != null)
            {
          
                xml_str += Util.Indent(ConnectedAntennaList.ToString());
            
            }
        
            if (perAntennaStatsList != null)
            {
          
                len = perAntennaStatsList.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(perAntennaStatsList[i].ToString());
                }
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":CustomStatsValue>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_CustomStatsValue</returns>
        public new static PARAM_CustomStatsValue  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_CustomStatsValue param = new PARAM_CustomStatsValue();
    
            val = XmlUtil.GetNodeValue(node, "StatsEnable");
        
            param.StatsEnable = (ENUM_ThingMagicCustomStatsEnableFlag)Enum.Parse(typeof(ENUM_ThingMagicCustomStatsEnableFlag), val);
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TemperatureParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.TemperatureParam = PARAM_TemperatureParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ProtocolParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.ProtocolParam = PARAM_ProtocolParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.AntennaParam = PARAM_AntennaParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FrequencyParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.FrequencyParam = PARAM_FrequencyParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ConnectedAntennaList", nsmgr);
            if (xnl.Count != 0)
            {
                param.ConnectedAntennaList = PARAM_ConnectedAntennaList.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "perAntennaStatsList", nsmgr);
            if (xnl.Count != 0)
            {
                param.perAntennaStatsList = new PARAM_perAntennaStatsList[xnl.Count];
                for (int i=0; i<xnl.Count; i++)
                {
                    param.perAntennaStatsList[i] = PARAM_perAntennaStatsList.FromXmlNode(xnl[i]);
                }
            }
              
            }
      
            {
        
            string[] excl = new string[] { "TemperatureParam", "ProtocolParam", "AntennaParam", "FrequencyParam", "ConnectedAntennaList", "perAntennaStatsList",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the temperature information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_TemperatureParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_TemperatureParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 210;
        }
      
        public sbyte Temperature=0;
        private Int16 Temperature_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITemperatureParam_Custom_Param custom =
                param as ITemperatureParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Temperature != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Temperature, Temperature_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_TemperatureParam</returns>
        public new static PARAM_TemperatureParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TemperatureParam obj = new PARAM_TemperatureParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(sbyte), field_len);
            obj.Temperature = (sbyte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"TemperatureParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Temperature != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Temperature>" + Util.ConvertValueTypeToString(Temperature, "s8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Temperature>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":TemperatureParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_TemperatureParam</returns>
        public new static PARAM_TemperatureParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_TemperatureParam param = new PARAM_TemperatureParam();
    
            val = XmlUtil.GetNodeValue(node, "Temperature");
        
            param.Temperature = (sbyte)(Util.ParseValueTypeFromString(val, "s8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the protocol information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ProtocolParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ProtocolParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 211;
        }
      
        public ENUM_ProtocolID Protocol;
        private Int16 Protocol_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IProtocolParam_Custom_Param custom =
                param as IProtocolParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Protocol != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Protocol, Protocol_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ProtocolParam</returns>
        public new static PARAM_ProtocolParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ProtocolParam obj = new PARAM_ProtocolParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Protocol = (ENUM_ProtocolID)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ProtocolParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Protocol != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>" + Protocol.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Protocol>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ProtocolParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ProtocolParam</returns>
        public new static PARAM_ProtocolParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ProtocolParam param = new PARAM_ProtocolParam();
    
            val = XmlUtil.GetNodeValue(node, "Protocol");
        
            param.Protocol = (ENUM_ProtocolID)Enum.Parse(typeof(ENUM_ProtocolID), val);
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the antennas information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_AntennaParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_AntennaParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 212;
        }
      
        public UInt16 Antenna=0;
        private Int16 Antenna_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IAntennaParam_Custom_Param custom =
                param as IAntennaParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Antenna != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Antenna, Antenna_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_AntennaParam</returns>
        public new static PARAM_AntennaParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaParam obj = new PARAM_AntennaParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.Antenna = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"AntennaParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Antenna != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Antenna>" + Util.ConvertValueTypeToString(Antenna, "u16", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Antenna>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":AntennaParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_AntennaParam</returns>
        public new static PARAM_AntennaParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_AntennaParam param = new PARAM_AntennaParam();
    
            val = XmlUtil.GetNodeValue(node, "Antenna");
        
            param.Antenna = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Frequency information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_FrequencyParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_FrequencyParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 213;
        }
      
        public UInt32 Frequency=0;
        private Int16 Frequency_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IFrequencyParam_Custom_Param custom =
                param as IFrequencyParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Frequency != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Frequency, Frequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_FrequencyParam</returns>
        public new static PARAM_FrequencyParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FrequencyParam obj = new PARAM_FrequencyParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Frequency = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"FrequencyParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Frequency != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Frequency>" + Util.ConvertValueTypeToString(Frequency, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Frequency>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":FrequencyParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_FrequencyParam</returns>
        public new static PARAM_FrequencyParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_FrequencyParam param = new PARAM_FrequencyParam();
    
            val = XmlUtil.GetNodeValue(node, "Frequency");
        
            param.Frequency = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the Connected antennas information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ConnectedAntennaList : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ConnectedAntennaList()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 198;
        }
      
        public ByteArray connectedAntennas=new ByteArray();
        private Int16 connectedAntennas_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IConnectedAntennaList_Custom_Param custom =
                param as IConnectedAntennaList_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (connectedAntennas != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(connectedAntennas.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(connectedAntennas, connectedAntennas_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ConnectedAntennaList</returns>
        public new static PARAM_ConnectedAntennaList FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ConnectedAntennaList obj = new PARAM_ConnectedAntennaList();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.connectedAntennas = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ConnectedAntennaList";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (connectedAntennas != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "connectedAntennas>" + Util.ConvertArrayTypeToString(connectedAntennas, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "connectedAntennas>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ConnectedAntennaList>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ConnectedAntennaList</returns>
        public new static PARAM_ConnectedAntennaList  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ConnectedAntennaList param = new PARAM_ConnectedAntennaList();
    
            val = XmlUtil.GetNodeValue(node, "connectedAntennas");
        
            param.connectedAntennas = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the perAntennaStatsList values 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_perAntennaStatsList : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_perAntennaStatsList()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 199;
        }
      
        public byte antenna=0;
        private Int16 antenna_len=0;
      
        public PARAM_RFOntimeParam RFOntimeParam;
                
        public PARAM_NoiseFloorParam NoiseFloorParam;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IperAntennaStatsList_Custom_Param custom =
                param as IperAntennaStatsList_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (antenna != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(antenna, antenna_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (RFOntimeParam != null)
            {
        RFOntimeParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (NoiseFloorParam != null)
            {
        NoiseFloorParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_perAntennaStatsList</returns>
        public new static PARAM_perAntennaStatsList FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_perAntennaStatsList obj = new PARAM_perAntennaStatsList();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.antenna = (byte)obj_val;
          
            obj.RFOntimeParam = PARAM_RFOntimeParam.FromBitArray(ref bit_array, ref cursor, length);
            
            obj.NoiseFloorParam = PARAM_NoiseFloorParam.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"perAntennaStatsList";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (antenna != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "antenna>" + Util.ConvertValueTypeToString(antenna, "u8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "antenna>";
            
	            xml_str += "\r\n";
	        }
        
            if (RFOntimeParam != null)
            {
          
                xml_str += Util.Indent(RFOntimeParam.ToString());
            
            }
        
            if (NoiseFloorParam != null)
            {
          
                xml_str += Util.Indent(NoiseFloorParam.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":perAntennaStatsList>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_perAntennaStatsList</returns>
        public new static PARAM_perAntennaStatsList  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_perAntennaStatsList param = new PARAM_perAntennaStatsList();
    
            val = XmlUtil.GetNodeValue(node, "antenna");
        
            param.antenna = (byte)(Util.ParseValueTypeFromString(val, "u8", ""));
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFOntimeParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.RFOntimeParam = PARAM_RFOntimeParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "NoiseFloorParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.NoiseFloorParam = PARAM_NoiseFloorParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "RFOntimeParam", "NoiseFloorParam",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the RFOntime information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_RFOntimeParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_RFOntimeParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 214;
        }
      
        public UInt32 rfOntime=0;
        private Int16 rfOntime_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IRFOntimeParam_Custom_Param custom =
                param as IRFOntimeParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (rfOntime != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(rfOntime, rfOntime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_RFOntimeParam</returns>
        public new static PARAM_RFOntimeParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFOntimeParam obj = new PARAM_RFOntimeParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.rfOntime = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"RFOntimeParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (rfOntime != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "rfOntime>" + Util.ConvertValueTypeToString(rfOntime, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "rfOntime>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":RFOntimeParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_RFOntimeParam</returns>
        public new static PARAM_RFOntimeParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_RFOntimeParam param = new PARAM_RFOntimeParam();
    
            val = XmlUtil.GetNodeValue(node, "rfOntime");
        
            param.rfOntime = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the NoiseFloor information 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_NoiseFloorParam : PARAM_Custom,ICustomStatsValue_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_NoiseFloorParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 215;
        }
      
        public sbyte noiseFloor=0;
        private Int16 noiseFloor_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            INoiseFloorParam_Custom_Param custom =
                param as INoiseFloorParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (noiseFloor != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(noiseFloor, noiseFloor_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_NoiseFloorParam</returns>
        public new static PARAM_NoiseFloorParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_NoiseFloorParam obj = new PARAM_NoiseFloorParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(sbyte), field_len);
            obj.noiseFloor = (sbyte)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"NoiseFloorParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (noiseFloor != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "noiseFloor>" + Util.ConvertValueTypeToString(noiseFloor, "s8", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "noiseFloor>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":NoiseFloorParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_NoiseFloorParam</returns>
        public new static PARAM_NoiseFloorParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_NoiseFloorParam param = new PARAM_NoiseFloorParam();
    
            val = XmlUtil.GetNodeValue(node, "noiseFloor");
        
            param.noiseFloor = (sbyte)(Util.ParseValueTypeFromString(val, "s8", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This custom parameter reports the tagop response information .
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomTagopResponse : PARAM_Custom,ITagReportData_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomTagopResponse()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 216;
        }
      
        public ENUM_ThingMagicCustomTagOpSpecResultType Result;
        private Int16 Result_len = 8;
        public PARAM_TagopByteStreamParam TagopByteStreamParam;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            IThingMagicCustomTagopResponse_Custom_Param custom =
                param as IThingMagicCustomTagopResponse_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (Result != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagopByteStreamParam != null)
            {
        TagopByteStreamParam.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomTagopResponse</returns>
        public new static PARAM_ThingMagicCustomTagopResponse FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomTagopResponse obj = new PARAM_ThingMagicCustomTagopResponse();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)(UInt32)obj_val;
          
            obj.TagopByteStreamParam = PARAM_TagopByteStreamParam.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomTagopResponse";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (Result != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>" + Result.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Result>";
            
	            xml_str += "\r\n";
	        }
        
            if (TagopByteStreamParam != null)
            {
          
                xml_str += Util.Indent(TagopByteStreamParam.ToString());
            
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomTagopResponse>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomTagopResponse</returns>
        public new static PARAM_ThingMagicCustomTagopResponse  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomTagopResponse param = new PARAM_ThingMagicCustomTagopResponse();
    
            val = XmlUtil.GetNodeValue(node, "Result");
        
            param.Result = (ENUM_ThingMagicCustomTagOpSpecResultType)Enum.Parse(typeof(ENUM_ThingMagicCustomTagOpSpecResultType), val);
          
            {
        
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagopByteStreamParam", nsmgr);
            if (xnl.Count != 0)
            {
                param.TagopByteStreamParam = PARAM_TagopByteStreamParam.FromXmlNode(xnl[0]);
            }
              
            }
      
            {
        
            string[] excl = new string[] { "TagopByteStreamParam",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter provides the tagop result data 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_TagopByteStreamParam : PARAM_Custom,IThingMagicCustomTagopResponse_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_TagopByteStreamParam()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 217;
        }
      
        public ByteArray ByteStream=new ByteArray();
        private Int16 ByteStream_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITagopByteStreamParam_Custom_Param custom =
                param as ITagopByteStreamParam_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (ByteStream != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ByteStream.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ByteStream, ByteStream_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len;i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_TagopByteStreamParam</returns>
        public new static PARAM_TagopByteStreamParam FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TagopByteStreamParam obj = new PARAM_TagopByteStreamParam();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.ByteStream = (ByteArray)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (cursor <= max_cursor)
                    {
                        if (obj.AddCustomParameter(custom))
                        {
                            success = true;
                        }
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"TagopByteStreamParam";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (ByteStream != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ByteStream>" + Util.ConvertArrayTypeToString(ByteStream, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ByteStream>";
            
	            xml_str += "\r\n";
	        }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":TagopByteStreamParam>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_TagopByteStreamParam</returns>
        public new static PARAM_TagopByteStreamParam  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_TagopByteStreamParam param = new PARAM_TagopByteStreamParam();
    
            val = XmlUtil.GetNodeValue(node, "ByteStream");
        
            param.ByteStream = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            {
        
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for (int i=0; i<xnl.Count; i++)
                {
                    if (!customArr.Contains(xnl[i]))
                    {
                        ICustom_Parameter custom =
                            CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                        if (custom != null)
                        {
                            if (param.AddCustomParameter(custom))
                            {
                                customArr.Add(xnl[i]);
                            }
                        }
                    }
                }
            }
          
            }
      
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the custom antenna switching type
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicCustomAntennaSwitching : PARAM_Custom,IInventoryParameterSpec_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicCustomAntennaSwitching()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 219;
        }
      
        public ENUM_ThingMagicCustomAntennaSwitchingType AntSwitchingType;
        private Int16 AntSwitchingType_len = 8;
        public UInt32 Timeout=0;
        private Int16 Timeout_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (AntSwitchingType != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntSwitchingType, AntSwitchingType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Timeout != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Timeout, Timeout_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicCustomAntennaSwitching</returns>
        public new static PARAM_ThingMagicCustomAntennaSwitching FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicCustomAntennaSwitching obj = new PARAM_ThingMagicCustomAntennaSwitching();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AntSwitchingType = (ENUM_ThingMagicCustomAntennaSwitchingType)(UInt32)obj_val;
          
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.Timeout = (UInt32)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicCustomAntennaSwitching";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (AntSwitchingType != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntSwitchingType>" + AntSwitchingType.ToString() + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntSwitchingType>";
            
	            xml_str += "\r\n";
	        }
        
            if (Timeout != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Timeout>" + Util.ConvertValueTypeToString(Timeout, "u32", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX+ ":" + "Timeout>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicCustomAntennaSwitching>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicCustomAntennaSwitching</returns>
        public new static PARAM_ThingMagicCustomAntennaSwitching  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicCustomAntennaSwitching param = new PARAM_ThingMagicCustomAntennaSwitching();
    
            val = XmlUtil.GetNodeValue(node, "AntSwitchingType");
        
            param.AntSwitchingType = (ENUM_ThingMagicCustomAntennaSwitchingType)Enum.Parse(typeof(ENUM_ThingMagicCustomAntennaSwitchingType), val);
          
            val = XmlUtil.GetNodeValue(node, "Timeout");
        
            param.Timeout = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///This parameter describes the port switching GPO List for antenna multiplexing
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class PARAM_ThingMagicPortSwitchGPO : PARAM_Custom,IGET_READER_CONFIG_RESPONSE_Custom_Param,ISET_READER_CONFIG_Custom_Param
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public UInt32 SUB_TYPE
        {
            get { return ParameterSubtype; }
        }

        public PARAM_ThingMagicPortSwitchGPO()
        {
            VendorIdentifier = 26554;
            ParameterSubtype = 231;
        }
      
        public ByteArray portSwitchGPOList=new ByteArray();
        private Int16 portSwitchGPOList_len=0;
      
        /// <summary>
        /// Encode this parameter into existing bit array
        /// </summary>
        /// <param name="bit_array">Existing bit array to be appended to</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;   // Omit the parameter length, will be added at the end.
            }

            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

            bArr = Util.ConvertIntToBitArray(ParameterSubtype, 32);
            bArr.CopyTo(bit_array, cursor);
            cursor +=32;

    
            if (portSwitchGPOList != null)
            {
        
                try
                {
                    int temp_cursor = cursor;
            
                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(portSwitchGPOList.Count), 16);
              
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(portSwitchGPOList, portSwitchGPOList_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      

            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }
  
        /// <summary>
        /// Decode from existing bit array.
        /// </summary>
        /// <param name="bit_array">Existing bit array to be decoded</param>
        /// <param name="cursor">Current cursor in existing bit array</param>
        /// <param name="length">Total bits to be decoded</param>
        /// <returns>PARAM_ThingMagicPortSwitchGPO</returns>
        public new static PARAM_ThingMagicPortSwitchGPO FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            int orig_cursor = cursor;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ThingMagicPortSwitchGPO obj = new PARAM_ThingMagicPortSwitchGPO();

            int param_type = 0;

            obj.tvCoding = bit_array[cursor];

            if (obj.tvCoding)
            {
                // LLRP Doesn't support tv encoding for custom parameters
                return null;
            }

            // Skip the reserved bits and tv Bit
            cursor += 6;
            param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (param_type != obj.TypeID)
            {
                cursor = orig_cursor;
                return null;
            }

            obj.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            int max_cursor = orig_cursor + obj.length * 8;

            UInt32 vendorIdentifier = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            UInt32 parameterSubtype = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            if (obj.VendorIdentifier != vendorIdentifier ||
                obj.ParameterSubtype != parameterSubtype)
            {
                cursor = orig_cursor;
                return null;
            }

    
            if (cursor > length || cursor > max_cursor)
            {
                throw new Exception("Input data is not a complete LLRP message");
            }
        
            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.portSwitchGPOList = (ByteArray)obj_val;
          
            return obj;
        }
  
        /// <summary>
        /// Serialize a Xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;

            string xml_str = "<"+LLRPExtensionConstants.NAMESPACE_PREFIX+":"+"ThingMagicPortSwitchGPO";
            xml_str += "\r\n";
            xml_str += string.Format("    xmlns=\"{0}\"\n", LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += string.Format("    xmlns:{0}=\"{1}\"\n", LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);
            xml_str += "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format("    xsi:schemaLocation=\"{0} {1}\"", LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION) + "\r\n>";
            xml_str += "\r\n";

    
            if (portSwitchGPOList != null)
            {
          
                xml_str +="  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "portSwitchGPOList>" + Util.ConvertArrayTypeToString(portSwitchGPOList, "u8v", "") + "</"+LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "portSwitchGPOList>";
            
	            xml_str += "\r\n";
	        }
        
            xml_str += "</" +LLRPExtensionConstants.NAMESPACE_PREFIX+":ThingMagicPortSwitchGPO>";
            xml_str += "\r\n";

            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a XML node to parameter
        /// </summary>
        /// <param name="node">Xml node to be deserialized</param>
        /// <returns>PARAM_ThingMagicPortSwitchGPO</returns>
        public new static PARAM_ThingMagicPortSwitchGPO  FromXmlNode(XmlNode node)
        {
            ArrayList customArr = new ArrayList();
            string count;
            string val;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            PARAM_ThingMagicPortSwitchGPO param = new PARAM_ThingMagicPortSwitchGPO();
    
            val = XmlUtil.GetNodeValue(node, "portSwitchGPOList");
        
            param.portSwitchGPOList = (ByteArray)(Util.ParseArrayTypeFromString(val, "u8v", ""));
          
            return param;
        }
  
    }
    
        ///<summary>
        ///
        ///power cycle the ThingMagic reader
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 1;
            
        }
      
        public UInt32 MagicNumber=0;
        private Int16 MagicNumber_len=0;
      
        public bool BootToSafeMode=false;
        private Int16 BootToSafeMode_len=0;
      
        private const UInt16 param_reserved_len4 = 7;
        
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (MagicNumber != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MagicNumber, MagicNumber_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (BootToSafeMode != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BootToSafeMode, BootToSafeMode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            cursor += param_reserved_len4;
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER obj = new MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.MagicNumber = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 1;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.BootToSafeMode = (bool)obj_val;
          
            cursor += param_reserved_len4;
      
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (MagicNumber != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MagicNumber>" + Util.ConvertValueTypeToString(MagicNumber, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MagicNumber>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (BootToSafeMode != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BootToSafeMode>" + Util.ConvertValueTypeToString(BootToSafeMode, "u1", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "BootToSafeMode>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER msg = new MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            val = XmlUtil.GetNodeValue(node, "MagicNumber");
          
            msg.MagicNumber = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "BootToSafeMode");
          
            msg.BootToSafeMode = (bool)(Util.ParseValueTypeFromString(val, "u1", ""));
            
            {
          
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_REQUEST_POWER_CYCLE_READER;
        }
  
    }
    
        ///<summary>
        ///
        ///Response message to power cycle the ThingMagic reader request
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 2;
            
        }
      
        public PARAM_LLRPStatus LLRPStatus;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER obj = new MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER msg = new MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
            if (xnl.Count != 0)
            {
                msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
            }
                
            }
        
            {
          
            string[] excl = new string[] { "LLRPStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_RESPONSE_POWER_CYCLE_READER;
        }
  
    }
    
        ///<summary>
        ///
        ///Reset reader statistics
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 3;
            
        }
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS obj = new MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS msg = new MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_REQUEST_RESET_STATISTICS;
        }
  
    }
    
        ///<summary>
        ///
        ///Response message to power cycle the ThingMagic reader request
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 4;
            
        }
      
        public PARAM_LLRPStatus LLRPStatus;
                
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS obj = new MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS msg = new MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
            if (xnl.Count != 0)
            {
                msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
            }
                
            }
        
            {
          
            string[] excl = new string[] { "LLRPStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_RESPONSE_RESET_STATISTICS;
        }
  
    }
    
        ///<summary>
        ///
        ///Time stamp when reader statistics are reset
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 5;
            
        }
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME obj = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME msg = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_REQUEST_GET_RESET_TIME;
        }
  
    }
    
        ///<summary>
        ///
        ///Response message to Get reset statistics time stamp request 
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 6;
            
        }
      
        public PARAM_LLRPStatus LLRPStatus;
                
        public UInt64 Microseconds=0;
        private Int16 Microseconds_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (Microseconds != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME obj = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 64;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            obj.Microseconds = (UInt64)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (Microseconds != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Microseconds>" + Util.ConvertValueTypeToString(Microseconds, "u64", "Datetime") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "Microseconds>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME msg = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
            if (xnl.Count != 0)
            {
                msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
            }
                
            }
        
            val = XmlUtil.GetNodeValue(node, "Microseconds");
          
            msg.Microseconds = (UInt64)(Util.ParseValueTypeFromString(val, "u64", "Datetime"));
            
            {
          
            string[] excl = new string[] { "LLRPStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_RESPONSE_GET_RESET_TIME;
        }
  
    }
    
        ///<summary>
        ///
        ///Request to get Reader Antenna statistics.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 7;
            
        }
      
        public UInt16 AntennaID=0;
        private Int16 AntennaID_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (AntennaID != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS obj = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 16;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.AntennaID = (UInt16)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (AntennaID != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaID>" + Util.ConvertValueTypeToString(AntennaID, "u16", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "AntennaID>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS msg = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            val = XmlUtil.GetNodeValue(node, "AntennaID");
          
            msg.AntennaID = (UInt16)(Util.ParseValueTypeFromString(val, "u16", ""));
            
            {
          
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_REQUEST_GET_ANTENNA_STATS;
        }
  
    }
    
        ///<summary>
        ///
        ///Response message to get reader antenna statistics request
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 8;
            
        }
      
        public PARAM_LLRPStatus LLRPStatus;
                
        public UInt32 TagsIdentified=0;
        private Int16 TagsIdentified_len=0;
      
        public UInt32 TagsNotIdentified=0;
        private Int16 TagsNotIdentified_len=0;
      
        public UInt32 MemoryReadFailures=0;
        private Int16 MemoryReadFailures_len=0;
      
        public UInt32 WriteOperations=0;
        private Int16 WriteOperations_len=0;
      
        public UInt32 WriteFailures=0;
        private Int16 WriteFailures_len=0;
      
        public UInt32 KillOperations=0;
        private Int16 KillOperations_len=0;
      
        public UInt32 KillFailures=0;
        private Int16 KillFailures_len=0;
      
        public UInt32 EraseOperations=0;
        private Int16 EraseOperations_len=0;
      
        public UInt32 EraseFailures=0;
        private Int16 EraseFailures_len=0;
      
        public UInt32 LockOperations=0;
        private Int16 LockOperations_len=0;
      
        public UInt32 LockFailures=0;
        private Int16 LockFailures_len=0;
      
        public UInt32 NoiseLevel=0;
        private Int16 NoiseLevel_len=0;
      
        public UInt32 TimeEnergised=0;
        private Int16 TimeEnergised_len=0;
      
        public UInt32 PowerLevel=0;
        private Int16 PowerLevel_len=0;
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (TagsIdentified != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagsIdentified, TagsIdentified_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TagsNotIdentified != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagsNotIdentified, TagsNotIdentified_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (MemoryReadFailures != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MemoryReadFailures, MemoryReadFailures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (WriteOperations != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WriteOperations, WriteOperations_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (WriteFailures != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WriteFailures, WriteFailures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillOperations != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillOperations, KillOperations_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (KillFailures != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillFailures, KillFailures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EraseOperations != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EraseOperations, EraseOperations_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (EraseFailures != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EraseFailures, EraseFailures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LockOperations != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LockOperations, LockOperations_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (LockFailures != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LockFailures, LockFailures_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (NoiseLevel != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NoiseLevel, NoiseLevel_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (TimeEnergised != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TimeEnergised, TimeEnergised_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (PowerLevel != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PowerLevel, PowerLevel_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS obj = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.TagsIdentified = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.TagsNotIdentified = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.MemoryReadFailures = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.WriteOperations = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.WriteFailures = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillOperations = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.KillFailures = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.EraseOperations = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.EraseFailures = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.LockOperations = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.LockFailures = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.NoiseLevel = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.TimeEnergised = (UInt32)obj_val;
          
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 32;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.PowerLevel = (UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (TagsIdentified != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagsIdentified>" + Util.ConvertValueTypeToString(TagsIdentified, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagsIdentified>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (TagsNotIdentified != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagsNotIdentified>" + Util.ConvertValueTypeToString(TagsNotIdentified, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TagsNotIdentified>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (MemoryReadFailures != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MemoryReadFailures>" + Util.ConvertValueTypeToString(MemoryReadFailures, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "MemoryReadFailures>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (WriteOperations != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteOperations>" + Util.ConvertValueTypeToString(WriteOperations, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteOperations>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (WriteFailures != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteFailures>" + Util.ConvertValueTypeToString(WriteFailures, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "WriteFailures>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (KillOperations != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillOperations>" + Util.ConvertValueTypeToString(KillOperations, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillOperations>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (KillFailures != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillFailures>" + Util.ConvertValueTypeToString(KillFailures, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "KillFailures>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (EraseOperations != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EraseOperations>" + Util.ConvertValueTypeToString(EraseOperations, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EraseOperations>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (EraseFailures != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EraseFailures>" + Util.ConvertValueTypeToString(EraseFailures, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "EraseFailures>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (LockOperations != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockOperations>" + Util.ConvertValueTypeToString(LockOperations, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockOperations>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (LockFailures != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockFailures>" + Util.ConvertValueTypeToString(LockFailures, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "LockFailures>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (NoiseLevel != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NoiseLevel>" + Util.ConvertValueTypeToString(NoiseLevel, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "NoiseLevel>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (TimeEnergised != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TimeEnergised>" + Util.ConvertValueTypeToString(TimeEnergised, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "TimeEnergised>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (PowerLevel != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PowerLevel>" + Util.ConvertValueTypeToString(PowerLevel, "u32", "") + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "PowerLevel>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS msg = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
            if (xnl.Count != 0)
            {
                msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
            }
                
            }
        
            val = XmlUtil.GetNodeValue(node, "TagsIdentified");
          
            msg.TagsIdentified = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "TagsNotIdentified");
          
            msg.TagsNotIdentified = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "MemoryReadFailures");
          
            msg.MemoryReadFailures = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "WriteOperations");
          
            msg.WriteOperations = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "WriteFailures");
          
            msg.WriteFailures = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "KillOperations");
          
            msg.KillOperations = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "KillFailures");
          
            msg.KillFailures = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "EraseOperations");
          
            msg.EraseOperations = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "EraseFailures");
          
            msg.EraseFailures = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "LockOperations");
          
            msg.LockOperations = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "LockFailures");
          
            msg.LockFailures = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "NoiseLevel");
          
            msg.NoiseLevel = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "TimeEnergised");
          
            msg.TimeEnergised = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            val = XmlUtil.GetNodeValue(node, "PowerLevel");
          
            msg.PowerLevel = (UInt32)(Util.ParseValueTypeFromString(val, "u32", ""));
            
            {
          
            string[] excl = new string[] { "LLRPStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_RESPONSE_GET_ANTENNA_STATS;
        }
  
    }
    
        ///<summary>
        ///
        ///Request to get Reader device status.
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 11;
            
        }
      
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS obj = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS</returns>
        public new static MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS msg = new MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            string[] excl = new string[] {  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_REQUEST_GET_READER_STATUS;
        }
  
    }
    
        ///<summary>
        ///
        ///Response message to power cycle the ThingMagic reader request
        ///
        ///For more information, please refer to:
        ///
        ///</summary>
    public class MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS : MSG_CUSTOM_MESSAGE
    {
        public UInt32 VENDOR_ID
        {
            get { return VendorIdentifier; }
        }

        public Byte SUB_TYPE
        {
            get { return MessageSubtype; }
        }

        public MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS()
        {
            VendorIdentifier = 26554;
            MessageSubtype = 12;
            
        }
      
        public PARAM_LLRPStatus LLRPStatus;
                
        public ENUM_ThingMagicReaderOperatingStatus ReaderDeviceOperatingStatus;
        private Int16 ReaderDeviceOperatingStatus_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();

        public bool AddCustomParameter(ICustom_Parameter param)
        {
            ITHINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS_Custom_Param custom =
                param as ITHINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS_Custom_Param;
            if (custom != null)
            {
                Custom.Add(param);
                return true;
            }

            if (param.GetType() == typeof(PARAM_Custom))
            {
                Custom.Add(param);
                return true;
            }

            return false;
        }
            
        /// <summary>
        /// Encode message to boolean (bit) array
        /// </summary>
        /// <returns>boolean array</returns>
        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[4*1024*1024*8]; // Handle messages up to 4 MB

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(VendorIdentifier, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(MessageSubtype, 8);
            bArr.CopyTo(bit_array, cursor);

            cursor += 8;
    
            if (LLRPStatus != null)
            {
        LLRPStatus.ToBitArray(ref bit_array, ref cursor);
          
            }
      
            if (ReaderDeviceOperatingStatus != null)
            {
        
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReaderDeviceOperatingStatus, ReaderDeviceOperatingStatus_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }
          
            }
      
            if (Custom != null)
            {
        
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    Custom[i].ToBitArray(ref bit_array, ref cursor);
                }
          
            }
      

            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len ,32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);

            return boolArr;
        }
  
        /// <summary>
        /// Decode bit array to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS
        /// </summary>
        /// <param name="bit_array">input bit array</param>
        /// <param name="cursor">pointer to current position</param>
        /// <param name="length">data length</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            UInt16 loop_control_counter = 1;    // Used for control choice element parsing loop

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS obj = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -=16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);

            obj.VendorID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.SubType = (byte)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 8);

    
            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);
            
            if (cursor > length)
                throw new Exception("Input data is not a complete LLRP message");
        
            field_len = 8;
        
            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ReaderDeviceOperatingStatus = (ENUM_ThingMagicReaderOperatingStatus)(UInt32)obj_val;
          
            while (true)
            {
                int temp_cursor = cursor;
                bool success = false;
                ICustom_Parameter custom =
                    CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
                if (custom != null)
                {
                    if (obj.AddCustomParameter(custom))
                    {
                        success = true;
                    }
                }

                if (!success)
                {
                    cursor = temp_cursor;
                    break;
                }
            }
          
            return obj;
        }
  
        /// <summary>
        /// Serialize native message to xml string
        /// </summary>
        /// <returns>Xml string</returns>
        public override string ToString()
        {
            int len;
            string xml_str = "<" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS";
            xml_str += string.Format(" xmlns=\"{0}\"\n", LLRPConstants.NAMESPACE_URI);
            xml_str += " xmlns:" + LLRPExtensionConstants.NAMESPACE_PREFIX + "=\"" + LLRPExtensionConstants.NAMESPACE_URI + "\"\n";
            xml_str += " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
            xml_str += string.Format(" xsi:schemaLocation=\"{0} {1} {2} {3}\"\n", LLRPConstants.NAMESPACE_URI, LLRPConstants.NAMESPACE_SCHEMALOCATION, LLRPExtensionConstants.NAMESPACE_URI, LLRPExtensionConstants.NAMESPACE_SCHEMALOCATION);
            xml_str += " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">" + "\r\n";
    
            if (LLRPStatus != null)
            {
          
                xml_str += Util.Indent(LLRPStatus.ToString());
                
            }
        
            if (ReaderDeviceOperatingStatus != null)
            {
                try
                {
          
                    xml_str += "  <" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderDeviceOperatingStatus>" + ReaderDeviceOperatingStatus.ToString() + "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "ReaderDeviceOperatingStatus>";
            
	                xml_str += "\r\n";
	            }
                catch { }
            }
        
            if (Custom != null)
            {
          
                len = Custom.Length;
                for (int i=0; i<len; i++)
                {
                    xml_str += Util.Indent(Custom[i].ToString());
                }
            
            }
        
            xml_str += "</" + LLRPExtensionConstants.NAMESPACE_PREFIX + ":" + "THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS>";
            return xml_str;
        }
  
        /// <summary>
        /// Deserialize a xml string to a MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS
        /// </summary>
        /// <param name="str">Input Xml string</param>
        /// <returns>MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS</returns>
        public new static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS FromString(string str)
        {
            string count;
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(node.OwnerDocument.NameTable);
            nsmgr.AddNamespace("", LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPConstants.NAMESPACE_PREFIX, LLRPConstants.NAMESPACE_URI);
            nsmgr.AddNamespace(LLRPExtensionConstants.NAMESPACE_PREFIX, LLRPExtensionConstants.NAMESPACE_URI);

            MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS msg = new MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS();
            try { msg.MSG_ID = Convert.ToUInt16(XmlUtil.GetNodeAttrValue(node, "MessageID")); } catch { }

    
            {
          
            XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus", nsmgr);
            if (xnl.Count != 0)
            {
                msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
            }
                
            }
        
            val = XmlUtil.GetNodeValue(node, "ReaderDeviceOperatingStatus");
          
            msg.ReaderDeviceOperatingStatus = (ENUM_ThingMagicReaderOperatingStatus)Enum.Parse(typeof(ENUM_ThingMagicReaderOperatingStatus), val);
            
            {
          
            string[] excl = new string[] { "LLRPStatus",  };
            ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node, excl, nsmgr);
            if (xnl != null)
            {
                for(int i=0; i<xnl.Count; i++)
                {
                    ICustom_Parameter custom =
                        CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                    if (custom != null)
                    {
                        msg.AddCustomParameter(custom);
                    }
                }
            }
            
            }
        
            return msg;
        }
  
        /// <summary>
        /// Convert a vendor extended message to MSG_CUSTOM_MESSAGE (deprecated)
        /// </summary>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public MSG_CUSTOM_MESSAGE ToCustomMessage()
        {
            return (MSG_CUSTOM_MESSAGE)this;
        }
  
        /// <summary>
        /// Parse MSG_CUSTOM_MESSAGE to vendor extended message (deprecated)
        /// </summary>
        /// <param name="msg">Custom message to be parsed</param>
        /// <returns>Vendor extended message</returns>
        [Obsolete("Custom messages are derived from MSG_CUSTOM_MESSAGE")]
        public static MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS FromCustomMessage(MSG_CUSTOM_MESSAGE msg)
        {
            return msg as MSG_THINGMAGIC_CONTROL_RESPONSE_GET_READER_STATUS;
        }
  
    }
    
}
  